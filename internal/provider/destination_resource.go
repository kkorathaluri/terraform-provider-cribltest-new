// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/numberdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/numberplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	speakeasy_boolplanmodifier "github.com/speakeasy/terraform-provider-cribl-terraform/internal/planmodifiers/boolplanmodifier"
	speakeasy_int64planmodifier "github.com/speakeasy/terraform-provider-cribl-terraform/internal/planmodifiers/int64planmodifier"
	speakeasy_listplanmodifier "github.com/speakeasy/terraform-provider-cribl-terraform/internal/planmodifiers/listplanmodifier"
	speakeasy_numberplanmodifier "github.com/speakeasy/terraform-provider-cribl-terraform/internal/planmodifiers/numberplanmodifier"
	speakeasy_objectplanmodifier "github.com/speakeasy/terraform-provider-cribl-terraform/internal/planmodifiers/objectplanmodifier"
	speakeasy_stringplanmodifier "github.com/speakeasy/terraform-provider-cribl-terraform/internal/planmodifiers/stringplanmodifier"
	tfTypes "github.com/speakeasy/terraform-provider-cribl-terraform/internal/provider/types"
	"github.com/speakeasy/terraform-provider-cribl-terraform/internal/sdk"
	"github.com/speakeasy/terraform-provider-cribl-terraform/internal/validators"
	speakeasy_listvalidators "github.com/speakeasy/terraform-provider-cribl-terraform/internal/validators/listvalidators"
	speakeasy_numbervalidators "github.com/speakeasy/terraform-provider-cribl-terraform/internal/validators/numbervalidators"
	speakeasy_objectvalidators "github.com/speakeasy/terraform-provider-cribl-terraform/internal/validators/objectvalidators"
	speakeasy_stringvalidators "github.com/speakeasy/terraform-provider-cribl-terraform/internal/validators/stringvalidators"
	"math/big"
	"regexp"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &DestinationResource{}
var _ resource.ResourceWithImportState = &DestinationResource{}

func NewDestinationResource() resource.Resource {
	return &DestinationResource{}
}

// DestinationResource defines the resource implementation.
type DestinationResource struct {
	client *sdk.CriblTerraform
}

// DestinationResourceModel describes the resource data model.
type DestinationResourceModel struct {
	CountTotal                   types.Int64                           `tfsdk:"count_total"`
	OutputAzureBlob              *tfTypes.OutputAzureBlob              `queryParam:"inline" tfsdk:"output_azure_blob" tfPlanOnly:"true"`
	OutputAzureDataExplorer      *tfTypes.OutputAzureDataExplorer      `queryParam:"inline" tfsdk:"output_azure_data_explorer" tfPlanOnly:"true"`
	OutputAzureEventhub          *tfTypes.OutputAzureEventhub          `queryParam:"inline" tfsdk:"output_azure_eventhub" tfPlanOnly:"true"`
	OutputAzureLogs              *tfTypes.OutputAzureLogs              `queryParam:"inline" tfsdk:"output_azure_logs" tfPlanOnly:"true"`
	OutputClickHouse             *tfTypes.OutputClickHouse             `queryParam:"inline" tfsdk:"output_click_house" tfPlanOnly:"true"`
	OutputCloudwatch             *tfTypes.OutputCloudwatch             `queryParam:"inline" tfsdk:"output_cloudwatch" tfPlanOnly:"true"`
	OutputConfluentCloud         *tfTypes.OutputConfluentCloud         `queryParam:"inline" tfsdk:"output_confluent_cloud" tfPlanOnly:"true"`
	OutputCriblHTTP              *tfTypes.OutputCriblHTTP              `queryParam:"inline" tfsdk:"output_cribl_http" tfPlanOnly:"true"`
	OutputCriblLake              *tfTypes.OutputCriblLake              `queryParam:"inline" tfsdk:"output_cribl_lake" tfPlanOnly:"true"`
	OutputCriblTCP               *tfTypes.OutputCriblTCP               `queryParam:"inline" tfsdk:"output_cribl_tcp" tfPlanOnly:"true"`
	OutputCrowdstrikeNextGenSiem *tfTypes.OutputCrowdstrikeNextGenSiem `queryParam:"inline" tfsdk:"output_crowdstrike_next_gen_siem" tfPlanOnly:"true"`
	OutputDatadog                *tfTypes.OutputDatadog                `queryParam:"inline" tfsdk:"output_datadog" tfPlanOnly:"true"`
	OutputDataset                *tfTypes.OutputDataset                `queryParam:"inline" tfsdk:"output_dataset" tfPlanOnly:"true"`
	OutputDefault                *tfTypes.OutputDefault                `queryParam:"inline" tfsdk:"output_default" tfPlanOnly:"true"`
	OutputDevnull                *tfTypes.OutputDevnull                `queryParam:"inline" tfsdk:"output_devnull" tfPlanOnly:"true"`
	OutputDiskSpool              *tfTypes.OutputDiskSpool              `queryParam:"inline" tfsdk:"output_disk_spool" tfPlanOnly:"true"`
	OutputDlS3                   *tfTypes.OutputDlS3                   `queryParam:"inline" tfsdk:"output_dl_s3" tfPlanOnly:"true"`
	OutputDynatraceHTTP          *tfTypes.OutputDynatraceHTTP          `queryParam:"inline" tfsdk:"output_dynatrace_http" tfPlanOnly:"true"`
	OutputDynatraceOtlp          *tfTypes.OutputDynatraceOtlp          `queryParam:"inline" tfsdk:"output_dynatrace_otlp" tfPlanOnly:"true"`
	OutputElastic                *tfTypes.OutputElastic                `queryParam:"inline" tfsdk:"output_elastic" tfPlanOnly:"true"`
	OutputElasticCloud           *tfTypes.OutputElasticCloud           `queryParam:"inline" tfsdk:"output_elastic_cloud" tfPlanOnly:"true"`
	OutputExabeam                *tfTypes.OutputExabeam                `queryParam:"inline" tfsdk:"output_exabeam" tfPlanOnly:"true"`
	OutputFilesystem             *tfTypes.OutputFilesystem             `queryParam:"inline" tfsdk:"output_filesystem" tfPlanOnly:"true"`
	OutputGoogleChronicle        *tfTypes.OutputGoogleChronicle        `queryParam:"inline" tfsdk:"output_google_chronicle" tfPlanOnly:"true"`
	OutputGoogleCloudLogging     *tfTypes.OutputGoogleCloudLogging     `queryParam:"inline" tfsdk:"output_google_cloud_logging" tfPlanOnly:"true"`
	OutputGoogleCloudStorage     *tfTypes.OutputGoogleCloudStorage     `queryParam:"inline" tfsdk:"output_google_cloud_storage" tfPlanOnly:"true"`
	OutputGooglePubsub           *tfTypes.OutputGooglePubsub           `queryParam:"inline" tfsdk:"output_google_pubsub" tfPlanOnly:"true"`
	OutputGrafanaCloud           *tfTypes.OutputGrafanaCloud           `queryParam:"inline" tfsdk:"output_grafana_cloud" tfPlanOnly:"true"`
	OutputGraphite               *tfTypes.OutputGraphite               `queryParam:"inline" tfsdk:"output_graphite" tfPlanOnly:"true"`
	OutputHoneycomb              *tfTypes.OutputHoneycomb              `queryParam:"inline" tfsdk:"output_honeycomb" tfPlanOnly:"true"`
	OutputHumioHec               *tfTypes.OutputHumioHec               `queryParam:"inline" tfsdk:"output_humio_hec" tfPlanOnly:"true"`
	OutputInfluxdb               *tfTypes.OutputInfluxdb               `queryParam:"inline" tfsdk:"output_influxdb" tfPlanOnly:"true"`
	OutputKafka                  *tfTypes.OutputKafka                  `queryParam:"inline" tfsdk:"output_kafka" tfPlanOnly:"true"`
	OutputKinesis                *tfTypes.OutputKinesis                `queryParam:"inline" tfsdk:"output_kinesis" tfPlanOnly:"true"`
	OutputLoki                   *tfTypes.OutputLoki                   `queryParam:"inline" tfsdk:"output_loki" tfPlanOnly:"true"`
	OutputMinio                  *tfTypes.OutputMinio                  `queryParam:"inline" tfsdk:"output_minio" tfPlanOnly:"true"`
	OutputMsk                    *tfTypes.OutputMsk                    `queryParam:"inline" tfsdk:"output_msk" tfPlanOnly:"true"`
	OutputNetflow                *tfTypes.OutputNetflow                `queryParam:"inline" tfsdk:"output_netflow" tfPlanOnly:"true"`
	OutputNewrelic               *tfTypes.OutputNewrelic               `queryParam:"inline" tfsdk:"output_newrelic" tfPlanOnly:"true"`
	OutputNewrelicEvents         *tfTypes.OutputNewrelicEvents         `queryParam:"inline" tfsdk:"output_newrelic_events" tfPlanOnly:"true"`
	OutputOpenTelemetry          *tfTypes.OutputOpenTelemetry          `queryParam:"inline" tfsdk:"output_open_telemetry" tfPlanOnly:"true"`
	OutputPrometheus             *tfTypes.OutputPrometheus             `queryParam:"inline" tfsdk:"output_prometheus" tfPlanOnly:"true"`
	OutputRing                   *tfTypes.OutputRing                   `queryParam:"inline" tfsdk:"output_ring" tfPlanOnly:"true"`
	OutputRouter                 *tfTypes.OutputRouter                 `queryParam:"inline" tfsdk:"output_router" tfPlanOnly:"true"`
	OutputS3                     *tfTypes.OutputS3                     `queryParam:"inline" tfsdk:"output_s3" tfPlanOnly:"true"`
	OutputSecurityLake           *tfTypes.OutputSecurityLake           `queryParam:"inline" tfsdk:"output_security_lake" tfPlanOnly:"true"`
	OutputSentinel               *tfTypes.OutputSentinel               `queryParam:"inline" tfsdk:"output_sentinel" tfPlanOnly:"true"`
	OutputServiceNow             *tfTypes.OutputServiceNow             `queryParam:"inline" tfsdk:"output_service_now" tfPlanOnly:"true"`
	OutputSignalfx               *tfTypes.OutputSignalfx               `queryParam:"inline" tfsdk:"output_signalfx" tfPlanOnly:"true"`
	OutputSnmp                   *tfTypes.OutputSnmp                   `queryParam:"inline" tfsdk:"output_snmp" tfPlanOnly:"true"`
	OutputSns                    *tfTypes.OutputSns                    `queryParam:"inline" tfsdk:"output_sns" tfPlanOnly:"true"`
	OutputSplunk                 *tfTypes.OutputSplunk                 `queryParam:"inline" tfsdk:"output_splunk" tfPlanOnly:"true"`
	OutputSplunkHec              *tfTypes.OutputSplunkHec              `queryParam:"inline" tfsdk:"output_splunk_hec" tfPlanOnly:"true"`
	OutputSplunkLb               *tfTypes.OutputSplunkLb               `queryParam:"inline" tfsdk:"output_splunk_lb" tfPlanOnly:"true"`
	OutputSqs                    *tfTypes.OutputSqs                    `queryParam:"inline" tfsdk:"output_sqs" tfPlanOnly:"true"`
	OutputStatsd                 *tfTypes.OutputStatsd                 `queryParam:"inline" tfsdk:"output_statsd" tfPlanOnly:"true"`
	OutputStatsdExt              *tfTypes.OutputStatsdExt              `queryParam:"inline" tfsdk:"output_statsd_ext" tfPlanOnly:"true"`
	OutputSumoLogic              *tfTypes.OutputSumoLogic              `queryParam:"inline" tfsdk:"output_sumo_logic" tfPlanOnly:"true"`
	OutputSyslog                 *tfTypes.OutputSyslog                 `queryParam:"inline" tfsdk:"output_syslog" tfPlanOnly:"true"`
	OutputTcpjson                *tfTypes.OutputTcpjson                `queryParam:"inline" tfsdk:"output_tcpjson" tfPlanOnly:"true"`
	OutputWavefront              *tfTypes.OutputWavefront              `queryParam:"inline" tfsdk:"output_wavefront" tfPlanOnly:"true"`
	OutputWebhook                *tfTypes.OutputWebhook                `queryParam:"inline" tfsdk:"output_webhook" tfPlanOnly:"true"`
	OutputXsiam                  *tfTypes.OutputXsiam                  `queryParam:"inline" tfsdk:"output_xsiam" tfPlanOnly:"true"`
}

func (r *DestinationResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_destination"
}

func (r *DestinationResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Destination Resource",
		Attributes: map[string]schema.Attribute{
			"count_total": schema.Int64Attribute{
				Computed:    true,
				Description: `number of items present in the items array`,
			},
			"output_azure_blob": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"add_id_to_stage_path": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Append output's ID to staging location. Default: true; Requires replacement if changed.`,
					},
					"auth_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`manual`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Enter connection string directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret", "clientSecret", "clientCert"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"manual",
								"secret",
								"clientSecret",
								"clientCert",
							),
						},
					},
					"automatic_schema": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Automatically calculate the schema based on the events of each Parquet file generated. Default: false; Requires replacement if changed.`,
					},
					"base_file_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`` + "`" + `CriblOut` + "`" + ``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to define the output filename prefix (can be constant). Default: "` + "`" + `CriblOut` + "`" + `"; Requires replacement if changed.`,
					},
					"certificate": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"certificate_name": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The certificate you registered as credentials for your app in the Azure portal. Not Null; Requires replacement if changed.`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"client_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The service principal's client ID. Requires replacement if changed.`,
					},
					"client_text_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`gzip`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Choose data compression format to apply before moving files to final destination. Default: "gzip"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"compression_level": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`best_speed`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Compression level to apply before moving files to final destination. Default: "best_speed"; must be one of ["best_speed", "normal", "best_compression"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"best_speed",
								"normal",
								"best_compression",
							),
						},
					},
					"connection_string": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING. Requires replacement if changed.`,
					},
					"container_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A container organizes a set of blobs, similar to a directory in a file system. Value can be a JavaScript expression enclosed in quotes or backticks. @{product} evaluates the expression at init time. The expression can evaluate to a constant value, and can reference Global Variables, e.g., ` + "`" + `myContainer-${C.env["CRIBL_WORKER_ID"]}` + "`" + `. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"create_container": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Creates the configured container in Azure Blob Storage if it does not already exist. Default: false; Requires replacement if changed.`,
					},
					"deadletter_enabled": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors. Default: false; Requires replacement if changed.`,
					},
					"deadletter_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/outputs/dead-letter`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Storage location for files that fail to reach their final destination after maximum retries are exceeded. Default: "$CRIBL_HOME/state/outputs/dead-letter"; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"dest_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks. @{product} evaluates the expression at init time. The expression can evaluate to a constant value, and can reference Global Variables, e.g., ` + "`" + `myBlobPrefix-${C.env["CRIBL_WORKER_ID"]}` + "`" + `. Requires replacement if changed.`,
					},
					"empty_dir_cleanup_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How frequently, in seconds, to clean up empty directories when 'Remove empty staging dirs' is enabled. Default: 300; Requires replacement if changed.`,
					},
					"enable_page_checksum": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Parquet tools can use the checksum of a Parquet page to verify data integrity. Default: false; Requires replacement if changed.`,
					},
					"enable_statistics": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics. Default: true; Requires replacement if changed.`,
					},
					"enable_write_page_index": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping. Default: true; Requires replacement if changed.`,
					},
					"endpoint_suffix": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Endpoint suffix for the service URL. Defaults to core.windows.net. Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"file_name_suffix": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`` + "`" + `.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}` + "`" + ``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to define the output filename suffix (can be constant).  The ` + "`" + `__format` + "`" + ` variable refers to the value of the ` + "`" + `Data format` + "`" + ` field (` + "`" + `json` + "`" + ` or ` + "`" + `raw` + "`" + `).  The ` + "`" + `__compression` + "`" + ` field refers to the kind of compression being used (` + "`" + `none` + "`" + ` or ` + "`" + `gzip` + "`" + `). Default: "` + "`" + `.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}` + "`" + `"; Requires replacement if changed.`,
					},
					"format": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`json`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Format of the output data. Default: "json"; must be one of ["json", "raw", "parquet"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"json",
								"raw",
								"parquet",
							),
						},
					},
					"header_line": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `If set, this line will be written to the beginning of each output file. Default: ""; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"key_value_metadata": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed: true,
									Optional: true,
									Default:  stringdefault.StaticString(``),
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Default: ""; Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging, e.g., "key":"OCSF Event Class", "value":"9001". Requires replacement if changed.`,
					},
					"max_concurrent_file_parts": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of parts to upload in parallel per file. Default: 1; Requires replacement if changed.`,
					},
					"max_file_idle_time_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30; Requires replacement if changed.`,
					},
					"max_file_open_time_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300; Requires replacement if changed.`,
					},
					"max_file_size_mb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(32)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 32; Requires replacement if changed.`,
					},
					"max_open_files": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(100)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100; Requires replacement if changed.`,
					},
					"max_retry_num": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(20)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum number of times a file will attempt to move to its final destination before being dead-lettered. Default: 20; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"on_disk_full_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"parquet_data_page_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`DATA_PAGE_V2`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it. Default: "DATA_PAGE_V2"; must be one of ["DATA_PAGE_V1", "DATA_PAGE_V2"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"DATA_PAGE_V1",
								"DATA_PAGE_V2",
							),
						},
					},
					"parquet_page_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression. Default: "1MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:[kK][bB]|[mM][bB]|[gG][bB]|[tT][bB])?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:[kK][bB]|[mM][bB]|[gG][bB]|[tT][bB])?$`).String()),
						},
					},
					"parquet_row_group_length": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The number of rows that every group will contain. The final group can contain a smaller number of rows. Default: 10000; Requires replacement if changed.`,
					},
					"parquet_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`PARQUET_2_6`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Determines which data types are supported and how they are represented. Default: "PARQUET_2_6"; must be one of ["PARQUET_1_0", "PARQUET_2_4", "PARQUET_2_6"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"PARQUET_1_0",
								"PARQUET_2_4",
								"PARQUET_2_6",
							),
						},
					},
					"partition_expr": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory. Default: "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"; Requires replacement if changed.`,
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"remove_empty_dirs": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Remove empty staging directories after moving files. Default: true; Requires replacement if changed.`,
					},
					"should_log_invalid_rows": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Log up to 3 rows that @{product} skips due to data mismatch. Requires replacement if changed.`,
					},
					"stage_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/outputs/staging`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage. Default: "$CRIBL_HOME/state/outputs/staging"; Requires replacement if changed.`,
					},
					"storage_account_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The name of your Azure storage account. Requires replacement if changed.`,
					},
					"storage_class": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`Inferred`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default: "Inferred"; must be one of ["Inferred", "Hot", "Cool", "Cold", "Archive"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"Inferred",
								"Hot",
								"Cool",
								"Cold",
								"Archive",
							),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"tenant_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The service principal's tenant ID. Requires replacement if changed.`,
					},
					"text_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "azure_blob"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"azure_blob",
							),
						},
					},
					"write_high_water_mark": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(64)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Buffer size used to write to a file. Default: 64; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_azure_data_explorer": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"add_id_to_stage_path": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Append output's ID to staging location. Default: true; Requires replacement if changed.`,
					},
					"additional_properties": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
										stringvalidator.RegexMatches(regexp.MustCompile(`^[\w\-\.]+$`), "must match pattern "+regexp.MustCompile(`^[\w\-\.]+$`).String()),
									},
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Optionally, enter additional configuration properties to send to the ingestion service. Requires replacement if changed.`,
					},
					"certificate": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"certificate_name": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The certificate you registered as credentials for your app in the Azure portal. Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"client_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `client_id to pass in the OAuth request parameter. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"client_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The client secret that you generated for your app in the Azure portal. Requires replacement if changed.`,
					},
					"cluster_url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The base URI for your cluster. Typically, ` + "`" + `https://<cluster>.<region>.kusto.windows.net` + "`" + `. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.RegexMatches(regexp.MustCompile(`^https://[a-zA-Z0-9\-]+.(\w+).(kusto.fabric.microsoft.com|kusto.(windows|usgovcloudapi).net)$`), "must match pattern "+regexp.MustCompile(`^https://[a-zA-Z0-9\-]+.(\w+).(kusto.fabric.microsoft.com|kusto.(windows|usgovcloudapi).net)$`).String()),
						},
					},
					"compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`gzip`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Choose data compression format to apply to HTTP content before it is delivered. Default: "gzip"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"database": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the database containing the table where data will be ingested. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.UTF8LengthAtMost(260),
							stringvalidator.RegexMatches(regexp.MustCompile(`^[\w\s\-\.]+$`), "must match pattern "+regexp.MustCompile(`^[\w\s\-\.]+$`).String()),
						},
					},
					"deadletter_enabled": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors. Default: false; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"extent_tags": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"prefix": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `must be one of ["dropBy", "ingestBy"]; Requires replacement if changed.`,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"dropBy",
											"ingestBy",
										),
									},
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Strings or tags associated with the extent (ingested data shard). Requires replacement if changed.`,
					},
					"file_name_suffix": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`` + "`" + `.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}` + "`" + ``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to define the output filename suffix (can be constant).  The ` + "`" + `__format` + "`" + ` variable refers to the value of the ` + "`" + `Data format` + "`" + ` field (` + "`" + `json` + "`" + ` or ` + "`" + `raw` + "`" + `).  The ` + "`" + `__compression` + "`" + ` field refers to the kind of compression being used (` + "`" + `none` + "`" + ` or ` + "`" + `gzip` + "`" + `). Default: "` + "`" + `.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}` + "`" + `"; Requires replacement if changed.`,
					},
					"flush_immediately": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enable to bypass the data management service's aggregation mechanism. Default: false; Requires replacement if changed.`,
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"format": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`json`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Format of the output data. Default: "json"; must be one of ["json", "raw", "parquet"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"json",
								"raw",
								"parquet",
							),
						},
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"ingest_if_not_exists": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Prevents duplicate ingestion by checking if an extent with the specified ingest-by tag already exists. Requires replacement if changed.`,
					},
					"ingest_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`batching`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Method to use for ingesting data. Default: "batching"; must be one of ["batching", "streaming"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"batching",
								"streaming",
							),
						},
					},
					"ingest_url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The ingestion service URI for your cluster. Typically, ` + "`" + `https://ingest-<cluster>.<region>.kusto.windows.net` + "`" + `. Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^https://[a-zA-Z0-9\-]+.(\w+).(kusto.fabric.microsoft.com|kusto.(windows|usgovcloudapi).net)$`), "must match pattern "+regexp.MustCompile(`^https://[a-zA-Z0-9\-]+.(\w+).(kusto.fabric.microsoft.com|kusto.(windows|usgovcloudapi).net)$`).String()),
						},
					},
					"is_mapping_obj": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enable if you want to send a (JSON) mapping object instead of specifying an existing named data mapping. Default: false; Requires replacement if changed.`,
					},
					"keep_alive": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Disable to close the connection immediately after sending the outgoing request. Default: true; Requires replacement if changed.`,
					},
					"mapping_ref": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Enter the name of a data mapping associated with your target table. Or, if incoming event and target table fields match exactly, you can leave the field empty. Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^[\w\-\.]+$`), "must match pattern "+regexp.MustCompile(`^[\w\-\.]+$`).String()),
						},
					},
					"max_concurrent_file_parts": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of parts to upload in parallel per file. Default: 1; Requires replacement if changed.`,
					},
					"max_file_idle_time_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30; Requires replacement if changed.`,
					},
					"max_file_open_time_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300; Requires replacement if changed.`,
					},
					"max_file_size_mb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(32)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 32; Requires replacement if changed.`,
					},
					"max_open_files": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(100)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100; Requires replacement if changed.`,
					},
					"max_payload_events": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(4096)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size, in KB, of the request body. Default: 4096; Requires replacement if changed.`,
					},
					"oauth_endpoint": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`https://login.microsoftonline.com`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Endpoint used to acquire authentication tokens from Azure. Default: "https://login.microsoftonline.com"; must be one of ["https://login.microsoftonline.com", "https://login.microsoftonline.us", "https://login.partner.microsoftonline.cn"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"https://login.microsoftonline.com",
								"https://login.microsoftonline.us",
								"https://login.partner.microsoftonline.cn",
							),
						},
					},
					"oauth_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`clientSecret`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The type of OAuth 2.0 client credentials grant flow to use. Default: "clientSecret"; must be one of ["clientSecret", "clientTextSecret", "certificate"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"clientSecret",
								"clientTextSecret",
								"certificate",
							),
						},
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"on_disk_full_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"remove_empty_dirs": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Remove empty staging directories after moving files. Default: true; Requires replacement if changed.`,
					},
					"report_level": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`failuresOnly`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Level of ingestion status reporting. Defaults to FailuresOnly. Default: "failuresOnly"; must be one of ["failuresOnly", "doNotReport", "failuresAndSuccesses"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"failuresOnly",
								"doNotReport",
								"failuresAndSuccesses",
							),
						},
					},
					"report_method": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`queue`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Target of the ingestion status reporting. Defaults to Queue. Default: "queue"; must be one of ["queue", "table", "queueAndTable"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"queue",
								"table",
								"queueAndTable",
							),
						},
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"retain_blob_on_success": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enable to prevent blob deletion after ingestion is complete. Default: false; Requires replacement if changed.`,
					},
					"scope": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Scope to pass in the OAuth request parameter. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"stage_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/outputs/staging`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage. Default: "$CRIBL_HOME/state/outputs/staging"; Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"table": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the table to ingest data into. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.UTF8LengthAtMost(1024),
							stringvalidator.RegexMatches(regexp.MustCompile(`^[\w\-\.]+$`), "must match pattern "+regexp.MustCompile(`^[\w\-\.]+$`).String()),
						},
					},
					"tenant_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Directory ID (tenant identifier) in Azure Active Directory. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"text_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "azure_data_explorer"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"azure_data_explorer",
							),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false; Requires replacement if changed.`,
					},
					"validate_database_settings": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `When you save or start the Destination, validates database name and credentials; also validates table name except when creating a new table. Disable if your Azure app does not have both the Database Viewer and the Table Viewer role. Default: true; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_azure_eventhub": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"ack": schema.Int64Attribute{
						Computed: true,
						Optional: true,
						Default:  int64default.StaticInt64(1),
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
							speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
						},
						Description: `Control the number of required acknowledgments. Default: 1; must be one of ["1", "0", "-1"]; Requires replacement if changed.`,
						Validators: []validator.Int64{
							int64validator.OneOf(1, 0, -1),
						},
					},
					"authentication_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time to wait for Kafka to respond to an authentication request. Default: 10000; Requires replacement if changed.`,
					},
					"backoff_rate": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details. Default: 2; Requires replacement if changed.`,
					},
					"brokers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of Event Hubs Kafka brokers to connect to, eg. yourdomain.servicebus.windows.net:9093. The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies. Not Null; Requires replacement if changed.`,
						Validators: []validator.List{
							speakeasy_listvalidators.NotNull(),
							listvalidator.SizeAtLeast(1),
						},
					},
					"connection_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time to wait for a connection to complete successfully. Default: 10000; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"flush_event_count": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of events in a batch before forcing a flush. Default: 1000; Requires replacement if changed.`,
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size. Default: 1; Requires replacement if changed.`,
					},
					"format": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`json`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Format to use to serialize events before writing to the Event Hubs Kafka brokers. Default: "json"; must be one of ["json", "raw"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"json",
								"raw",
							),
						},
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"initial_backoff": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes). Default: 300; Requires replacement if changed.`,
					},
					"max_back_off": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds). Default: 30000; Requires replacement if changed.`,
					},
					"max_record_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(768)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size (KB) of each record batch before compression. Setting should be < message.max.bytes settings in Event Hubs brokers. Default: 768; Requires replacement if changed.`,
					},
					"max_retries": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data. Default: 5; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"reauthentication_threshold": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backwards from the moment when credentials are set to expire. Default: 10000; Requires replacement if changed.`,
					},
					"request_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(60000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time to wait for Kafka to respond to a request. Default: 60000; Requires replacement if changed.`,
					},
					"sasl": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"disabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable authentication. Default: false; Requires replacement if changed.`,
							},
							"mechanism": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`plain`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `SASL authentication mechanism to use. Default: "plain"; must be one of ["plain", "oauthbearer"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"plain",
										"oauthbearer",
									),
								},
							},
						},
						Description: `Authentication parameters to use when connecting to brokers. Using TLS is highly recommended. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"tls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"disabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Default: false; Requires replacement if changed.`,
							},
							"reject_unauthorized": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Reject certs that are not authorized by a CA in the CA certificate path, or by another trusted CA (e.g., the system's CA). Default: true; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"topic": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The name of the Event Hub (a.k.a. Kafka Topic) to publish events. Can be overwritten using field __topicOut. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "azure_eventhub"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"azure_eventhub",
							),
						},
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_azure_logs": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"api_url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`.ods.opinsights.azure.com`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Enter the DNS name of the Log API endpoint that sends log data to a Log Analytics workspace in Azure Monitor. Defaults to .ods.opinsights.azure.com. @{product} will add a prefix and suffix around this DNS name to construct a URI in this format: <https://<Workspace_ID><your_DNS_name>/api/logs?api-version=<API version>. Default: ".ods.opinsights.azure.com"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\.[^\/]+$`), "must match pattern "+regexp.MustCompile(`^\.[^\/]+$`).String()),
						},
					},
					"auth_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`manual`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Enter workspace ID and workspace key directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"manual",
								"secret",
							),
						},
					},
					"compress": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"keypair_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored secret that references your access key and secret key. Requires replacement if changed.`,
					},
					"log_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`Cribl`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The Log Type of events sent to this LogAnalytics workspace. Defaults to ` + "`" + `Cribl` + "`" + `. Use only letters, numbers, and ` + "`" + `_` + "`" + ` characters, and can't exceed 100 characters. Can be overwritten by event field __logType. Default: "Cribl"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.UTF8LengthAtMost(100),
						},
					},
					"max_payload_events": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1024)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size, in KB, of the request body. Default: 1024; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"resource_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optional Resource ID of the Azure resource to associate the data with. Can be overridden by the __resourceId event field. This ID populates the _ResourceId property, allowing the data to be included in resource-centric queries. If the ID is neither specified nor overridden, resource-centric queries will omit the data. Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "azure_logs"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf(
								"azure_logs",
							),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false; Requires replacement if changed.`,
					},
					"workspace_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Azure Log Analytics Workspace ID. See Azure Dashboard Workspace > Advanced settings. Requires replacement if changed.`,
					},
					"workspace_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Azure Log Analytics Workspace Primary or Secondary Shared Key. See Azure Dashboard Workspace > Advanced settings. Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_click_house": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"async_inserts": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Collect data into batches for later processing. Disable to write to a ClickHouse table immediately. Default: false; Requires replacement if changed.`,
					},
					"auth_header_expr": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`` + "`" + `Bearer ${token}` + "`" + ``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to compute the Authorization header value to pass in requests. The value ` + "`" + `${token}` + "`" + ` is used to reference the token obtained from authentication, e.g.: ` + "`" + `Bearer ${token}` + "`" + `. Default: "` + "`" + `Bearer ${token}` + "`" + `"; Requires replacement if changed.`,
					},
					"auth_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default: "none"; must be one of ["none", "basic", "credentialsSecret", "sslUserCertificate", "token", "textSecret", "oauth"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"basic",
								"credentialsSecret",
								"sslUserCertificate",
								"token",
								"textSecret",
								"oauth",
							),
						},
					},
					"column_mappings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"column_name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Name of the column in ClickHouse that will store field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
								"column_type": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Type of the column in the ClickHouse database. Requires replacement if changed.`,
								},
								"column_value_expression": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `JavaScript expression to compute value to be inserted into ClickHouse table. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"compress": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Compress the payload body before sending. Default: true; Requires replacement if changed.`,
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"credentials_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a secret that references your credentials. Requires replacement if changed.`,
					},
					"database": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"describe_table": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Retrieves the table schema from ClickHouse and populates the Column Mapping table. Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"dump_format_errors_to_disk": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Log the most recent event that fails to match the table schema. Default: false; Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"exclude_mapping_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to exclude from sending to ClickHouse. Requires replacement if changed.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"format": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`json-compact-each-row-with-names`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data format to use when sending data to ClickHouse. Defaults to JSON Compact. Default: "json-compact-each-row-with-names"; must be one of ["json-compact-each-row-with-names", "json-each-row"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"json-compact-each-row-with-names",
								"json-each-row",
							),
						},
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"login_url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `URL for OAuth. Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
						},
					},
					"mapping_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`automatic`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `How event fields are mapped to ClickHouse columns. Default: "automatic"; must be one of ["automatic", "custom"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"automatic",
								"custom",
							),
						},
					},
					"max_payload_events": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(4096)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size, in KB, of the request body. Default: 4096; Requires replacement if changed.`,
					},
					"oauth_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `OAuth header name. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `OAuth header value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request. Requires replacement if changed.`,
					},
					"oauth_params": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `OAuth parameter name. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `OAuth parameter value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request. Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"password": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Password for Basic authentication. Requires replacement if changed.`,
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Secret parameter value to pass in request body. Requires replacement if changed.`,
					},
					"secret_param_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Secret parameter name to pass in request body. Requires replacement if changed.`,
					},
					"sql_username": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Username for certificate authentication. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"table_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the ClickHouse table where data will be inserted. Name can contain letters (A-Z, a-z), numbers (0-9), and the character "_", and must start with either a letter or the character "_". Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.RegexMatches(regexp.MustCompile(`^[a-zA-Z_][0-9a-zA-Z_]*$`), "must match pattern "+regexp.MustCompile(`^[a-zA-Z_][0-9a-zA-Z_]*$`).String()),
						},
					},
					"text_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"tls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"cert_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"certificate_name": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The name of the predefined certificate. Requires replacement if changed.`,
							},
							"disabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Default: true; Requires replacement if changed.`,
							},
							"max_version": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Minimum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Passphrase to use to decrypt private key. Requires replacement if changed.`,
							},
							"priv_key_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"servername": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address. Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"token": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Bearer token to include in the authorization header. Requires replacement if changed.`,
					},
					"token_attribute_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token'). Requires replacement if changed.`,
					},
					"token_timeout_secs": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(3600)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How often the OAuth token should be refreshed. Default: 3600; Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "click_house"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"click_house",
							),
						},
					},
					"url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `URL of the ClickHouse instance. Example: http://localhost:8123/. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false; Requires replacement if changed.`,
					},
					"username": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Username for Basic authentication. Requires replacement if changed.`,
					},
					"wait_for_async_inserts": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Cribl will wait for confirmation that data has been fully inserted into the ClickHouse database before proceeding. Disabling this option can increase throughput, but Cribl won’t be able to verify data has been completely inserted. Default: true; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_cloudwatch": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"assume_role_arn": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Amazon Resource Name (ARN) of the role to assume. Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.UTF8LengthAtLeast(20),
							stringvalidator.RegexMatches(regexp.MustCompile(`^arn:`), "must match pattern "+regexp.MustCompile(`^arn:`).String()),
						},
					},
					"assume_role_external_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `External ID to use when assuming role. Requires replacement if changed.`,
					},
					"aws_api_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Access key. Requires replacement if changed.`,
					},
					"aws_authentication_method": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`auto`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"auto",
								"manual",
								"secret",
							),
						},
					},
					"aws_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored secret that references your access key and secret key. Requires replacement if changed.`,
					},
					"aws_secret_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Secret key. Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"duration_seconds": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(3600)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600; Requires replacement if changed.`,
					},
					"enable_assume_role": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Use Assume Role credentials to access CloudWatchLogs. Default: false; Requires replacement if changed.`,
					},
					"endpoint": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `CloudWatchLogs service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to CloudWatchLogs-compatible endpoint. Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size. Default: 1; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"log_group_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `CloudWatch log group to associate events with. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"log_stream_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Prefix for CloudWatch log stream name. This prefix will be used to generate a unique log stream name per cribl instance, for example: myStream_myHost_myOutputId. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"max_queue_size": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of queued batches before blocking. Default: 5; Requires replacement if changed.`,
					},
					"max_record_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1024)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size (KB) of each individual record before compression. For non compressible data 1MB is the max recommended size. Default: 1024; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"region": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Region where the CloudWatchLogs is located. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true; Requires replacement if changed.`,
					},
					"reuse_connections": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Reuse connections between requests, which can improve performance. Default: true; Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "cloudwatch"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"cloudwatch",
							),
						},
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_confluent_cloud": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"ack": schema.Int64Attribute{
						Computed: true,
						Optional: true,
						Default:  int64default.StaticInt64(1),
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
							speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
						},
						Description: `Control the number of required acknowledgments. Default: 1; must be one of ["1", "0", "-1"]; Requires replacement if changed.`,
						Validators: []validator.Int64{
							int64validator.OneOf(1, 0, -1),
						},
					},
					"authentication_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time to wait for Kafka to respond to an authentication request. Default: 10000; Requires replacement if changed.`,
					},
					"backoff_rate": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details. Default: 2; Requires replacement if changed.`,
					},
					"brokers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of Confluent Cloud bootstrap servers to use, such as yourAccount.confluent.cloud:9092. Not Null; Requires replacement if changed.`,
						Validators: []validator.List{
							speakeasy_listvalidators.NotNull(),
							listvalidator.SizeAtLeast(1),
						},
					},
					"compression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`gzip`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the data before sending to Kafka. Default: "gzip"; must be one of ["none", "gzip", "snappy", "lz4"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
								"snappy",
								"lz4",
							),
						},
					},
					"connection_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time to wait for a connection to complete successfully. Default: 10000; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"flush_event_count": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum number of events you want the Destination to allow in a batch before forcing a flush. Default: 1000; Requires replacement if changed.`,
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum amount of time you want the Destination to wait before forcing a flush. Shorter intervals tend to result in smaller batches being sent. Default: 1; Requires replacement if changed.`,
					},
					"format": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`json`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Format to use to serialize events before writing to Kafka. Default: "json"; must be one of ["json", "raw", "protobuf"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"json",
								"raw",
								"protobuf",
							),
						},
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"initial_backoff": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes). Default: 300; Requires replacement if changed.`,
					},
					"kafka_schema_registry": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"auth": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									objectplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"credentials_secret": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Select or create a secret that references your credentials. Requires replacement if changed.`,
									},
									"disabled": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											boolplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Enable authentication. Default: true; Requires replacement if changed.`,
									},
								},
								Description: `Credentials to use when authenticating with the schema registry using basic HTTP authentication. Requires replacement if changed.`,
							},
							"connection_timeout": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(30000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum time to wait for a Schema Registry connection to complete successfully. Default: 30000; Requires replacement if changed.`,
							},
							"default_key_schema_id": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Used when __keySchemaIdOut is not present, to transform key values, leave blank if key transformation is not required by default. Requires replacement if changed.`,
							},
							"default_value_schema_id": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Used when __valueSchemaIdOut is not present, to transform _raw, leave blank if value transformation is not required by default. Requires replacement if changed.`,
							},
							"disabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable Schema Registry. Default: true; Requires replacement if changed.`,
							},
							"max_retries": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum number of times to try fetching schemas from the Schema Registry. Default: 1; Requires replacement if changed.`,
							},
							"request_timeout": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(30000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum time to wait for the Schema Registry to respond to a request. Default: 30000; Requires replacement if changed.`,
							},
							"schema_registry_url": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`http://localhost:8081`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http. Default: "http://localhost:8081"; Requires replacement if changed.`,
							},
							"tls": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									objectplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"ca_path": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
									},
									"cert_path": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
									},
									"certificate_name": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `The name of the predefined certificate. Requires replacement if changed.`,
									},
									"disabled": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											boolplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Default: true; Requires replacement if changed.`,
									},
									"max_version": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Maximum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"TLSv1",
												"TLSv1.1",
												"TLSv1.2",
												"TLSv1.3",
											),
										},
									},
									"min_version": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Minimum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"TLSv1",
												"TLSv1.1",
												"TLSv1.2",
												"TLSv1.3",
											),
										},
									},
									"passphrase": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Passphrase to use to decrypt private key. Requires replacement if changed.`,
									},
									"priv_key_path": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
									},
									"reject_unauthorized": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											boolplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										MarkdownDescription: `Reject certs that are not authorized by a CA in the CA certificate path, or by another ` + "\n" +
											`                    trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.` + "\n" +
											`Default: true; Requires replacement if changed.`,
									},
									"servername": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address. Requires replacement if changed.`,
									},
								},
								Description: `Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"max_back_off": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds). Default: 30000; Requires replacement if changed.`,
					},
					"max_record_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(768)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size of each record batch before compression. The value must not exceed the Kafka brokers' message.max.bytes setting. Default: 768; Requires replacement if changed.`,
					},
					"max_retries": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data. Default: 5; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"protobuf_library_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select a set of Protobuf definitions for the events you want to send. Requires replacement if changed.`,
					},
					"reauthentication_threshold": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backwards from the moment when credentials are set to expire. Default: 10000; Requires replacement if changed.`,
					},
					"request_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(60000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time to wait for Kafka to respond to a request. Default: 60000; Requires replacement if changed.`,
					},
					"sasl": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"disabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable Authentication. Default: true; Requires replacement if changed.`,
							},
							"mechanism": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`plain`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `SASL authentication mechanism to use. Default: "plain"; must be one of ["plain", "scram-sha-256", "scram-sha-512", "kerberos"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"plain",
										"scram-sha-256",
										"scram-sha-512",
										"kerberos",
									),
								},
							},
						},
						Description: `Authentication parameters to use when connecting to brokers. Using TLS is highly recommended. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"tls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"cert_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"certificate_name": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The name of the predefined certificate. Requires replacement if changed.`,
							},
							"disabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Default: false; Requires replacement if changed.`,
							},
							"max_version": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Minimum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Passphrase to use to decrypt private key. Requires replacement if changed.`,
							},
							"priv_key_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"reject_unauthorized": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								MarkdownDescription: `Reject certs that are not authorized by a CA in the CA certificate path, or by another ` + "\n" +
									`                    trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.` + "\n" +
									`Default: true; Requires replacement if changed.`,
							},
							"servername": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address. Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"topic": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The topic to publish events to. Can be overridden using the __topicOut field. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "confluent_cloud"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"confluent_cloud",
							),
						},
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_cribl_http": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"compression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`gzip`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the data before sending. Default: "gzip"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"dns_resolve_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(600)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Re-resolve any hostnames every this many seconds and pick up destinations from A records. Default: 600; Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"exclude_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to exclude from the event. By default, all internal fields except ` + "`" + `__output` + "`" + ` are sent. E.g.: ` + "`" + `cribl_pipe` + "`" + `, ` + "`" + `c*` + "`" + `. Wildcards supported. Requires replacement if changed.`,
					},
					"exclude_self": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Exclude all IPs of the current host from the list of any resolved hostnames. Default: false; Requires replacement if changed.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"load_balance_stats_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How far back in time to keep traffic stats for load balancing purposes. Default: 300; Requires replacement if changed.`,
					},
					"load_balanced": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `For optimal performance, enable load balancing even if you have one hostname, as it can expand to multiple IPs. If this setting is disabled, consider enabling round-robin DNS. Default: true; Requires replacement if changed.`,
					},
					"max_payload_events": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(4096)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size, in KB, of the request body. Default: 4096; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"tls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"cert_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"certificate_name": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The name of the predefined certificate. Requires replacement if changed.`,
							},
							"disabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Default: true; Requires replacement if changed.`,
							},
							"max_version": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Minimum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Passphrase to use to decrypt private key. Requires replacement if changed.`,
							},
							"priv_key_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"reject_unauthorized": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								MarkdownDescription: `Reject certs that are not authorized by a CA in the CA certificate path, or by another ` + "\n" +
									`                    trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.` + "\n" +
									`Default: true; Requires replacement if changed.`,
							},
							"servername": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address. Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"token_ttl_minutes": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(60)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The number of minutes before the internally generated authentication token expires, valid values between 1 and 60. Default: 60; Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "cribl_http"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf(
								"cribl_http",
							),
						},
					},
					"url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `URL of a Cribl Worker to send events to, e.g., http://localhost:10200. Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
						},
					},
					"urls": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"url": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `URL of a Cribl Worker to send events to, e.g., http://localhost:10200. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
										stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
									},
								},
								"weight": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Assign a weight (>0) to each endpoint to indicate its traffic-handling capability. Default: 1; Requires replacement if changed.`,
								},
							},
						},
						Description: `Requires replacement if changed.`,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_cribl_lake": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"add_id_to_stage_path": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Append output's ID to staging location. Default: true; Requires replacement if changed.`,
					},
					"assume_role_arn": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Amazon Resource Name (ARN) of the role to assume. Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.UTF8LengthAtLeast(20),
							stringvalidator.RegexMatches(regexp.MustCompile(`^arn:`), "must match pattern "+regexp.MustCompile(`^arn:`).String()),
						},
					},
					"assume_role_external_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `External ID to use when assuming role. Requires replacement if changed.`,
					},
					"aws_authentication_method": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`auto`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default: "auto"; must be one of ["auto", "auto_rpc", "manual"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"auto",
								"auto_rpc",
								"manual",
							),
						},
					},
					"aws_secret_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Secret key. This value can be a constant or a JavaScript expression(e.g., ` + "`" + `${C.env.SOME_SECRET}` + "`" + `). Requires replacement if changed.`,
					},
					"base_file_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`` + "`" + `CriblOut` + "`" + ``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to define the output filename prefix (can be constant). Default: "` + "`" + `CriblOut` + "`" + `"; Requires replacement if changed.`,
					},
					"bucket": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the destination S3 bucket. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: ` + "`" + `myBucket-${C.vars.myVar}` + "`" + `. Requires replacement if changed.`,
					},
					"deadletter_enabled": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors. Default: false; Requires replacement if changed.`,
					},
					"deadletter_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/outputs/dead-letter`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Storage location for files that fail to reach their final destination after maximum retries are exceeded. Default: "$CRIBL_HOME/state/outputs/dead-letter"; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"dest_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Lake dataset to send the data to. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"duration_seconds": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(3600)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600; Requires replacement if changed.`,
					},
					"empty_dir_cleanup_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How frequently, in seconds, to clean up empty directories when 'Remove empty staging dirs' is enabled. Default: 300; Requires replacement if changed.`,
					},
					"enable_assume_role": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Use Assume Role credentials to access S3. Default: false; Requires replacement if changed.`,
					},
					"endpoint": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `S3 service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint. Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"file_name_suffix": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`` + "`" + `.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}` + "`" + ``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to define the output filename suffix (can be constant).  The ` + "`" + `__format` + "`" + ` variable refers to the value of the ` + "`" + `Data format` + "`" + ` field (` + "`" + `json` + "`" + ` or ` + "`" + `raw` + "`" + `).  The ` + "`" + `__compression` + "`" + ` field refers to the kind of compression being used (` + "`" + `none` + "`" + ` or ` + "`" + `gzip` + "`" + `). Default: "` + "`" + `.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}` + "`" + `"; Requires replacement if changed.`,
					},
					"format": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be one of ["json", "parquet", "ddss"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"json",
								"parquet",
								"ddss",
							),
						},
					},
					"header_line": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `If set, this line will be written to the beginning of each output file. Default: ""; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"kms_key_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `ID or ARN of the KMS customer-managed key to use for encryption. Requires replacement if changed.`,
					},
					"max_closing_files_to_backpressure": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(100)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of files that can be waiting for upload before backpressure is applied. Default: 100; Requires replacement if changed.`,
					},
					"max_concurrent_file_parts": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(4)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of parts to upload in parallel per file. Minimum part size is 5MB. Default: 4; Requires replacement if changed.`,
					},
					"max_file_idle_time_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30; Requires replacement if changed.`,
					},
					"max_file_open_time_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300; Requires replacement if changed.`,
					},
					"max_file_size_mb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(32)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 32; Requires replacement if changed.`,
					},
					"max_open_files": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(100)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100; Requires replacement if changed.`,
					},
					"max_retry_num": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(20)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum number of times a file will attempt to move to its final destination before being dead-lettered. Default: 20; Requires replacement if changed.`,
					},
					"object_acl": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`private`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Object ACL to assign to uploaded objects. Default: "private"; must be one of ["private", "public-read", "public-read-write", "authenticated-read", "aws-exec-read", "bucket-owner-read", "bucket-owner-full-control"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"private",
								"public-read",
								"public-read-write",
								"authenticated-read",
								"aws-exec-read",
								"bucket-owner-read",
								"bucket-owner-full-control",
							),
						},
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"on_disk_full_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"region": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Region where the S3 bucket is located. Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true; Requires replacement if changed.`,
					},
					"remove_empty_dirs": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Remove empty staging directories after moving files. Default: true; Requires replacement if changed.`,
					},
					"reuse_connections": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Reuse connections between requests, which can improve performance. Default: true; Requires replacement if changed.`,
					},
					"server_side_encryption": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Server-side encryption for uploaded objects. must be one of ["AES256", "aws:kms"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"AES256",
								"aws:kms",
							),
						},
					},
					"signature_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`v4`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Signature version to use for signing S3 requests. Default: "v4"; must be one of ["v2", "v4"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("v2", "v4"),
						},
					},
					"stage_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/outputs/staging`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage. Default: "$CRIBL_HOME/state/outputs/staging"; Requires replacement if changed.`,
					},
					"storage_class": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Storage class to select for uploaded objects. must be one of ["STANDARD", "REDUCED_REDUNDANCY", "STANDARD_IA", "ONEZONE_IA", "INTELLIGENT_TIERING", "GLACIER", "GLACIER_IR", "DEEP_ARCHIVE"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"STANDARD",
								"REDUCED_REDUNDANCY",
								"STANDARD_IA",
								"ONEZONE_IA",
								"INTELLIGENT_TIERING",
								"GLACIER",
								"GLACIER_IR",
								"DEEP_ARCHIVE",
							),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "cribl_lake"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf(
								"cribl_lake",
							),
						},
					},
					"verify_permissions": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Disable if you can access files within the bucket but not the bucket itself. Default: true; Requires replacement if changed.`,
					},
					"write_high_water_mark": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(64)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Buffer size used to write to a file. Default: 64; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_cribl_tcp": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"compression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`gzip`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the data before sending. Default: "gzip"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"connection_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"dns_resolve_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(600)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Re-resolve any hostnames every this many seconds and pick up destinations from A records. Default: 600; Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"exclude_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to exclude from the event. By default, all internal fields except ` + "`" + `__output` + "`" + ` are sent. E.g.: ` + "`" + `cribl_pipe` + "`" + `, ` + "`" + `c*` + "`" + `. Wildcards supported. Requires replacement if changed.`,
					},
					"exclude_self": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Exclude all IPs of the current host from the list of any resolved hostnames. Default: false; Requires replacement if changed.`,
					},
					"host": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The hostname of the receiver. Requires replacement if changed.`,
					},
					"hosts": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"host": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `The hostname of the receiver. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
								"port": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10300)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The port to connect to on the provided host. Default: 10300; Requires replacement if changed.`,
								},
								"servername": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Servername to use if establishing a TLS connection. If not specified, defaults to connection host (iff not an IP); otherwise, to the global TLS settings. Requires replacement if changed.`,
								},
								"tls": schema.StringAttribute{
									Computed: true,
									Optional: true,
									Default:  stringdefault.StaticString(`inherit`),
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Whether to inherit TLS configs from group setting or disable TLS. Default: "inherit"; must be one of ["inherit", "off"]; Requires replacement if changed.`,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"inherit",
											"off",
										),
									},
								},
								"weight": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Assign a weight (>0) to each endpoint to indicate its traffic-handling capability. Default: 1; Requires replacement if changed.`,
								},
							},
						},
						Description: `Set of hosts to load-balance data to. Requires replacement if changed.`,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"load_balance_stats_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How far back in time to keep traffic stats for load balancing purposes. Default: 300; Requires replacement if changed.`,
					},
					"load_balanced": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Use load-balanced destinations. Default: true; Requires replacement if changed.`,
					},
					"log_failed_requests": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Use to troubleshoot issues with sending data. Default: false; Requires replacement if changed.`,
					},
					"max_concurrent_senders": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of concurrent connections (per worker process). A random set of IPs will be picked on every DNS resolution period. Use 0 for unlimited. Default: 0; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"port": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The port to connect to on the provided host. Default: 10300; Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"throttle_rate_per_sec": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`0`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`), "must match pattern "+regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`).String()),
						},
					},
					"tls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"cert_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"certificate_name": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The name of the predefined certificate. Requires replacement if changed.`,
							},
							"disabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Default: true; Requires replacement if changed.`,
							},
							"max_version": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Minimum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Passphrase to use to decrypt private key. Requires replacement if changed.`,
							},
							"priv_key_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"reject_unauthorized": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								MarkdownDescription: `Reject certs that are not authorized by a CA in the CA certificate path, or by another ` + "\n" +
									`                    trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.` + "\n" +
									`Default: true; Requires replacement if changed.`,
							},
							"servername": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address. Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"token_ttl_minutes": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(60)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The number of minutes before the internally generated authentication token expires, valid values between 1 and 60. Default: 60; Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "cribl_tcp"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf(
								"cribl_tcp",
							),
						},
					},
					"write_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(60000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead. Default: 60000; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_crowdstrike_next_gen_siem": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"auth_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`manual`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"manual",
								"secret",
							),
						},
					},
					"compress": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Compress the payload body before sending. Default: true; Requires replacement if changed.`,
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"format": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`raw`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `When set to JSON, the event is automatically formatted with required fields before sending. When set to Raw, only the event's ` + "`" + `_raw` + "`" + ` value is sent. Default: "raw"; must be one of ["JSON", "raw"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"JSON",
								"raw",
							),
						},
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"max_payload_events": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(4096)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size, in KB, of the request body. Default: 4096; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"text_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"token": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `CrowdStrike Next-Gen SIEM authentication token. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "crowdstrike_next_gen_siem"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"crowdstrike_next_gen_siem",
							),
						},
					},
					"url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `URL provided from a CrowdStrike data connector, e.g. https://<your-api-key>.ingest.<your-region>.crowdstrike.com/services/collector. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: true; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_datadog": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"allow_api_key_from_events": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `If enabled, the API key can be set from the event's '__agent_api_key' field. Default: false; Requires replacement if changed.`,
					},
					"api_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Organization's API key in Datadog. Requires replacement if changed.`,
					},
					"auth_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`manual`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Enter API key directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"manual",
								"secret",
							),
						},
					},
					"batch_by_tags": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `When enabled, batches events by API key and the ddtags field on the event. When disabled, batches events only by API key. If incoming events have high cardinality in the ddtags field, disabling this setting may improve Destination performance. Default: true; Requires replacement if changed.`,
					},
					"compress": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Compress the payload body before sending. Default: true; Requires replacement if changed.`,
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"content_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`json`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The content type to use when sending logs. Default: "json"; must be one of ["text", "json"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"text",
								"json",
							),
						},
					},
					"custom_url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"host": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the host to send with logs. When you send logs as JSON objects, the event's 'host' field (if set) will override this value. Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"max_payload_events": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(4096)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size, in KB, of the request body. Default: 4096; Requires replacement if changed.`,
					},
					"message": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the event field that contains the message to send. If not specified, Stream sends a JSON representation of the whole event. Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"send_counters_as_count": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `If not enabled, Datadog will transform 'counter' metrics to 'gauge'. [Learn more about Datadog metrics types.](https://docs.datadoghq.com/metrics/types/?tab=count). Default: false; Requires replacement if changed.`,
					},
					"service": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the service to send with logs. When you send logs as JSON objects, the event's '__service' field (if set) will override this value. Requires replacement if changed.`,
					},
					"severity": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default value for message severity. When you send logs as JSON objects, the event's '__severity' field (if set) will override this value. must be one of ["emergency", "alert", "critical", "error", "warning", "notice", "info", "debug"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"emergency",
								"alert",
								"critical",
								"error",
								"warning",
								"notice",
								"info",
								"debug",
							),
						},
					},
					"site": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`us`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Datadog site to which events should be sent. Default: "us"; must be one of ["us", "us3", "us5", "eu", "fed1", "ap1", "custom"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"us",
								"us3",
								"us5",
								"eu",
								"fed1",
								"ap1",
								"custom",
							),
						},
					},
					"source": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the source to send with logs. When you send logs as JSON objects, the event's 'source' field (if set) will override this value. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"tags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of tags to send with logs (e.g., 'env:prod', 'env_staging:east'). Requires replacement if changed.`,
					},
					"text_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"total_memory_limit_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "datadog"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf("datadog"),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_dataset": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"api_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A 'Log Write Access' API key for the DataSet account. Requires replacement if changed.`,
					},
					"auth_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`manual`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Enter API key directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"manual",
								"secret",
							),
						},
					},
					"compress": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Compress the payload body before sending. Default: true; Requires replacement if changed.`,
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"custom_url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
						},
					},
					"default_severity": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`info`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default value for event severity. If the ` + "`" + `sev` + "`" + ` or ` + "`" + `__severity` + "`" + ` fields are set on an event, the first one matching will override this value. Default: "info"; must be one of ["finest", "finer", "fine", "info", "warning", "error", "fatal"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"finest",
								"finer",
								"fine",
								"info",
								"warning",
								"error",
								"fatal",
							),
						},
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"exclude_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to exclude from the event if the Message field is either unspecified or refers to an object. Ignored if the Message field is a string. If empty, we send all non-internal fields. Requires replacement if changed.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"max_payload_events": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(4096)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size, in KB, of the request body. Default: 4096; Requires replacement if changed.`,
					},
					"message_field": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the event field that contains the message or attributes to send. If not specified, all of the event's non-internal fields will be sent as attributes. Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"server_host_field": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the event field that contains the ` + "`" + `serverHost` + "`" + ` identifier. If not specified, defaults to ` + "`" + `cribl_<outputId>` + "`" + `. Requires replacement if changed.`,
					},
					"site": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`us`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `DataSet site to which events should be sent. Default: "us"; must be one of ["us", "eu", "custom"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"us",
								"eu",
								"custom",
							),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"text_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"timestamp_field": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the event field that contains the timestamp. If not specified, defaults to ` + "`" + `ts` + "`" + `, ` + "`" + `_time` + "`" + `, or ` + "`" + `Date.now()` + "`" + `, in that order. Requires replacement if changed.`,
					},
					"total_memory_limit_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "dataset"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf("dataset"),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_default": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"default_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `ID of the default output. This will be used whenever a nonexistent/deleted output is referenced. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "default"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf("default"),
						},
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_devnull": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "devnull"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf("devnull"),
						},
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_disk_spool": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`gzip`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data compression format. Default is gzip. Default: "gzip"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"max_data_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum disk space that can be consumed before older buckets are deleted. Examples: 420MB, 4GB. Default is 1GB. Default: "1GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+(\.\d+)?\s*(?:[kmgKMG](b|B))?$`), "must match pattern "+regexp.MustCompile(`^\d+(\.\d+)?\s*(?:[kmgKMG](b|B))?$`).String()),
						},
					},
					"max_data_time": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`24h`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum amount of time to retain data before older buckets are deleted. Examples: 2h, 4d. Default is 24h. Default: "24h"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`\d+[smhd]$`), "must match pattern "+regexp.MustCompile(`\d+[smhd]$`).String()),
						},
					},
					"partition_expr": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression defining how files are partitioned and organized within the time-buckets. If blank, the event's __partition property is used and otherwise, events go directly into the time-bucket directory. Requires replacement if changed.`,
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"time_window": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`10m`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Time period for grouping spooled events. Default is 10m. Default: "10m"; Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "disk_spool"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf(
								"disk_spool",
							),
						},
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_dl_s3": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"add_id_to_stage_path": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Append output's ID to staging location. Default: true; Requires replacement if changed.`,
					},
					"assume_role_arn": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Amazon Resource Name (ARN) of the role to assume. Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.UTF8LengthAtLeast(20),
							stringvalidator.RegexMatches(regexp.MustCompile(`^arn:`), "must match pattern "+regexp.MustCompile(`^arn:`).String()),
						},
					},
					"assume_role_external_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `External ID to use when assuming role. Requires replacement if changed.`,
					},
					"automatic_schema": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Automatically calculate the schema based on the events of each Parquet file generated. Default: false; Requires replacement if changed.`,
					},
					"aws_api_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Access key. This value can be a constant or a JavaScript expression(e.g., ` + "`" + `${C.env.SOME_ACCESS_KEY}` + "`" + `). Requires replacement if changed.`,
					},
					"aws_authentication_method": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`auto`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"auto",
								"manual",
								"secret",
							),
						},
					},
					"aws_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored secret that references your access key and secret key. Requires replacement if changed.`,
					},
					"aws_secret_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Secret key. This value can be a constant or a JavaScript expression(e.g., ` + "`" + `${C.env.SOME_SECRET}` + "`" + `). Requires replacement if changed.`,
					},
					"base_file_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`` + "`" + `CriblOut` + "`" + ``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to define the output filename prefix (can be constant). Default: "` + "`" + `CriblOut` + "`" + `"; Requires replacement if changed.`,
					},
					"bucket": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the destination S3 bucket. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: ` + "`" + `myBucket-${C.vars.myVar}` + "`" + `. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`gzip`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Choose data compression format to apply before moving files to final destination. Default: "gzip"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"compression_level": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`best_speed`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Compression level to apply before moving files to final destination. Default: "best_speed"; must be one of ["best_speed", "normal", "best_compression"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"best_speed",
								"normal",
								"best_compression",
							),
						},
					},
					"deadletter_enabled": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors. Default: false; Requires replacement if changed.`,
					},
					"deadletter_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/outputs/dead-letter`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Storage location for files that fail to reach their final destination after maximum retries are exceeded. Default: "$CRIBL_HOME/state/outputs/dead-letter"; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"dest_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Prefix to append to files before uploading. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: ` + "`" + `myKeyPrefix-${C.vars.myVar}` + "`" + `. Default: ""; Requires replacement if changed.`,
					},
					"duration_seconds": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(3600)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600; Requires replacement if changed.`,
					},
					"empty_dir_cleanup_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How frequently, in seconds, to clean up empty directories when 'Remove empty staging dirs' is enabled. Default: 300; Requires replacement if changed.`,
					},
					"enable_assume_role": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Use Assume Role credentials to access S3. Default: false; Requires replacement if changed.`,
					},
					"enable_page_checksum": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Parquet tools can use the checksum of a Parquet page to verify data integrity. Default: false; Requires replacement if changed.`,
					},
					"enable_statistics": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics. Default: true; Requires replacement if changed.`,
					},
					"enable_write_page_index": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping. Default: true; Requires replacement if changed.`,
					},
					"endpoint": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `S3 service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint. Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"file_name_suffix": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`` + "`" + `.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}` + "`" + ``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to define the output filename suffix (can be constant).  The ` + "`" + `__format` + "`" + ` variable refers to the value of the ` + "`" + `Data format` + "`" + ` field (` + "`" + `json` + "`" + ` or ` + "`" + `raw` + "`" + `).  The ` + "`" + `__compression` + "`" + ` field refers to the kind of compression being used (` + "`" + `none` + "`" + ` or ` + "`" + `gzip` + "`" + `). Default: "` + "`" + `.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}` + "`" + `"; Requires replacement if changed.`,
					},
					"format": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`json`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Format of the output data. Default: "json"; must be one of ["json", "raw", "parquet"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"json",
								"raw",
								"parquet",
							),
						},
					},
					"header_line": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `If set, this line will be written to the beginning of each output file. Default: ""; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"key_value_metadata": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed: true,
									Optional: true,
									Default:  stringdefault.StaticString(``),
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Default: ""; Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging, e.g., "key":"OCSF Event Class", "value":"9001". Requires replacement if changed.`,
					},
					"kms_key_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `ID or ARN of the KMS customer-managed key to use for encryption. Requires replacement if changed.`,
					},
					"max_closing_files_to_backpressure": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(100)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of files that can be waiting for upload before backpressure is applied. Default: 100; Requires replacement if changed.`,
					},
					"max_concurrent_file_parts": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(4)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of parts to upload in parallel per file. Minimum part size is 5MB. Default: 4; Requires replacement if changed.`,
					},
					"max_file_idle_time_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30; Requires replacement if changed.`,
					},
					"max_file_open_time_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300; Requires replacement if changed.`,
					},
					"max_file_size_mb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(32)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 32; Requires replacement if changed.`,
					},
					"max_open_files": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(100)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100; Requires replacement if changed.`,
					},
					"max_retry_num": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(20)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum number of times a file will attempt to move to its final destination before being dead-lettered. Default: 20; Requires replacement if changed.`,
					},
					"object_acl": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`private`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Object ACL to assign to uploaded objects. Default: "private"; must be one of ["private", "public-read", "public-read-write", "authenticated-read", "aws-exec-read", "bucket-owner-read", "bucket-owner-full-control"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"private",
								"public-read",
								"public-read-write",
								"authenticated-read",
								"aws-exec-read",
								"bucket-owner-read",
								"bucket-owner-full-control",
							),
						},
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"on_disk_full_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"parquet_data_page_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`DATA_PAGE_V2`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it. Default: "DATA_PAGE_V2"; must be one of ["DATA_PAGE_V1", "DATA_PAGE_V2"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"DATA_PAGE_V1",
								"DATA_PAGE_V2",
							),
						},
					},
					"parquet_page_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression. Default: "1MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:[kK][bB]|[mM][bB]|[gG][bB]|[tT][bB])?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:[kK][bB]|[mM][bB]|[gG][bB]|[tT][bB])?$`).String()),
						},
					},
					"parquet_row_group_length": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The number of rows that every group will contain. The final group can contain a smaller number of rows. Default: 10000; Requires replacement if changed.`,
					},
					"parquet_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`PARQUET_2_6`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Determines which data types are supported and how they are represented. Default: "PARQUET_2_6"; must be one of ["PARQUET_1_0", "PARQUET_2_4", "PARQUET_2_6"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"PARQUET_1_0",
								"PARQUET_2_4",
								"PARQUET_2_6",
							),
						},
					},
					"partitioning_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of fields to partition the path by, in addition to time, which is included automatically. The effective partition will be YYYY/MM/DD/HH/<list/of/fields>. Requires replacement if changed.`,
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"region": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Region where the S3 bucket is located. Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true; Requires replacement if changed.`,
					},
					"remove_empty_dirs": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Remove empty staging directories after moving files. Default: true; Requires replacement if changed.`,
					},
					"reuse_connections": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Reuse connections between requests, which can improve performance. Default: true; Requires replacement if changed.`,
					},
					"server_side_encryption": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Server-side encryption for uploaded objects. must be one of ["AES256", "aws:kms"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"AES256",
								"aws:kms",
							),
						},
					},
					"should_log_invalid_rows": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Log up to 3 rows that @{product} skips due to data mismatch. Requires replacement if changed.`,
					},
					"signature_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`v4`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Signature version to use for signing S3 requests. Default: "v4"; must be one of ["v2", "v4"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("v2", "v4"),
						},
					},
					"stage_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/outputs/staging`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage. Default: "$CRIBL_HOME/state/outputs/staging"; Requires replacement if changed.`,
					},
					"storage_class": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Storage class to select for uploaded objects. must be one of ["STANDARD", "REDUCED_REDUNDANCY", "STANDARD_IA", "ONEZONE_IA", "INTELLIGENT_TIERING", "GLACIER", "GLACIER_IR", "DEEP_ARCHIVE"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"STANDARD",
								"REDUCED_REDUNDANCY",
								"STANDARD_IA",
								"ONEZONE_IA",
								"INTELLIGENT_TIERING",
								"GLACIER",
								"GLACIER_IR",
								"DEEP_ARCHIVE",
							),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "dl_s3"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("dl_s3"),
						},
					},
					"verify_permissions": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Disable if you can access files within the bucket but not the bucket itself. Default: true; Requires replacement if changed.`,
					},
					"write_high_water_mark": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(64)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Buffer size used to write to a file. Default: 64; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_dynatrace_http": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"active_gate_domain": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `ActiveGate domain with Log analytics collector module enabled. For example https://{activeGate-domain}:9999/e/{environment-id}/api/v2/logs/ingest. Requires replacement if changed.`,
					},
					"auth_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`token`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default: "token"; must be one of ["token", "textSecret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"token",
								"textSecret",
							),
						},
					},
					"compress": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Compress the payload body before sending. Default: true; Requires replacement if changed.`,
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"endpoint": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`cloud`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default: "cloud"; must be one of ["cloud", "activeGate", "manual"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"cloud",
								"activeGate",
								"manual",
							),
						},
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"environment_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `ID of the environment to send to. Requires replacement if changed.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained [here](https://docs.cribl.io/stream/destinations-webhook/#internal-fields). Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"format": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`json_array`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `How to format events before sending. Defaults to JSON. Plaintext is not currently supported. Default: "json_array"; must be one of ["json_array", "plaintext"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"json_array",
								"plaintext",
							),
						},
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"keep_alive": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Disable to close the connection immediately after sending the outgoing request. Default: true; Requires replacement if changed.`,
					},
					"max_payload_events": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(4096)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size, in KB, of the request body. Default: 4096; Requires replacement if changed.`,
					},
					"method": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`POST`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The method to use when sending events. Defaults to POST. Default: "POST"; must be one of ["POST", "PUT", "PATCH"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"POST",
								"PUT",
								"PATCH",
							),
						},
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"telemetry_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`logs`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default: "logs"; must be one of ["logs", "metrics"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"logs",
								"metrics",
							),
						},
					},
					"text_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"token": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Bearer token to include in the authorization header. Requires replacement if changed.`,
					},
					"total_memory_limit_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be one of ["webhook", "sentinel", "dynatrace_http"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"webhook",
								"sentinel",
								"dynatrace_http",
							),
						},
					},
					"url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `URL to send events to. Can be overwritten by an event's __url field. Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_dynatrace_otlp": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"auth_token_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`Authorization`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default: "Authorization"; Requires replacement if changed.`,
					},
					"compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`gzip`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Type of compression to apply to messages sent to the OpenTelemetry endpoint. Default: "gzip"; must be one of ["none", "deflate", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"deflate",
								"gzip",
							),
						},
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"connection_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"endpoint": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`https://{your-environment-id}.live.dynatrace.com/api/v2/otlp`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The endpoint where Dynatrace events will be sent. Enter any valid URL or an IP address (IPv4 or IPv6; enclose IPv6 addresses in square brackets). Default: "https://{your-environment-id}.live.dynatrace.com/api/v2/otlp"; Requires replacement if changed.`,
					},
					"endpoint_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`saas`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select the type of Dynatrace endpoint configured. Default: "saas"; must be one of ["saas", "ag"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"saas",
								"ag",
							),
						},
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"http_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`gzip`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Type of compression to apply to messages sent to the OpenTelemetry endpoint. Default: "gzip"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"http_logs_endpoint_override": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `If you want to send logs to the default ` + "`" + `{endpoint}/v1/logs` + "`" + ` endpoint, leave this field empty; otherwise, specify the desired endpoint. Requires replacement if changed.`,
					},
					"http_metrics_endpoint_override": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `If you want to send metrics to the default ` + "`" + `{endpoint}/v1/metrics` + "`" + ` endpoint, leave this field empty; otherwise, specify the desired endpoint. Requires replacement if changed.`,
					},
					"http_traces_endpoint_override": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `If you want to send traces to the default ` + "`" + `{endpoint}/v1/traces` + "`" + ` endpoint, leave this field empty; otherwise, specify the desired endpoint. Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"keep_alive": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Disable to close the connection immediately after sending the outgoing request. Default: true; Requires replacement if changed.`,
					},
					"keep_alive_time": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How often the sender should ping the peer to keep the connection open. Default: 30; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(2048)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size (in KB) of the request body. The maximum payload size is 4 MB. If this limit is exceeded, the entire OTLP message is dropped. Default: 2048; Requires replacement if changed.`,
					},
					"metadata": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed: true,
									Optional: true,
									Default:  stringdefault.StaticString(``),
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Default: ""; Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `List of key-value pairs to send with each gRPC request. Value supports JavaScript expressions that are evaluated just once, when the destination gets started. To pass credentials as metadata, use 'C.Secret'. Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"otlp_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1.3.1`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The version of OTLP Protobuf definitions to use when structuring data to send. Default: "1.3.1"; must be "1.3.1"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("1.3.1"),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"protocol": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`http`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select a transport option for Dynatrace. Default: "http"; must be "http"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("http"),
						},
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"token_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "dynatrace_otlp"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"dynatrace_otlp",
							),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_elastic": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"auth": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"auth_type": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`manual`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Enter credentials directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret", "manualAPIKey", "textSecret"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"manual",
										"secret",
										"manualAPIKey",
										"textSecret",
									),
								},
							},
							"disabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Default: true; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"compress": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Compress the payload body before sending. Default: true; Requires replacement if changed.`,
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"dns_resolve_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(600)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Re-resolve any hostnames every this many seconds and pick up destinations from A records. Default: 600; Requires replacement if changed.`,
					},
					"doc_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Document type to use for events. Can be overwritten by an event's __type field. Requires replacement if changed.`,
					},
					"elastic_pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optional Elasticsearch destination pipeline. Requires replacement if changed.`,
					},
					"elastic_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`auto`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optional Elasticsearch version, used to format events. If not specified, will auto-discover version. Default: "auto"; must be one of ["auto", "6", "7"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"auto",
								"6",
								"7",
							),
						},
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"exclude_self": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Exclude all IPs of the current host from the list of any resolved hostnames. Default: false; Requires replacement if changed.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. Requires replacement if changed.`,
					},
					"extra_params": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Extra Parameters. Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"include_doc_id": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Toggle this off when sending events to an Elastic TSDS (time series data stream) or to allow Elastic to generate document IDs. Default: false; Requires replacement if changed.`,
					},
					"index": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Index or data stream to send events to. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be overwritten by an event's __index field. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"load_balance_stats_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How far back in time to keep traffic stats for load balancing purposes. Default: 300; Requires replacement if changed.`,
					},
					"load_balanced": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS. Default: true; Requires replacement if changed.`,
					},
					"max_payload_events": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(4096)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size, in KB, of the request body. Default: 4096; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"retry_partial_errors": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Retry failed events when a bulk request to Elastic is successful, but the response body returns an error for one or more events in the batch. Default: false; Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "elastic"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf("elastic"),
						},
					},
					"url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The Cloud ID or URL to an Elastic cluster to send events to. Example: http://elastic:9200/_bulk. Requires replacement if changed.`,
					},
					"urls": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"url": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `The URL to an Elastic node to send events to. Example: http://elastic:9200/_bulk. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
								"weight": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Assign a weight (>0) to each endpoint to indicate its traffic-handling capability. Default: 1; Requires replacement if changed.`,
								},
							},
						},
						Description: `Requires replacement if changed.`,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false; Requires replacement if changed.`,
					},
					"write_action": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`create`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Action to use when writing events. Must be set to ` + "`" + `Create` + "`" + ` when writing to a data stream. Default: "create"; must be one of ["index", "create"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"index",
								"create",
							),
						},
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_elastic_cloud": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"auth": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"auth_type": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`manual`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Enter credentials directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret", "manualAPIKey", "textSecret"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"manual",
										"secret",
										"manualAPIKey",
										"textSecret",
									),
								},
							},
							"disabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"compress": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Compress the payload body before sending. Default: true; Requires replacement if changed.`,
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"elastic_pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optional Elastic Cloud Destination pipeline. Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. Requires replacement if changed.`,
					},
					"extra_params": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Extra parameters to use in HTTP requests. Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"include_doc_id": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Toggle to No when sending events to an Elastic TSDS (time series data stream). Default: true; Requires replacement if changed.`,
					},
					"index": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data stream or index to send events to. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be overwritten by an event's __index field. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"max_payload_events": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(4096)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size, in KB, of the request body. Default: 4096; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "elastic_cloud"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"elastic_cloud",
							),
						},
					},
					"url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Enter Cloud ID of the Elastic Cloud environment to send events to. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_exabeam": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"add_id_to_stage_path": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Append output's ID to staging location. Default: true; Requires replacement if changed.`,
					},
					"aws_api_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `HMAC access key. Can be a constant or a JavaScript expression, such as ` + "`" + `${C.env.GCS_ACCESS_KEY}` + "`" + `. Requires replacement if changed.`,
					},
					"aws_secret_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `HMAC secret. Can be a constant or a JavaScript expression, such as ` + "`" + `${C.env.GCS_SECRET}` + "`" + `. Requires replacement if changed.`,
					},
					"bucket": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the destination bucket. A constant or a JavaScript expression that can only be evaluated at init time. Example of referencing a JavaScript Global Variable: ` + "`" + `myBucket-${C.vars.myVar}` + "`" + `. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"collector_instance_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `ID of the Exabeam Collector where data should be sent. Example: 11112222-3333-4444-5555-666677778888. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"deadletter_enabled": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors. Default: false; Requires replacement if changed.`,
					},
					"deadletter_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/outputs/dead-letter`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Storage location for files that fail to reach their final destination after maximum retries are exceeded. Default: "$CRIBL_HOME/state/outputs/dead-letter"; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"empty_dir_cleanup_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How frequently, in seconds, to clean up empty directories when 'Remove empty staging dirs' is enabled. Default: 300; Requires replacement if changed.`,
					},
					"encoded_configuration": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Enter an encoded string containing Exabeam configurations. Requires replacement if changed.`,
					},
					"endpoint": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`https://storage.googleapis.com`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Google Cloud Storage service endpoint. Default: "https://storage.googleapis.com"; Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"max_file_idle_time_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30; Requires replacement if changed.`,
					},
					"max_file_open_time_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300; Requires replacement if changed.`,
					},
					"max_file_size_mb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 10; Requires replacement if changed.`,
					},
					"max_open_files": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(100)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100; Requires replacement if changed.`,
					},
					"max_retry_num": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(20)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum number of times a file will attempt to move to its final destination before being dead-lettered. Default: 20; Requires replacement if changed.`,
					},
					"object_acl": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`private`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Object ACL to assign to uploaded objects. Default: "private"; must be one of ["private", "bucket-owner-read", "bucket-owner-full-control", "project-private", "authenticated-read", "public-read"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"private",
								"bucket-owner-read",
								"bucket-owner-full-control",
								"project-private",
								"authenticated-read",
								"public-read",
							),
						},
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"on_disk_full_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"region": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Region where the bucket is located. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates). Default: true; Requires replacement if changed.`,
					},
					"remove_empty_dirs": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Remove empty staging directories after moving files. Default: true; Requires replacement if changed.`,
					},
					"reuse_connections": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to reuse connections between requests, which can improve performance. Default: true; Requires replacement if changed.`,
					},
					"signature_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`v4`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Signature version to use for signing Google Cloud Storage requests. Default: "v4"; must be one of ["v2", "v4"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("v2", "v4"),
						},
					},
					"site_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Exabeam site ID. If left blank, @{product} will use the value of the Exabeam site name. Requires replacement if changed.`,
					},
					"site_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Constant or JavaScript expression to create an Exabeam site name. Values that aren't successfully evaluated will be treated as string constants. Requires replacement if changed.`,
					},
					"stage_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/outputs/staging`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage. Default: "$CRIBL_HOME/state/outputs/staging"; Requires replacement if changed.`,
					},
					"storage_class": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Storage class to select for uploaded objects. must be one of ["STANDARD", "NEARLINE", "COLDLINE", "ARCHIVE"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"STANDARD",
								"NEARLINE",
								"COLDLINE",
								"ARCHIVE",
							),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"timezone_offset": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Exabeam timezone offset. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "exabeam"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("exabeam"),
						},
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_filesystem": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"add_id_to_stage_path": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Append output's ID to staging location. Default: true; Requires replacement if changed.`,
					},
					"automatic_schema": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Automatically calculate the schema based on the events of each Parquet file generated. Default: false; Requires replacement if changed.`,
					},
					"base_file_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`` + "`" + `CriblOut` + "`" + ``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to define the output filename prefix (can be constant). Default: "` + "`" + `CriblOut` + "`" + `"; Requires replacement if changed.`,
					},
					"compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`gzip`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Choose data compression format to apply before moving files to final destination. Default: "gzip"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"compression_level": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`best_speed`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Compression level to apply before moving files to final destination. Default: "best_speed"; must be one of ["best_speed", "normal", "best_compression"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"best_speed",
								"normal",
								"best_compression",
							),
						},
					},
					"deadletter_enabled": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors. Default: false; Requires replacement if changed.`,
					},
					"deadletter_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/outputs/dead-letter`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Storage location for files that fail to reach their final destination after maximum retries are exceeded. Default: "$CRIBL_HOME/state/outputs/dead-letter"; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"dest_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Final destination for the output files. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"empty_dir_cleanup_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How frequently, in seconds, to clean up empty directories when 'Remove empty staging dirs' is enabled. Default: 300; Requires replacement if changed.`,
					},
					"enable_page_checksum": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Parquet tools can use the checksum of a Parquet page to verify data integrity. Default: false; Requires replacement if changed.`,
					},
					"enable_statistics": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics. Default: true; Requires replacement if changed.`,
					},
					"enable_write_page_index": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping. Default: true; Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"file_name_suffix": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`` + "`" + `.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}` + "`" + ``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to define the output filename suffix (can be constant).  The ` + "`" + `__format` + "`" + ` variable refers to the value of the ` + "`" + `Data format` + "`" + ` field (` + "`" + `json` + "`" + ` or ` + "`" + `raw` + "`" + `).  The ` + "`" + `__compression` + "`" + ` field refers to the kind of compression being used (` + "`" + `none` + "`" + ` or ` + "`" + `gzip` + "`" + `). Default: "` + "`" + `.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}` + "`" + `"; Requires replacement if changed.`,
					},
					"format": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`json`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Format of the output data. Default: "json"; must be one of ["json", "raw", "parquet"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"json",
								"raw",
								"parquet",
							),
						},
					},
					"header_line": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `If set, this line will be written to the beginning of each output file. Default: ""; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"key_value_metadata": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed: true,
									Optional: true,
									Default:  stringdefault.StaticString(``),
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Default: ""; Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging, e.g., "key":"OCSF Event Class", "value":"9001". Requires replacement if changed.`,
					},
					"max_file_idle_time_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30; Requires replacement if changed.`,
					},
					"max_file_open_time_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300; Requires replacement if changed.`,
					},
					"max_file_size_mb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(32)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 32; Requires replacement if changed.`,
					},
					"max_open_files": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(100)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100; Requires replacement if changed.`,
					},
					"max_retry_num": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(20)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum number of times a file will attempt to move to its final destination before being dead-lettered. Default: 20; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"on_disk_full_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"parquet_data_page_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`DATA_PAGE_V2`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it. Default: "DATA_PAGE_V2"; must be one of ["DATA_PAGE_V1", "DATA_PAGE_V2"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"DATA_PAGE_V1",
								"DATA_PAGE_V2",
							),
						},
					},
					"parquet_page_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression. Default: "1MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:[kK][bB]|[mM][bB]|[gG][bB]|[tT][bB])?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:[kK][bB]|[mM][bB]|[gG][bB]|[tT][bB])?$`).String()),
						},
					},
					"parquet_row_group_length": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The number of rows that every group will contain. The final group can contain a smaller number of rows. Default: 10000; Requires replacement if changed.`,
					},
					"parquet_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`PARQUET_2_6`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Determines which data types are supported and how they are represented. Default: "PARQUET_2_6"; must be one of ["PARQUET_1_0", "PARQUET_2_4", "PARQUET_2_6"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"PARQUET_1_0",
								"PARQUET_2_4",
								"PARQUET_2_6",
							),
						},
					},
					"partition_expr": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory. Default: "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"; Requires replacement if changed.`,
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"remove_empty_dirs": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Remove empty staging directories after moving files. Default: true; Requires replacement if changed.`,
					},
					"should_log_invalid_rows": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Log up to 3 rows that @{product} skips due to data mismatch. Requires replacement if changed.`,
					},
					"stage_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Filesystem location in which to buffer files before compressing and moving to final destination. Use performant, stable storage. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "filesystem"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf(
								"filesystem",
							),
						},
					},
					"write_high_water_mark": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(64)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Buffer size used to write to a file. Default: 64; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_google_chronicle": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"api_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Organization's API key in Google SecOps. Requires replacement if changed.`,
					},
					"api_key_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"api_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`v1`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default: "v1"; must be one of ["v1", "v2"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("v1", "v2"),
						},
					},
					"authentication_method": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`serviceAccount`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default: "serviceAccount"; must be one of ["manual", "secret", "serviceAccount", "serviceAccountSecret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"manual",
								"secret",
								"serviceAccount",
								"serviceAccountSecret",
							),
						},
					},
					"compress": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Compress the payload body before sending. Default: true; Requires replacement if changed.`,
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"custom_labels": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Label key. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Label value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Custom labels to be added to every batch. Requires replacement if changed.`,
					},
					"customer_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique identifier (UUID) corresponding to a particular SecOps instance. Provided by your SecOps representative. Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. Requires replacement if changed.`,
					},
					"extra_log_types": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"description": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Log type description. Requires replacement if changed.`,
								},
								"log_type": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Log type. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
										stringvalidator.RegexMatches(regexp.MustCompile(`^[A-Z0-9_]+$`), "must match pattern "+regexp.MustCompile(`^[A-Z0-9_]+$`).String()),
									},
								},
							},
						},
						Description: `Custom log types. If the value "Custom" is selected in the setting "Default log type" above, the first custom log type in this table will be automatically selected as default log type. Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"log_format_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`unstructured`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default: "unstructured"; must be one of ["unstructured", "udm"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"unstructured",
								"udm",
							),
						},
					},
					"log_text_field": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the event field that contains the log text to send. If not specified, Stream sends a JSON representation of the whole event. Requires replacement if changed.`,
					},
					"log_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default log type value to send to SecOps. Can be overwritten by event field __logType. Requires replacement if changed.`,
					},
					"max_payload_events": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1024)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size, in KB, of the request body. Default: 1024; Requires replacement if changed.`,
					},
					"namespace": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `User-configured environment namespace to identify the data domain the logs originated from. Use namespace as a tag to identify the appropriate data domain for indexing and enrichment functionality. Can be overwritten by event field __namespace. Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"region": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Regional endpoint to send events to. Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"service_account_credentials": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right. Requires replacement if changed.`,
					},
					"service_account_credentials_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(90)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 90; Requires replacement if changed.`,
					},
					"total_memory_limit_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "google_chronicle"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf(
								"google_chronicle",
							),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. Default: false; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_google_cloud_logging": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"cache_fill_bytes_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the HTTP request cache fill bytes as a string, in int64 format. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details. Requires replacement if changed.`,
					},
					"cache_hit_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the HTTP request cache hit as a boolean. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details. Requires replacement if changed.`,
					},
					"cache_lookup_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the HTTP request cache lookup as a boolean. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details. Requires replacement if changed.`,
					},
					"cache_validated_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the HTTP request cache validated with origin server as a boolean. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details. Requires replacement if changed.`,
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"connection_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"file_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the log entry source location file as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentrysourcelocation) for details. Requires replacement if changed.`,
					},
					"first_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the log entry operation first flag as a boolean. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentryoperation) for details. Requires replacement if changed.`,
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size. Default: 1; Requires replacement if changed.`,
					},
					"function_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the log entry source location function as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentrysourcelocation) for details. Requires replacement if changed.`,
					},
					"google_auth_method": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`manual`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Google authentication method. Choose Auto to use Google Application Default Credentials. Default: "manual"; must be one of ["auto", "manual", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"auto",
								"manual",
								"secret",
							),
						},
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"id_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the log entry operation ID as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentryoperation) for details. Requires replacement if changed.`,
					},
					"index_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the log entry log split index as a number. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logsplit) for details. Requires replacement if changed.`,
					},
					"insert_id_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to compute the value of the insert ID field. Requires replacement if changed.`,
					},
					"last_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the log entry operation last flag as a boolean. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentryoperation) for details. Requires replacement if changed.`,
					},
					"latency_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the HTTP request latency, formatted as <seconds>.<nanoseconds>s (for example, 1.23s). See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details. Requires replacement if changed.`,
					},
					"line_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the log entry source location line as a string, in int64 format. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentrysourcelocation) for details. Requires replacement if changed.`,
					},
					"log_labels": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"label": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Label name. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
								"value_expression": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `JavaScript expression to compute the label's value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Labels to apply to the log entry. Requires replacement if changed.`,
					},
					"log_location_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to compute the value of the folder ID with which log entries should be associated. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"log_location_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be one of ["project", "organization", "billingAccount", "folder"]; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf(
								"project",
								"organization",
								"billingAccount",
								"folder",
							),
						},
					},
					"log_name_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to compute the value of the log name. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"max_payload_events": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Max number of events to include in the request body. Default is 0 (unlimited). Default: 0; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(4096)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size, in KB, of the request body. Default: 4096; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"payload_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to compute the value of the payload. Must evaluate to a JavaScript object value. If an invalid value is encountered it will result in the default value instead. Defaults to the entire event. Requires replacement if changed.`,
					},
					"payload_format": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`text`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Format to use when sending payload. Defaults to Text. Default: "text"; must be one of ["text", "json"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"text",
								"json",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"producer_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the log entry operation producer as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentryoperation) for details. Requires replacement if changed.`,
					},
					"protocol_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the HTTP request protocol as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details. Requires replacement if changed.`,
					},
					"referer_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the HTTP request referer as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details. Requires replacement if changed.`,
					},
					"remote_ip_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the HTTP request remote IP as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details. Requires replacement if changed.`,
					},
					"request_method_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the HTTP request method as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details. Requires replacement if changed.`,
					},
					"request_size_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the HTTP request size as a string, in int64 format. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details. Requires replacement if changed.`,
					},
					"request_url_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the HTTP request URL as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details. Requires replacement if changed.`,
					},
					"resource_type_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to compute the value of the managed resource type field. Must evaluate to one of the valid values [here](https://cloud.google.com/logging/docs/api/v2/resource-list#resource-types). Defaults to "global". Requires replacement if changed.`,
					},
					"resource_type_labels": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"label": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Label name. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
								"value_expression": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `JavaScript expression to compute the label's value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Labels to apply to the managed resource. These must correspond to the valid labels for the specified resource type (see [here](https://cloud.google.com/logging/docs/api/v2/resource-list#resource-types)). Otherwise, they will be dropped by Google Cloud Logging. Requires replacement if changed.`,
					},
					"response_size_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the HTTP response size as a string, in int64 format. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details. Requires replacement if changed.`,
					},
					"secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"server_ip_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the HTTP request server IP as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details. Requires replacement if changed.`,
					},
					"service_account_credentials": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right. Requires replacement if changed.`,
					},
					"severity_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to compute the value of the severity field. Must evaluate to one of the severity values supported by Google Cloud Logging [here](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logseverity) (case insensitive). Defaults to "DEFAULT". Requires replacement if changed.`,
					},
					"span_id_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the ID of the cloud trace span associated with the current operation in which the log is being written as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry) for details. Requires replacement if changed.`,
					},
					"status_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the HTTP request method as a number. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"throttle_rate_req_per_sec": schema.Int64Attribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
							speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of requests to limit to per second. Requires replacement if changed.`,
						Validators: []validator.Int64{
							int64validator.AtMost(2000),
						},
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"total_memory_limit_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced. Requires replacement if changed.`,
					},
					"total_splits_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the log entry log split total splits as a number. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logsplit) for details. Requires replacement if changed.`,
					},
					"trace_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the REST resource name of the trace being written as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry) for details. Requires replacement if changed.`,
					},
					"trace_sampled_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the the sampling decision of the span associated with the log entry. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry) for details. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "google_cloud_logging"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"google_cloud_logging",
							),
						},
					},
					"uid_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the log entry log split UID as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logsplit) for details. Requires replacement if changed.`,
					},
					"user_agent_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JavaScript expression that evaluates to the HTTP request user agent as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details. Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_google_cloud_storage": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"add_id_to_stage_path": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Append output's ID to staging location. Default: true; Requires replacement if changed.`,
					},
					"automatic_schema": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Automatically calculate the schema based on the events of each Parquet file generated. Default: false; Requires replacement if changed.`,
					},
					"aws_api_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `HMAC access key. This value can be a constant or a JavaScript expression (e.g., ` + "`" + `${C.env.GCS_ACCESS_KEY}` + "`" + `). Requires replacement if changed.`,
					},
					"aws_authentication_method": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`manual`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default: "manual"; must be one of ["auto", "manual", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"auto",
								"manual",
								"secret",
							),
						},
					},
					"aws_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored secret that references your access key and secret key. Requires replacement if changed.`,
					},
					"aws_secret_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `HMAC secret. This value can be a constant or a JavaScript expression (e.g., ` + "`" + `${C.env.GCS_SECRET}` + "`" + `). Requires replacement if changed.`,
					},
					"base_file_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`` + "`" + `CriblOut` + "`" + ``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to define the output filename prefix (can be constant). Default: "` + "`" + `CriblOut` + "`" + `"; Requires replacement if changed.`,
					},
					"bucket": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the destination bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example of referencing a Global Variable: ` + "`" + `myBucket-${C.vars.myVar}` + "`" + `. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`gzip`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Choose data compression format to apply before moving files to final destination. Default: "gzip"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"compression_level": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`best_speed`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Compression level to apply before moving files to final destination. Default: "best_speed"; must be one of ["best_speed", "normal", "best_compression"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"best_speed",
								"normal",
								"best_compression",
							),
						},
					},
					"deadletter_enabled": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors. Default: false; Requires replacement if changed.`,
					},
					"deadletter_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/outputs/dead-letter`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Storage location for files that fail to reach their final destination after maximum retries are exceeded. Default: "$CRIBL_HOME/state/outputs/dead-letter"; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"dest_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Prefix to append to files before uploading. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: ` + "`" + `myKeyPrefix-${C.vars.myVar}` + "`" + `. Default: ""; Requires replacement if changed.`,
					},
					"empty_dir_cleanup_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How frequently, in seconds, to clean up empty directories when 'Remove empty staging dirs' is enabled. Default: 300; Requires replacement if changed.`,
					},
					"enable_page_checksum": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Parquet tools can use the checksum of a Parquet page to verify data integrity. Default: false; Requires replacement if changed.`,
					},
					"enable_statistics": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics. Default: true; Requires replacement if changed.`,
					},
					"enable_write_page_index": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping. Default: true; Requires replacement if changed.`,
					},
					"endpoint": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`https://storage.googleapis.com`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Google Cloud Storage service endpoint. Default: "https://storage.googleapis.com"; Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"file_name_suffix": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`` + "`" + `.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}` + "`" + ``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to define the output filename suffix (can be constant).  The ` + "`" + `__format` + "`" + ` variable refers to the value of the ` + "`" + `Data format` + "`" + ` field (` + "`" + `json` + "`" + ` or ` + "`" + `raw` + "`" + `).  The ` + "`" + `__compression` + "`" + ` field refers to the kind of compression being used (` + "`" + `none` + "`" + ` or ` + "`" + `gzip` + "`" + `). Default: "` + "`" + `.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}` + "`" + `"; Requires replacement if changed.`,
					},
					"format": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`json`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Format of the output data. Default: "json"; must be one of ["json", "raw", "parquet"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"json",
								"raw",
								"parquet",
							),
						},
					},
					"header_line": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `If set, this line will be written to the beginning of each output file. Default: ""; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"key_value_metadata": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed: true,
									Optional: true,
									Default:  stringdefault.StaticString(``),
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Default: ""; Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging, e.g., "key":"OCSF Event Class", "value":"9001". Requires replacement if changed.`,
					},
					"max_file_idle_time_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30; Requires replacement if changed.`,
					},
					"max_file_open_time_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300; Requires replacement if changed.`,
					},
					"max_file_size_mb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(32)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 32; Requires replacement if changed.`,
					},
					"max_open_files": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(100)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100; Requires replacement if changed.`,
					},
					"max_retry_num": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(20)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum number of times a file will attempt to move to its final destination before being dead-lettered. Default: 20; Requires replacement if changed.`,
					},
					"object_acl": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`private`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Object ACL to assign to uploaded objects. Default: "private"; must be one of ["private", "bucket-owner-read", "bucket-owner-full-control", "project-private", "authenticated-read", "public-read"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"private",
								"bucket-owner-read",
								"bucket-owner-full-control",
								"project-private",
								"authenticated-read",
								"public-read",
							),
						},
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"on_disk_full_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"parquet_data_page_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`DATA_PAGE_V2`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it. Default: "DATA_PAGE_V2"; must be one of ["DATA_PAGE_V1", "DATA_PAGE_V2"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"DATA_PAGE_V1",
								"DATA_PAGE_V2",
							),
						},
					},
					"parquet_page_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression. Default: "1MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:[kK][bB]|[mM][bB]|[gG][bB]|[tT][bB])?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:[kK][bB]|[mM][bB]|[gG][bB]|[tT][bB])?$`).String()),
						},
					},
					"parquet_row_group_length": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The number of rows that every group will contain. The final group can contain a smaller number of rows. Default: 10000; Requires replacement if changed.`,
					},
					"parquet_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`PARQUET_2_6`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Determines which data types are supported and how they are represented. Default: "PARQUET_2_6"; must be one of ["PARQUET_1_0", "PARQUET_2_4", "PARQUET_2_6"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"PARQUET_1_0",
								"PARQUET_2_4",
								"PARQUET_2_6",
							),
						},
					},
					"partition_expr": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory. Default: "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"; Requires replacement if changed.`,
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"region": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Region where the bucket is located. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates). Default: true; Requires replacement if changed.`,
					},
					"remove_empty_dirs": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Remove empty staging directories after moving files. Default: true; Requires replacement if changed.`,
					},
					"reuse_connections": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to reuse connections between requests, which can improve performance. Default: true; Requires replacement if changed.`,
					},
					"should_log_invalid_rows": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Log up to 3 rows that @{product} skips due to data mismatch. Requires replacement if changed.`,
					},
					"signature_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`v4`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Signature version to use for signing Google Cloud Storage requests. Default: "v4"; must be one of ["v2", "v4"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("v2", "v4"),
						},
					},
					"stage_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/outputs/staging`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage. Default: "$CRIBL_HOME/state/outputs/staging"; Requires replacement if changed.`,
					},
					"storage_class": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Storage class to select for uploaded objects. must be one of ["STANDARD", "NEARLINE", "COLDLINE", "ARCHIVE"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"STANDARD",
								"NEARLINE",
								"COLDLINE",
								"ARCHIVE",
							),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "google_cloud_storage"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"google_cloud_storage",
							),
						},
					},
					"verify_permissions": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Disable if you can access files within the bucket but not the bucket itself. Default: true; Requires replacement if changed.`,
					},
					"write_high_water_mark": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(64)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Buffer size used to write to a file. Default: 64; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_google_pubsub": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"batch_size": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum number of items the Google API should batch before it sends them to the topic. Default: 1000; Requires replacement if changed.`,
					},
					"batch_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(100)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum amount of time, in milliseconds, that the Google API should wait to send a batch (if the Batch size is not reached). Default: 100; Requires replacement if changed.`,
					},
					"create_topic": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `If enabled, create topic if it does not exist. Default: false; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time to wait before sending a batch (when batch size limit is not reached). Default: 1; Requires replacement if changed.`,
					},
					"google_auth_method": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`manual`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Google authentication method. Choose Auto to use Google Application Default Credentials. Default: "manual"; must be one of ["auto", "manual", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"auto",
								"manual",
								"secret",
							),
						},
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"max_in_progress": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum number of in-progress API requests before backpressure is applied. Default: 10; Requires replacement if changed.`,
					},
					"max_queue_size": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(100)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of queued batches before blocking. Default: 100; Requires replacement if changed.`,
					},
					"max_record_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(256)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size (KB) of batches to send. Default: 256; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"ordered_delivery": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `If enabled, send events in the order they were added to the queue. For this to work correctly, the process receiving events must have ordering enabled. Default: false; Requires replacement if changed.`,
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"region": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Region to publish messages to. Select 'default' to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy. Requires replacement if changed.`,
					},
					"secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"service_account_credentials": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"topic_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `ID of the topic to send events to. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "google_pubsub"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf(
								"google_pubsub",
							),
						},
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_grafana_cloud": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"one": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"compress": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Whether to compress the payload body before sending. Applies only to Loki's JSON payloads, as both Prometheus' and Loki's Protobuf variant are snappy-compressed by default. Default: true; Requires replacement if changed.`,
							},
							"concurrency": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum number of ongoing requests before blocking. Warning: Setting this value > 1 can cause Loki and Prometheus to complain about entries being delivered out of order. Default: 1; Requires replacement if changed.`,
							},
							"description": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Requires replacement if changed.`,
							},
							"environment": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
							},
							"extra_http_headers": schema.ListNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								NestedObject: schema.NestedAttributeObject{
									Validators: []validator.Object{
										speakeasy_objectvalidators.NotNull(),
									},
									PlanModifiers: []planmodifier.Object{
										objectplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `Field name. Requires replacement if changed.`,
										},
										"value": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `Field value. Not Null; Requires replacement if changed.`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
									},
								},
								Description: `Headers to add to all events. Requires replacement if changed.`,
							},
							"failed_request_logging_mode": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`none`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"payload",
										"payloadAndHeaders",
										"none",
									),
								},
							},
							"flush_period_sec": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(15)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Maximum time between requests. Small values can reduce the payload size below the configured 'Max record size' and 'Max events per request'. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order. Default: 15; Requires replacement if changed.`,
							},
							"id": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Unique ID for this output. Not Null; Requires replacement if changed.`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"labels": schema.ListNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								NestedObject: schema.NestedAttributeObject{
									Validators: []validator.Object{
										speakeasy_objectvalidators.NotNull(),
									},
									PlanModifiers: []planmodifier.Object{
										objectplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Computed: true,
											Optional: true,
											Default:  stringdefault.StaticString(``),
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `Name of the label. Default: ""; Requires replacement if changed.`,
										},
										"value": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `Value of the label. Not Null; Requires replacement if changed.`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
									},
								},
								Description: `List of labels to send with logs. Labels define Loki streams, so use static labels to avoid proliferating label value combinations and streams. Can be merged and/or overridden by the event's __labels field (e.g.: '__labels: {host: "cribl.io", level: "error"}'). Requires replacement if changed.`,
							},
							"loki_auth": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									objectplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"auth_type": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`basic`),
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `The authentication method to use for the HTTP requests. Default: "basic"; must be one of ["none", "token", "textSecret", "basic", "credentialsSecret"]; Requires replacement if changed.`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"none",
												"token",
												"textSecret",
												"basic",
												"credentialsSecret",
											),
										},
									},
									"credentials_secret": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Select or create a secret that references your credentials. Requires replacement if changed.`,
									},
									"password": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Password (a.k.a API key in Grafana Cloud domain) for authentication. Requires replacement if changed.`,
									},
									"text_secret": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Select or create a stored text secret. Requires replacement if changed.`,
									},
									"token": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Bearer token to include in the authorization header. In Grafana Cloud, this is generally built by concatenating the username and the API key, separated by a colon. E.g.: <your-username>:<your-api-key>. Requires replacement if changed.`,
									},
									"username": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Username for authentication. Requires replacement if changed.`,
									},
								},
								Description: `Requires replacement if changed.`,
							},
							"loki_url": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The endpoint to send logs to, e.g.: https://logs-prod-us-central1.grafana.net. Not Null; Requires replacement if changed.`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.RegexMatches(regexp.MustCompile(`^https?://`), "must match pattern "+regexp.MustCompile(`^https?://`).String()),
								},
							},
							"max_payload_events": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum number of events to include in the request body. Default is 0 (unlimited). Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order. Default: 0; Requires replacement if changed.`,
							},
							"max_payload_size_kb": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(4096)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum size, in KB, of the request body. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order. Default: 4096; Requires replacement if changed.`,
							},
							"message": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Name of the event field that contains the message to send. If not specified, Stream sends a JSON representation of the whole event. Requires replacement if changed.`,
							},
							"message_format": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`protobuf`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Which format to use when sending logs to Loki (Protobuf or JSON).  Defaults to Protobuf. Default: "protobuf"; must be one of ["protobuf", "json"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"protobuf",
										"json",
									),
								},
							},
							"metric_rename_expr": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`name.replace(/[^a-zA-Z0-9_]/g, '_')`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `A JS expression that can be used to rename metrics. E.g.: name.replace(/\./g, '_') will replace all '.' characters in a metric's name with the supported '_' character. Use the 'name' global variable to access the metric's name.  You can access event fields' values via __e.<fieldName>. Default: "name.replace(/[^a-zA-Z0-9_]/g, '_')"; Requires replacement if changed.`,
							},
							"on_backpressure": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`block`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"block",
										"drop",
										"queue",
									),
								},
							},
							"pipeline": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
							},
							"pq_compress": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`none`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"pq_controls": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									objectplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Description: `Requires replacement if changed.`,
							},
							"pq_max_file_size": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`1 MB`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"pq_max_size": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`5GB`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"pq_mode": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`error`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"error",
										"backpressure",
										"always",
									),
								},
							},
							"pq_on_backpressure": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`block`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"block",
										"drop",
									),
								},
							},
							"pq_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
							},
							"prometheus_auth": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									objectplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"auth_type": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`basic`),
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `The authentication method to use for the HTTP requests. Default: "basic"; must be one of ["none", "token", "textSecret", "basic", "credentialsSecret"]; Requires replacement if changed.`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"none",
												"token",
												"textSecret",
												"basic",
												"credentialsSecret",
											),
										},
									},
									"credentials_secret": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Select or create a secret that references your credentials. Requires replacement if changed.`,
									},
									"password": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Password (a.k.a API key in Grafana Cloud domain) for authentication. Requires replacement if changed.`,
									},
									"text_secret": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Select or create a stored text secret. Requires replacement if changed.`,
									},
									"token": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Bearer token to include in the authorization header. In Grafana Cloud, this is generally built by concatenating the username and the API key, separated by a colon. E.g.: <your-username>:<your-api-key>. Requires replacement if changed.`,
									},
									"username": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Username for authentication. Requires replacement if changed.`,
									},
								},
								Description: `Requires replacement if changed.`,
							},
							"prometheus_url": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The remote_write endpoint to send Prometheus metrics to, e.g.: https://prometheus-blocks-prod-us-central1.grafana.net/api/prom/push. Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^https?://`), "must match pattern "+regexp.MustCompile(`^https?://`).String()),
								},
							},
							"reject_unauthorized": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
									`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
									`        that value will take precedence.` + "\n" +
									`Default: true; Requires replacement if changed.`,
							},
							"response_honor_retry_after_header": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
							},
							"response_retry_settings": schema.ListNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								NestedObject: schema.NestedAttributeObject{
									Validators: []validator.Object{
										speakeasy_objectvalidators.NotNull(),
									},
									PlanModifiers: []planmodifier.Object{
										objectplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"backoff_rate": schema.NumberAttribute{
											Computed: true,
											Optional: true,
											Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
											PlanModifiers: []planmodifier.Number{
												numberplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
											},
											Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
										},
										"http_status": schema.NumberAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.Number{
												numberplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
											},
											Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
											Validators: []validator.Number{
												speakeasy_numbervalidators.NotNull(),
											},
										},
										"initial_backoff": schema.NumberAttribute{
											Computed: true,
											Optional: true,
											Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
											PlanModifiers: []planmodifier.Number{
												numberplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
											},
											Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
										},
										"max_backoff": schema.NumberAttribute{
											Computed: true,
											Optional: true,
											Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
											PlanModifiers: []planmodifier.Number{
												numberplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
											},
											Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
										},
									},
								},
								Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
							},
							"safe_headers": schema.ListAttribute{
								Computed: true,
								Optional: true,
								Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								ElementType: types.StringType,
								Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
							},
							"streamtags": schema.ListAttribute{
								Computed: true,
								Optional: true,
								Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								ElementType: types.StringType,
								Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
							},
							"system_fields": schema.ListAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								ElementType: types.StringType,
								Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. These fields are added as dimensions and labels to generated metrics and logs, respectively. Requires replacement if changed.`,
							},
							"timeout_retry_settings": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									objectplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"backoff_rate": schema.NumberAttribute{
										Computed: true,
										Optional: true,
										Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
										PlanModifiers: []planmodifier.Number{
											numberplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
										},
										Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
									},
									"initial_backoff": schema.NumberAttribute{
										Computed: true,
										Optional: true,
										Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
										PlanModifiers: []planmodifier.Number{
											numberplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
										},
										Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
									},
									"max_backoff": schema.NumberAttribute{
										Computed: true,
										Optional: true,
										Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
										PlanModifiers: []planmodifier.Number{
											numberplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
										},
										Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
									},
									"timeout_retry": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(false),
										PlanModifiers: []planmodifier.Bool{
											boolplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
									},
								},
								Description: `Requires replacement if changed.`,
							},
							"timeout_sec": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
							},
							"type": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Not Null; must be "grafana_cloud"; Requires replacement if changed.`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"grafana_cloud",
									),
								},
							},
							"use_round_robin_dns": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("two"),
							}...),
						},
					},
					"two": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"compress": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Whether to compress the payload body before sending. Applies only to Loki's JSON payloads, as both Prometheus' and Loki's Protobuf variant are snappy-compressed by default. Default: true; Requires replacement if changed.`,
							},
							"concurrency": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum number of ongoing requests before blocking. Warning: Setting this value > 1 can cause Loki and Prometheus to complain about entries being delivered out of order. Default: 1; Requires replacement if changed.`,
							},
							"description": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Requires replacement if changed.`,
							},
							"environment": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
							},
							"extra_http_headers": schema.ListNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								NestedObject: schema.NestedAttributeObject{
									Validators: []validator.Object{
										speakeasy_objectvalidators.NotNull(),
									},
									PlanModifiers: []planmodifier.Object{
										objectplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `Field name. Requires replacement if changed.`,
										},
										"value": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `Field value. Not Null; Requires replacement if changed.`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
									},
								},
								Description: `Headers to add to all events. Requires replacement if changed.`,
							},
							"failed_request_logging_mode": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`none`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"payload",
										"payloadAndHeaders",
										"none",
									),
								},
							},
							"flush_period_sec": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(15)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Maximum time between requests. Small values can reduce the payload size below the configured 'Max record size' and 'Max events per request'. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order. Default: 15; Requires replacement if changed.`,
							},
							"id": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Unique ID for this output. Not Null; Requires replacement if changed.`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"labels": schema.ListNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								NestedObject: schema.NestedAttributeObject{
									Validators: []validator.Object{
										speakeasy_objectvalidators.NotNull(),
									},
									PlanModifiers: []planmodifier.Object{
										objectplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Computed: true,
											Optional: true,
											Default:  stringdefault.StaticString(``),
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `Name of the label. Default: ""; Requires replacement if changed.`,
										},
										"value": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `Value of the label. Not Null; Requires replacement if changed.`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
									},
								},
								Description: `List of labels to send with logs. Labels define Loki streams, so use static labels to avoid proliferating label value combinations and streams. Can be merged and/or overridden by the event's __labels field (e.g.: '__labels: {host: "cribl.io", level: "error"}'). Requires replacement if changed.`,
							},
							"loki_auth": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									objectplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"auth_type": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`basic`),
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `The authentication method to use for the HTTP requests. Default: "basic"; must be one of ["none", "token", "textSecret", "basic", "credentialsSecret"]; Requires replacement if changed.`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"none",
												"token",
												"textSecret",
												"basic",
												"credentialsSecret",
											),
										},
									},
									"credentials_secret": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Select or create a secret that references your credentials. Requires replacement if changed.`,
									},
									"password": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Password (a.k.a API key in Grafana Cloud domain) for authentication. Requires replacement if changed.`,
									},
									"text_secret": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Select or create a stored text secret. Requires replacement if changed.`,
									},
									"token": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Bearer token to include in the authorization header. In Grafana Cloud, this is generally built by concatenating the username and the API key, separated by a colon. E.g.: <your-username>:<your-api-key>. Requires replacement if changed.`,
									},
									"username": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Username for authentication. Requires replacement if changed.`,
									},
								},
								Description: `Requires replacement if changed.`,
							},
							"loki_url": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The endpoint to send logs to, e.g.: https://logs-prod-us-central1.grafana.net. Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^https?://`), "must match pattern "+regexp.MustCompile(`^https?://`).String()),
								},
							},
							"max_payload_events": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum number of events to include in the request body. Default is 0 (unlimited). Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order. Default: 0; Requires replacement if changed.`,
							},
							"max_payload_size_kb": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(4096)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum size, in KB, of the request body. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order. Default: 4096; Requires replacement if changed.`,
							},
							"message": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Name of the event field that contains the message to send. If not specified, Stream sends a JSON representation of the whole event. Requires replacement if changed.`,
							},
							"message_format": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`protobuf`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Which format to use when sending logs to Loki (Protobuf or JSON).  Defaults to Protobuf. Default: "protobuf"; must be one of ["protobuf", "json"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"protobuf",
										"json",
									),
								},
							},
							"metric_rename_expr": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`name.replace(/[^a-zA-Z0-9_]/g, '_')`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `A JS expression that can be used to rename metrics. E.g.: name.replace(/\./g, '_') will replace all '.' characters in a metric's name with the supported '_' character. Use the 'name' global variable to access the metric's name.  You can access event fields' values via __e.<fieldName>. Default: "name.replace(/[^a-zA-Z0-9_]/g, '_')"; Requires replacement if changed.`,
							},
							"on_backpressure": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`block`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"block",
										"drop",
										"queue",
									),
								},
							},
							"pipeline": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
							},
							"pq_compress": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`none`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"pq_controls": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									objectplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Description: `Requires replacement if changed.`,
							},
							"pq_max_file_size": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`1 MB`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"pq_max_size": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`5GB`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"pq_mode": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`error`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"error",
										"backpressure",
										"always",
									),
								},
							},
							"pq_on_backpressure": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`block`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"block",
										"drop",
									),
								},
							},
							"pq_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
							},
							"prometheus_auth": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									objectplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"auth_type": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`basic`),
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `The authentication method to use for the HTTP requests. Default: "basic"; must be one of ["none", "token", "textSecret", "basic", "credentialsSecret"]; Requires replacement if changed.`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"none",
												"token",
												"textSecret",
												"basic",
												"credentialsSecret",
											),
										},
									},
									"credentials_secret": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Select or create a secret that references your credentials. Requires replacement if changed.`,
									},
									"password": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Password (a.k.a API key in Grafana Cloud domain) for authentication. Requires replacement if changed.`,
									},
									"text_secret": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Select or create a stored text secret. Requires replacement if changed.`,
									},
									"token": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Bearer token to include in the authorization header. In Grafana Cloud, this is generally built by concatenating the username and the API key, separated by a colon. E.g.: <your-username>:<your-api-key>. Requires replacement if changed.`,
									},
									"username": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Username for authentication. Requires replacement if changed.`,
									},
								},
								Description: `Requires replacement if changed.`,
							},
							"prometheus_url": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The remote_write endpoint to send Prometheus metrics to, e.g.: https://prometheus-blocks-prod-us-central1.grafana.net/api/prom/push. Not Null; Requires replacement if changed.`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.RegexMatches(regexp.MustCompile(`^https?://`), "must match pattern "+regexp.MustCompile(`^https?://`).String()),
								},
							},
							"reject_unauthorized": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
									`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
									`        that value will take precedence.` + "\n" +
									`Default: true; Requires replacement if changed.`,
							},
							"response_honor_retry_after_header": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
							},
							"response_retry_settings": schema.ListNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								NestedObject: schema.NestedAttributeObject{
									Validators: []validator.Object{
										speakeasy_objectvalidators.NotNull(),
									},
									PlanModifiers: []planmodifier.Object{
										objectplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"backoff_rate": schema.NumberAttribute{
											Computed: true,
											Optional: true,
											Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
											PlanModifiers: []planmodifier.Number{
												numberplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
											},
											Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
										},
										"http_status": schema.NumberAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.Number{
												numberplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
											},
											Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
											Validators: []validator.Number{
												speakeasy_numbervalidators.NotNull(),
											},
										},
										"initial_backoff": schema.NumberAttribute{
											Computed: true,
											Optional: true,
											Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
											PlanModifiers: []planmodifier.Number{
												numberplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
											},
											Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
										},
										"max_backoff": schema.NumberAttribute{
											Computed: true,
											Optional: true,
											Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
											PlanModifiers: []planmodifier.Number{
												numberplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
											},
											Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
										},
									},
								},
								Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
							},
							"safe_headers": schema.ListAttribute{
								Computed: true,
								Optional: true,
								Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								ElementType: types.StringType,
								Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
							},
							"streamtags": schema.ListAttribute{
								Computed: true,
								Optional: true,
								Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								ElementType: types.StringType,
								Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
							},
							"system_fields": schema.ListAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								ElementType: types.StringType,
								Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. These fields are added as dimensions and labels to generated metrics and logs, respectively. Requires replacement if changed.`,
							},
							"timeout_retry_settings": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									objectplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"backoff_rate": schema.NumberAttribute{
										Computed: true,
										Optional: true,
										Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
										PlanModifiers: []planmodifier.Number{
											numberplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
										},
										Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
									},
									"initial_backoff": schema.NumberAttribute{
										Computed: true,
										Optional: true,
										Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
										PlanModifiers: []planmodifier.Number{
											numberplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
										},
										Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
									},
									"max_backoff": schema.NumberAttribute{
										Computed: true,
										Optional: true,
										Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
										PlanModifiers: []planmodifier.Number{
											numberplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
										},
										Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
									},
									"timeout_retry": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(false),
										PlanModifiers: []planmodifier.Bool{
											boolplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
									},
								},
								Description: `Requires replacement if changed.`,
							},
							"timeout_sec": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
							},
							"type": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Not Null; must be "grafana_cloud"; Requires replacement if changed.`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"grafana_cloud",
									),
								},
							},
							"use_round_robin_dns": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("one"),
							}...),
						},
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_graphite": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"connection_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"dns_resolve_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How often to resolve the destination hostname to an IP address. Ignored if the destination is an IP address. A value of 0 means every batch sent will incur a DNS lookup. Default: 0; Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `When protocol is TCP, specifies how often buffers should be flushed, resulting in records sent to the destination. Default: 1; Requires replacement if changed.`,
					},
					"host": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The hostname of the destination. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"mtu": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(512)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `When protocol is UDP, specifies the maximum size of packets sent to the destination. Also known as the MTU for the network path to the destination system. Default: 512; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"port": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(8125)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Destination port. Default: 8125; Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"protocol": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`udp`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Protocol to use when communicating with the destination. Default: "udp"; must be one of ["udp", "tcp"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"udp",
								"tcp",
							),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"throttle_rate_per_sec": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`0`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`), "must match pattern "+regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`).String()),
						},
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "graphite"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("graphite"),
						},
					},
					"write_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(60000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead. Default: 60000; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_honeycomb": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"auth_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`manual`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Enter API key directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"manual",
								"secret",
							),
						},
					},
					"compress": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Compress the payload body before sending. Default: true; Requires replacement if changed.`,
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"dataset": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the dataset to send events to – e.g., observability. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"max_payload_events": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(4096)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size, in KB, of the request body. Default: 4096; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"team": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Team API key where the dataset belongs. Requires replacement if changed.`,
					},
					"text_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "honeycomb"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf(
								"honeycomb",
							),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_humio_hec": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"auth_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`manual`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"manual",
								"secret",
							),
						},
					},
					"compress": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Compress the payload body before sending. Default: true; Requires replacement if changed.`,
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"format": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`JSON`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `When set to JSON, the event is automatically formatted with required fields before sending. When set to Raw, only the event's ` + "`" + `_raw` + "`" + ` value is sent. Default: "JSON"; must be one of ["JSON", "raw"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"JSON",
								"raw",
							),
						},
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"max_payload_events": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(4096)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size, in KB, of the request body. Default: 4096; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"text_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"token": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `CrowdStrike Falcon LogScale authentication token. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "humio_hec"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"humio_hec",
							),
						},
					},
					"url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`https://cloud.us.humio.com/api/v1/ingest/hec`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `URL to a CrowdStrike Falcon LogScale endpoint to send events to, e.g., https://cloud.us.humio.com/api/v1/ingest/hec for JSON and https://cloud.us.humio.com/api/v1/ingest/hec/raw for raw. Default: "https://cloud.us.humio.com/api/v1/ingest/hec"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: true; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_influxdb": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"auth_header_expr": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`` + "`" + `Bearer ${token}` + "`" + ``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to compute the Authorization header value to pass in requests. The value ` + "`" + `${token}` + "`" + ` is used to reference the token obtained from authentication, e.g.: ` + "`" + `Bearer ${token}` + "`" + `. Default: "` + "`" + `Bearer ${token}` + "`" + `"; Requires replacement if changed.`,
					},
					"auth_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `InfluxDB authentication type. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"basic",
								"credentialsSecret",
								"token",
								"textSecret",
								"oauth",
							),
						},
					},
					"bucket": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Bucket to write to. Requires replacement if changed.`,
					},
					"compress": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Compress the payload body before sending. Default: true; Requires replacement if changed.`,
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"credentials_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a secret that references your credentials. Requires replacement if changed.`,
					},
					"database": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Database to write to. Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"dynamic_value_field_name": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enabling this will pull the value field from the metric name. E,g, 'db.query.user' will use 'db.query' as the measurement and 'user' as the value field. Default: true; Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"login_url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `URL for OAuth. Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
						},
					},
					"max_payload_events": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(4096)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size, in KB, of the request body. Default: 4096; Requires replacement if changed.`,
					},
					"oauth_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `OAuth header name. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `OAuth header value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request. Requires replacement if changed.`,
					},
					"oauth_params": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `OAuth parameter name. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `OAuth parameter value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request. Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"org": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Organization ID for this bucket. Requires replacement if changed.`,
					},
					"password": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Password for Basic authentication. Requires replacement if changed.`,
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Secret parameter value to pass in request body. Requires replacement if changed.`,
					},
					"secret_param_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Secret parameter name to pass in request body. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"text_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"timestamp_precision": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`ms`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Sets the precision for the supplied Unix time values. Defaults to milliseconds. Default: "ms"; must be one of ["ns", "u", "ms", "s", "m", "h"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"ns",
								"u",
								"ms",
								"s",
								"m",
								"h",
							),
						},
					},
					"token": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Bearer token to include in the authorization header. Requires replacement if changed.`,
					},
					"token_attribute_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token'). Requires replacement if changed.`,
					},
					"token_timeout_secs": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(3600)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How often the OAuth token should be refreshed. Default: 3600; Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "influxdb"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf("influxdb"),
						},
					},
					"url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `URL of an InfluxDB cluster to send events to, e.g., http://localhost:8086/write. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false; Requires replacement if changed.`,
					},
					"use_v2_api": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `The v2 API can be enabled with InfluxDB versions 1.8 and later. Default: false; Requires replacement if changed.`,
					},
					"username": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Username for Basic authentication. Requires replacement if changed.`,
					},
					"value_field_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`value`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the field in which to store the metric when sending to InfluxDB. If dynamic generation is enabled and fails, this will be used as a fallback. Default: "value"; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_kafka": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"ack": schema.Int64Attribute{
						Computed: true,
						Optional: true,
						Default:  int64default.StaticInt64(1),
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
							speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
						},
						Description: `Control the number of required acknowledgments. Default: 1; must be one of ["1", "0", "-1"]; Requires replacement if changed.`,
						Validators: []validator.Int64{
							int64validator.OneOf(1, 0, -1),
						},
					},
					"authentication_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time to wait for Kafka to respond to an authentication request. Default: 10000; Requires replacement if changed.`,
					},
					"backoff_rate": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details. Default: 2; Requires replacement if changed.`,
					},
					"brokers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Enter each Kafka bootstrap server you want to use. Specify hostname and port, e.g., mykafkabroker:9092, or just hostname, in which case @{product} will assign port 9092. Not Null; Requires replacement if changed.`,
						Validators: []validator.List{
							speakeasy_listvalidators.NotNull(),
							listvalidator.SizeAtLeast(1),
						},
					},
					"compression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`gzip`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the data before sending to Kafka. Default: "gzip"; must be one of ["none", "gzip", "snappy", "lz4"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
								"snappy",
								"lz4",
							),
						},
					},
					"connection_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time to wait for a connection to complete successfully. Default: 10000; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"flush_event_count": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum number of events you want the Destination to allow in a batch before forcing a flush. Default: 1000; Requires replacement if changed.`,
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum amount of time you want the Destination to wait before forcing a flush. Shorter intervals tend to result in smaller batches being sent. Default: 1; Requires replacement if changed.`,
					},
					"format": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`json`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Format to use to serialize events before writing to Kafka. Default: "json"; must be one of ["json", "raw", "protobuf"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"json",
								"raw",
								"protobuf",
							),
						},
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"initial_backoff": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes). Default: 300; Requires replacement if changed.`,
					},
					"kafka_schema_registry": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"auth": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									objectplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"credentials_secret": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Select or create a secret that references your credentials. Requires replacement if changed.`,
									},
									"disabled": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											boolplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Enable authentication. Default: true; Requires replacement if changed.`,
									},
								},
								Description: `Credentials to use when authenticating with the schema registry using basic HTTP authentication. Requires replacement if changed.`,
							},
							"connection_timeout": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(30000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum time to wait for a Schema Registry connection to complete successfully. Default: 30000; Requires replacement if changed.`,
							},
							"default_key_schema_id": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Used when __keySchemaIdOut is not present, to transform key values, leave blank if key transformation is not required by default. Requires replacement if changed.`,
							},
							"default_value_schema_id": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Used when __valueSchemaIdOut is not present, to transform _raw, leave blank if value transformation is not required by default. Requires replacement if changed.`,
							},
							"disabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable Schema Registry. Default: true; Requires replacement if changed.`,
							},
							"max_retries": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum number of times to try fetching schemas from the Schema Registry. Default: 1; Requires replacement if changed.`,
							},
							"request_timeout": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(30000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum time to wait for the Schema Registry to respond to a request. Default: 30000; Requires replacement if changed.`,
							},
							"schema_registry_url": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`http://localhost:8081`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http. Default: "http://localhost:8081"; Requires replacement if changed.`,
							},
							"tls": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									objectplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"ca_path": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
									},
									"cert_path": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
									},
									"certificate_name": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `The name of the predefined certificate. Requires replacement if changed.`,
									},
									"disabled": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											boolplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Default: true; Requires replacement if changed.`,
									},
									"max_version": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Maximum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"TLSv1",
												"TLSv1.1",
												"TLSv1.2",
												"TLSv1.3",
											),
										},
									},
									"min_version": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Minimum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"TLSv1",
												"TLSv1.1",
												"TLSv1.2",
												"TLSv1.3",
											),
										},
									},
									"passphrase": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Passphrase to use to decrypt private key. Requires replacement if changed.`,
									},
									"priv_key_path": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
									},
									"reject_unauthorized": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											boolplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										MarkdownDescription: `Reject certs that are not authorized by a CA in the CA certificate path, or by another ` + "\n" +
											`                    trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.` + "\n" +
											`Default: true; Requires replacement if changed.`,
									},
									"servername": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address. Requires replacement if changed.`,
									},
								},
								Description: `Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"max_back_off": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds). Default: 30000; Requires replacement if changed.`,
					},
					"max_record_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(768)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size of each record batch before compression. The value must not exceed the Kafka brokers' message.max.bytes setting. Default: 768; Requires replacement if changed.`,
					},
					"max_retries": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data. Default: 5; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"protobuf_library_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select a set of Protobuf definitions for the events you want to send. Requires replacement if changed.`,
					},
					"reauthentication_threshold": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backwards from the moment when credentials are set to expire. Default: 10000; Requires replacement if changed.`,
					},
					"request_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(60000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time to wait for Kafka to respond to a request. Default: 60000; Requires replacement if changed.`,
					},
					"sasl": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"disabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable Authentication. Default: true; Requires replacement if changed.`,
							},
							"mechanism": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`plain`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `SASL authentication mechanism to use. Default: "plain"; must be one of ["plain", "scram-sha-256", "scram-sha-512", "kerberos"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"plain",
										"scram-sha-256",
										"scram-sha-512",
										"kerberos",
									),
								},
							},
						},
						Description: `Authentication parameters to use when connecting to brokers. Using TLS is highly recommended. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"tls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"cert_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"certificate_name": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The name of the predefined certificate. Requires replacement if changed.`,
							},
							"disabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Default: true; Requires replacement if changed.`,
							},
							"max_version": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Minimum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Passphrase to use to decrypt private key. Requires replacement if changed.`,
							},
							"priv_key_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"reject_unauthorized": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								MarkdownDescription: `Reject certs that are not authorized by a CA in the CA certificate path, or by another ` + "\n" +
									`                    trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.` + "\n" +
									`Default: true; Requires replacement if changed.`,
							},
							"servername": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address. Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"topic": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The topic to publish events to. Can be overridden using the __topicOut field. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "kafka"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("kafka"),
						},
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_kinesis": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"as_ndjson": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Batch events into a single record as NDJSON. Default: true; Requires replacement if changed.`,
					},
					"assume_role_arn": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Amazon Resource Name (ARN) of the role to assume. Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.UTF8LengthAtLeast(20),
							stringvalidator.RegexMatches(regexp.MustCompile(`^arn:`), "must match pattern "+regexp.MustCompile(`^arn:`).String()),
						},
					},
					"assume_role_external_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `External ID to use when assuming role. Requires replacement if changed.`,
					},
					"aws_api_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Access key. Requires replacement if changed.`,
					},
					"aws_authentication_method": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`auto`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"auto",
								"manual",
								"secret",
							),
						},
					},
					"aws_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored secret that references your access key and secret key. Requires replacement if changed.`,
					},
					"aws_secret_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Secret key. Requires replacement if changed.`,
					},
					"compression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`gzip`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Compression type to use for records. Default: "gzip"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing put requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"duration_seconds": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(3600)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600; Requires replacement if changed.`,
					},
					"enable_assume_role": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Use Assume Role credentials to access Kinesis stream. Default: false; Requires replacement if changed.`,
					},
					"endpoint": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Kinesis stream service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint. Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size. Default: 1; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"max_record_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1024)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size (KB) of each individual record before compression. For uncompressed or non-compressible data 1MB is the max recommended size. Default: 1024; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"region": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Region where the Kinesis stream is located. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true; Requires replacement if changed.`,
					},
					"reuse_connections": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Reuse connections between requests, which can improve performance. Default: true; Requires replacement if changed.`,
					},
					"signature_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`v4`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Signature version to use for signing Kinesis stream requests. Default: "v4"; must be one of ["v2", "v4"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("v2", "v4"),
						},
					},
					"stream_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Kinesis stream name to send events to. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "kinesis"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("kinesis"),
						},
					},
					"use_list_shards": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Provides higher stream rate limits, improving delivery speed and reliability by minimizing throttling. See the [ListShards API](https://docs.aws.amazon.com/kinesis/latest/APIReference/API_ListShards.html) documentation for details. Default: false; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_loki": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"auth_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The authentication method to use for the HTTP requests. Default: "none"; must be one of ["none", "token", "textSecret", "basic", "credentialsSecret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"token",
								"textSecret",
								"basic",
								"credentialsSecret",
							),
						},
					},
					"compress": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to compress the payload body before sending. Default: true; Requires replacement if changed.`,
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Warning: Setting this value > 1 can cause Loki to complain about entries being delivered out of order. Default: 1; Requires replacement if changed.`,
					},
					"credentials_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a secret that references your credentials. Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(15)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Maximum time between requests. Small values can reduce the payload size below the configured 'Max record size' and 'Max events per request'. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki to complain about entries being delivered out of order. Default: 15; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"labels": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									Default:  stringdefault.StaticString(``),
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Name of the label. Default: ""; Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Value of the label. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `List of labels to send with logs. Labels define Loki streams, so use static labels to avoid proliferating label value combinations and streams. Can be merged and/or overridden by the event's __labels field (e.g.: '__labels: {host: "cribl.io", level: "error"}'). Requires replacement if changed.`,
					},
					"max_payload_events": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of events to include in the request body. Defaults to 0 (unlimited). Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki to complain about entries being delivered out of order. Default: 0; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(4096)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size, in KB, of the request body. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki to complain about entries being delivered out of order. Default: 4096; Requires replacement if changed.`,
					},
					"message": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the event field that contains the message to send. If not specified, Stream sends a JSON representation of the whole event. Requires replacement if changed.`,
					},
					"message_format": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`protobuf`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Which format to use when sending logs to Loki (Protobuf or JSON).  Defaults to Protobuf. Default: "protobuf"; must be one of ["protobuf", "json"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"protobuf",
								"json",
							),
						},
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"password": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Password (a.k.a API key in Grafana Cloud domain) for authentication. Requires replacement if changed.`,
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. These fields are added as labels to generated logs. Requires replacement if changed.`,
					},
					"text_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"token": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Bearer token to include in the authorization header. In Grafana Cloud, this is generally built by concatenating the username and the API key, separated by a colon. E.g.: <your-username>:<your-api-key>. Requires replacement if changed.`,
					},
					"total_memory_limit_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "loki"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf("loki"),
						},
					},
					"url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The endpoint to send logs to. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false; Requires replacement if changed.`,
					},
					"username": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Username for authentication. Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_minio": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"add_id_to_stage_path": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Append output's ID to staging location. Default: true; Requires replacement if changed.`,
					},
					"automatic_schema": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Automatically calculate the schema based on the events of each Parquet file generated. Default: false; Requires replacement if changed.`,
					},
					"aws_api_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Access key. This value can be a constant or a JavaScript expression(e.g., ` + "`" + `${C.env.SOME_ACCESS_KEY}` + "`" + `). Requires replacement if changed.`,
					},
					"aws_authentication_method": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`auto`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"auto",
								"manual",
								"secret",
							),
						},
					},
					"aws_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored secret that references your access key and secret key. Requires replacement if changed.`,
					},
					"aws_secret_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Secret key. This value can be a constant or a JavaScript expression(e.g., ` + "`" + `${C.env.SOME_SECRET}` + "`" + `). Requires replacement if changed.`,
					},
					"base_file_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`` + "`" + `CriblOut` + "`" + ``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to define the output filename prefix (can be constant). Default: "` + "`" + `CriblOut` + "`" + `"; Requires replacement if changed.`,
					},
					"bucket": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the destination MinIO bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. E.g. referencing a Global Variable: ` + "`" + `myBucket-${C.vars.myVar}` + "`" + `. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`gzip`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Choose data compression format to apply before moving files to final destination. Default: "gzip"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"compression_level": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`best_speed`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Compression level to apply before moving files to final destination. Default: "best_speed"; must be one of ["best_speed", "normal", "best_compression"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"best_speed",
								"normal",
								"best_compression",
							),
						},
					},
					"deadletter_enabled": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors. Default: false; Requires replacement if changed.`,
					},
					"deadletter_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/outputs/dead-letter`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Storage location for files that fail to reach their final destination after maximum retries are exceeded. Default: "$CRIBL_HOME/state/outputs/dead-letter"; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"dest_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Root directory to prepend to path before uploading. Enter a constant, or a JS expression enclosed in quotes or backticks. Requires replacement if changed.`,
					},
					"empty_dir_cleanup_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How frequently, in seconds, to clean up empty directories when 'Remove empty staging dirs' is enabled. Default: 300; Requires replacement if changed.`,
					},
					"enable_page_checksum": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Parquet tools can use the checksum of a Parquet page to verify data integrity. Default: false; Requires replacement if changed.`,
					},
					"enable_statistics": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics. Default: true; Requires replacement if changed.`,
					},
					"enable_write_page_index": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping. Default: true; Requires replacement if changed.`,
					},
					"endpoint": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `MinIO service url (e.g. http://minioHost:9000). Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
						},
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"file_name_suffix": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`` + "`" + `.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}` + "`" + ``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to define the output filename suffix (can be constant).  The ` + "`" + `__format` + "`" + ` variable refers to the value of the ` + "`" + `Data format` + "`" + ` field (` + "`" + `json` + "`" + ` or ` + "`" + `raw` + "`" + `).  The ` + "`" + `__compression` + "`" + ` field refers to the kind of compression being used (` + "`" + `none` + "`" + ` or ` + "`" + `gzip` + "`" + `). Default: "` + "`" + `.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}` + "`" + `"; Requires replacement if changed.`,
					},
					"format": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`json`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Format of the output data. Default: "json"; must be one of ["json", "raw", "parquet"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"json",
								"raw",
								"parquet",
							),
						},
					},
					"header_line": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `If set, this line will be written to the beginning of each output file. Default: ""; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"key_value_metadata": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed: true,
									Optional: true,
									Default:  stringdefault.StaticString(``),
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Default: ""; Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging, e.g., "key":"OCSF Event Class", "value":"9001". Requires replacement if changed.`,
					},
					"max_concurrent_file_parts": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(4)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of parts to upload in parallel per file. Minimum part size is 5MB. Default: 4; Requires replacement if changed.`,
					},
					"max_file_idle_time_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30; Requires replacement if changed.`,
					},
					"max_file_open_time_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300; Requires replacement if changed.`,
					},
					"max_file_size_mb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(32)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 32; Requires replacement if changed.`,
					},
					"max_open_files": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(100)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100; Requires replacement if changed.`,
					},
					"max_retry_num": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(20)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum number of times a file will attempt to move to its final destination before being dead-lettered. Default: 20; Requires replacement if changed.`,
					},
					"object_acl": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`private`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Object ACL to assign to uploaded objects. Default: "private"; must be one of ["private", "public-read", "public-read-write", "authenticated-read", "aws-exec-read", "bucket-owner-read", "bucket-owner-full-control"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"private",
								"public-read",
								"public-read-write",
								"authenticated-read",
								"aws-exec-read",
								"bucket-owner-read",
								"bucket-owner-full-control",
							),
						},
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"on_disk_full_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"parquet_data_page_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`DATA_PAGE_V2`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it. Default: "DATA_PAGE_V2"; must be one of ["DATA_PAGE_V1", "DATA_PAGE_V2"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"DATA_PAGE_V1",
								"DATA_PAGE_V2",
							),
						},
					},
					"parquet_page_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression. Default: "1MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:[kK][bB]|[mM][bB]|[gG][bB]|[tT][bB])?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:[kK][bB]|[mM][bB]|[gG][bB]|[tT][bB])?$`).String()),
						},
					},
					"parquet_row_group_length": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The number of rows that every group will contain. The final group can contain a smaller number of rows. Default: 10000; Requires replacement if changed.`,
					},
					"parquet_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`PARQUET_2_6`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Determines which data types are supported and how they are represented. Default: "PARQUET_2_6"; must be one of ["PARQUET_1_0", "PARQUET_2_4", "PARQUET_2_6"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"PARQUET_1_0",
								"PARQUET_2_4",
								"PARQUET_2_6",
							),
						},
					},
					"partition_expr": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory. Default: "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"; Requires replacement if changed.`,
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"region": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Region where the MinIO service/cluster is located. Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates). Default: true; Requires replacement if changed.`,
					},
					"remove_empty_dirs": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Remove empty staging directories after moving files. Default: true; Requires replacement if changed.`,
					},
					"reuse_connections": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to reuse connections between requests, which can improve performance. Default: true; Requires replacement if changed.`,
					},
					"server_side_encryption": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Server-side encryption for uploaded objects. must be "AES256"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("AES256"),
						},
					},
					"should_log_invalid_rows": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Log up to 3 rows that @{product} skips due to data mismatch. Requires replacement if changed.`,
					},
					"signature_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`v4`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Signature version to use for signing MinIO requests. Default: "v4"; must be one of ["v2", "v4"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("v2", "v4"),
						},
					},
					"stage_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/outputs/staging`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage. Default: "$CRIBL_HOME/state/outputs/staging"; Requires replacement if changed.`,
					},
					"storage_class": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Storage class to select for uploaded objects. must be one of ["STANDARD", "REDUCED_REDUNDANCY"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"STANDARD",
								"REDUCED_REDUNDANCY",
							),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "minio"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("minio"),
						},
					},
					"verify_permissions": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Disable if you can access files within the bucket but not the bucket itself. Default: true; Requires replacement if changed.`,
					},
					"write_high_water_mark": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(64)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Buffer size used to write to a file. Default: 64; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_msk": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"ack": schema.Int64Attribute{
						Computed: true,
						Optional: true,
						Default:  int64default.StaticInt64(1),
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
							speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
						},
						Description: `Control the number of required acknowledgments. Default: 1; must be one of ["1", "0", "-1"]; Requires replacement if changed.`,
						Validators: []validator.Int64{
							int64validator.OneOf(1, 0, -1),
						},
					},
					"assume_role_arn": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Amazon Resource Name (ARN) of the role to assume. Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.UTF8LengthAtLeast(20),
							stringvalidator.RegexMatches(regexp.MustCompile(`^arn:`), "must match pattern "+regexp.MustCompile(`^arn:`).String()),
						},
					},
					"assume_role_external_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `External ID to use when assuming role. Requires replacement if changed.`,
					},
					"authentication_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time to wait for Kafka to respond to an authentication request. Default: 10000; Requires replacement if changed.`,
					},
					"aws_api_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Access key. Requires replacement if changed.`,
					},
					"aws_authentication_method": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`auto`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"auto",
								"manual",
								"secret",
							),
						},
					},
					"aws_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored secret that references your access key and secret key. Requires replacement if changed.`,
					},
					"aws_secret_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Secret key. Requires replacement if changed.`,
					},
					"backoff_rate": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details. Default: 2; Requires replacement if changed.`,
					},
					"brokers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Enter each Kafka bootstrap server you want to use. Specify hostname and port, e.g., mykafkabroker:9092, or just hostname, in which case @{product} will assign port 9092. Not Null; Requires replacement if changed.`,
						Validators: []validator.List{
							speakeasy_listvalidators.NotNull(),
							listvalidator.SizeAtLeast(1),
						},
					},
					"compression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`gzip`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the data before sending to Kafka. Default: "gzip"; must be one of ["none", "gzip", "snappy", "lz4"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
								"snappy",
								"lz4",
							),
						},
					},
					"connection_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time to wait for a connection to complete successfully. Default: 10000; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"duration_seconds": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(3600)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600; Requires replacement if changed.`,
					},
					"enable_assume_role": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Use Assume Role credentials to access MSK. Default: false; Requires replacement if changed.`,
					},
					"endpoint": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `MSK cluster service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to MSK cluster-compatible endpoint. Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"flush_event_count": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum number of events you want the Destination to allow in a batch before forcing a flush. Default: 1000; Requires replacement if changed.`,
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum amount of time you want the Destination to wait before forcing a flush. Shorter intervals tend to result in smaller batches being sent. Default: 1; Requires replacement if changed.`,
					},
					"format": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`json`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Format to use to serialize events before writing to Kafka. Default: "json"; must be one of ["json", "raw", "protobuf"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"json",
								"raw",
								"protobuf",
							),
						},
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"initial_backoff": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes). Default: 300; Requires replacement if changed.`,
					},
					"kafka_schema_registry": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"auth": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									objectplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"credentials_secret": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Select or create a secret that references your credentials. Requires replacement if changed.`,
									},
									"disabled": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											boolplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Enable authentication. Default: true; Requires replacement if changed.`,
									},
								},
								Description: `Credentials to use when authenticating with the schema registry using basic HTTP authentication. Requires replacement if changed.`,
							},
							"connection_timeout": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(30000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum time to wait for a Schema Registry connection to complete successfully. Default: 30000; Requires replacement if changed.`,
							},
							"default_key_schema_id": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Used when __keySchemaIdOut is not present, to transform key values, leave blank if key transformation is not required by default. Requires replacement if changed.`,
							},
							"default_value_schema_id": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Used when __valueSchemaIdOut is not present, to transform _raw, leave blank if value transformation is not required by default. Requires replacement if changed.`,
							},
							"disabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable Schema Registry. Default: true; Requires replacement if changed.`,
							},
							"max_retries": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum number of times to try fetching schemas from the Schema Registry. Default: 1; Requires replacement if changed.`,
							},
							"request_timeout": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(30000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum time to wait for the Schema Registry to respond to a request. Default: 30000; Requires replacement if changed.`,
							},
							"schema_registry_url": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`http://localhost:8081`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http. Default: "http://localhost:8081"; Requires replacement if changed.`,
							},
							"tls": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									objectplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"ca_path": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
									},
									"cert_path": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
									},
									"certificate_name": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `The name of the predefined certificate. Requires replacement if changed.`,
									},
									"disabled": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											boolplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Default: true; Requires replacement if changed.`,
									},
									"max_version": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Maximum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"TLSv1",
												"TLSv1.1",
												"TLSv1.2",
												"TLSv1.3",
											),
										},
									},
									"min_version": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Minimum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"TLSv1",
												"TLSv1.1",
												"TLSv1.2",
												"TLSv1.3",
											),
										},
									},
									"passphrase": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Passphrase to use to decrypt private key. Requires replacement if changed.`,
									},
									"priv_key_path": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
									},
									"reject_unauthorized": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											boolplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										MarkdownDescription: `Reject certs that are not authorized by a CA in the CA certificate path, or by another ` + "\n" +
											`                    trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.` + "\n" +
											`Default: true; Requires replacement if changed.`,
									},
									"servername": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address. Requires replacement if changed.`,
									},
								},
								Description: `Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"max_back_off": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds). Default: 30000; Requires replacement if changed.`,
					},
					"max_record_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(768)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size of each record batch before compression. The value must not exceed the Kafka brokers' message.max.bytes setting. Default: 768; Requires replacement if changed.`,
					},
					"max_retries": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data. Default: 5; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"protobuf_library_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select a set of Protobuf definitions for the events you want to send. Requires replacement if changed.`,
					},
					"reauthentication_threshold": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backwards from the moment when credentials are set to expire. Default: 10000; Requires replacement if changed.`,
					},
					"region": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Region where the MSK cluster is located. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true; Requires replacement if changed.`,
					},
					"request_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(60000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time to wait for Kafka to respond to a request. Default: 60000; Requires replacement if changed.`,
					},
					"reuse_connections": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Reuse connections between requests, which can improve performance. Default: true; Requires replacement if changed.`,
					},
					"signature_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`v4`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Signature version to use for signing MSK cluster requests. Default: "v4"; must be one of ["v2", "v4"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("v2", "v4"),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"tls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"cert_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"certificate_name": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The name of the predefined certificate. Requires replacement if changed.`,
							},
							"disabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Default: false; Requires replacement if changed.`,
							},
							"max_version": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Minimum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Passphrase to use to decrypt private key. Requires replacement if changed.`,
							},
							"priv_key_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"reject_unauthorized": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								MarkdownDescription: `Reject certs that are not authorized by a CA in the CA certificate path, or by another ` + "\n" +
									`                    trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.` + "\n" +
									`Default: true; Requires replacement if changed.`,
							},
							"servername": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address. Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"topic": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The topic to publish events to. Can be overridden using the __topicOut field. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "msk"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("msk"),
						},
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_netflow": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"dns_resolve_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How often to resolve the destination hostname to an IP address. Ignored if all destinations are IP addresses. A value of 0 means every datagram sent will incur a DNS lookup. Default: 0; Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"hosts": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"host": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Destination host. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
								"port": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2055)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Destination port, default is 2055. Default: 2055; Requires replacement if changed.`,
								},
							},
						},
						Description: `One or more NetFlow destinations to forward events to. Not Null; Requires replacement if changed.`,
						Validators: []validator.List{
							speakeasy_listvalidators.NotNull(),
							listvalidator.SizeAtLeast(1),
						},
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "netflow"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf("netflow"),
						},
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_newrelic": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"api_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `New Relic API key. Can be overridden using __newRelic_apiKey field. Requires replacement if changed.`,
					},
					"auth_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`manual`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Enter API key directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"manual",
								"secret",
							),
						},
					},
					"compress": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Compress the payload body before sending. Default: true; Requires replacement if changed.`,
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"custom_url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
						},
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"log_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the logtype to send with events, e.g.: observability, access_log. The event's 'sourcetype' field (if set) will override this value. Default: ""; Requires replacement if changed.`,
					},
					"max_payload_events": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1024)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size, in KB, of the request body. Default: 1024; Requires replacement if changed.`,
					},
					"message_field": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of field to send as log message value. If not present, event will be serialized and sent as JSON. Default: ""; Requires replacement if changed.`,
					},
					"metadata": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Not Null; must be one of ["service", "hostname", "timestamp", "auditId"]; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
										stringvalidator.OneOf(
											"service",
											"hostname",
											"timestamp",
											"auditId",
										),
									},
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.). Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Fields to add to events from this input. Requires replacement if changed.`,
						Validators: []validator.List{
							listvalidator.SizeAtMost(4),
						},
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"region": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`US`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Which New Relic region endpoint to use. Default: "US"; must be one of ["US", "EU", "Custom"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"US",
								"EU",
								"Custom",
							),
						},
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"text_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"total_memory_limit_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "newrelic"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf("newrelic"),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_newrelic_events": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"account_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `New Relic account ID. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"api_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `New Relic API key. Can be overridden using __newRelic_apiKey field. Requires replacement if changed.`,
					},
					"auth_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`manual`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Enter API key directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"manual",
								"secret",
							),
						},
					},
					"compress": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Compress the payload body before sending. Default: true; Requires replacement if changed.`,
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"custom_url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
						},
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"event_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default eventType to use when not present in an event. For more information, see [here](https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/data-requirements-limits-custom-event-data/#reserved-words). Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"max_payload_events": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1024)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size, in KB, of the request body. Default: 1024; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"region": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`US`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Which New Relic region endpoint to use. Default: "US"; must be one of ["US", "EU", "Custom"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"US",
								"EU",
								"Custom",
							),
						},
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"text_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "newrelic_events"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"newrelic_events",
							),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_open_telemetry": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"auth_header_expr": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`` + "`" + `Bearer ${token}` + "`" + ``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to compute the Authorization header value to pass in requests. The value ` + "`" + `${token}` + "`" + ` is used to reference the token obtained from authentication, e.g.: ` + "`" + `Bearer ${token}` + "`" + `. Default: "` + "`" + `Bearer ${token}` + "`" + `"; Requires replacement if changed.`,
					},
					"auth_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `OpenTelemetry authentication type. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"basic",
								"credentialsSecret",
								"token",
								"textSecret",
								"oauth",
							),
						},
					},
					"compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`gzip`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Type of compression to apply to messages sent to the OpenTelemetry endpoint. Default: "gzip"; must be one of ["none", "deflate", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"deflate",
								"gzip",
							),
						},
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"connection_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000; Requires replacement if changed.`,
					},
					"credentials_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a secret that references your credentials. Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"endpoint": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The endpoint where OTel events will be sent. Enter any valid URL or an IP address (IPv4 or IPv6; enclose IPv6 addresses in square brackets). Unspecified ports will default to 4317, unless the endpoint is an HTTPS-based URL or TLS is enabled, in which case 443 will be used. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"http_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`gzip`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Type of compression to apply to messages sent to the OpenTelemetry endpoint. Default: "gzip"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"http_logs_endpoint_override": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `If you want to send logs to the default ` + "`" + `{endpoint}/v1/logs` + "`" + ` endpoint, leave this field empty; otherwise, specify the desired endpoint. Requires replacement if changed.`,
					},
					"http_metrics_endpoint_override": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `If you want to send metrics to the default ` + "`" + `{endpoint}/v1/metrics` + "`" + ` endpoint, leave this field empty; otherwise, specify the desired endpoint. Requires replacement if changed.`,
					},
					"http_traces_endpoint_override": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `If you want to send traces to the default ` + "`" + `{endpoint}/v1/traces` + "`" + ` endpoint, leave this field empty; otherwise, specify the desired endpoint. Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"keep_alive": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Disable to close the connection immediately after sending the outgoing request. Default: true; Requires replacement if changed.`,
					},
					"keep_alive_time": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How often the sender should ping the peer to keep the connection open. Default: 30; Requires replacement if changed.`,
					},
					"login_url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `URL for OAuth. Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
						},
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(4096)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size, in KB, of the request body. Default: 4096; Requires replacement if changed.`,
					},
					"metadata": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed: true,
									Optional: true,
									Default:  stringdefault.StaticString(``),
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Default: ""; Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `List of key-value pairs to send with each gRPC request. Value supports JavaScript expressions that are evaluated just once, when the destination gets started. To pass credentials as metadata, use 'C.Secret'. Requires replacement if changed.`,
					},
					"oauth_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `OAuth header name. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `OAuth header value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request. Requires replacement if changed.`,
					},
					"oauth_params": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `OAuth parameter name. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `OAuth parameter value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request. Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"otlp_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`0.10.0`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The version of OTLP Protobuf definitions to use when structuring data to send. Default: "0.10.0"; must be one of ["0.10.0", "1.3.1"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"0.10.0",
								"1.3.1",
							),
						},
					},
					"password": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Password for Basic authentication. Requires replacement if changed.`,
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"protocol": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`grpc`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select a transport option for OpenTelemetry. Default: "grpc"; must be one of ["grpc", "http"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"grpc",
								"http",
							),
						},
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Secret parameter value to pass in request body. Requires replacement if changed.`,
					},
					"secret_param_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Secret parameter name to pass in request body. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"text_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"tls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"cert_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"certificate_name": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The name of the predefined certificate. Requires replacement if changed.`,
							},
							"disabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Default: true; Requires replacement if changed.`,
							},
							"max_version": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Minimum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Passphrase to use to decrypt private key. Requires replacement if changed.`,
							},
							"priv_key_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"reject_unauthorized": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								MarkdownDescription: `Reject certs that are not authorized by a CA in the CA certificate path, or by another ` + "\n" +
									`                    trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.` + "\n" +
									`Default: true; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"token": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Bearer token to include in the authorization header. Requires replacement if changed.`,
					},
					"token_attribute_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token'). Requires replacement if changed.`,
					},
					"token_timeout_secs": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(3600)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How often the OAuth token should be refreshed. Default: 3600; Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "open_telemetry"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf(
								"open_telemetry",
							),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false; Requires replacement if changed.`,
					},
					"username": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Username for Basic authentication. Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_prometheus": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"auth_header_expr": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`` + "`" + `Bearer ${token}` + "`" + ``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to compute the Authorization header value to pass in requests. The value ` + "`" + `${token}` + "`" + ` is used to reference the token obtained from authentication, e.g.: ` + "`" + `Bearer ${token}` + "`" + `. Default: "` + "`" + `Bearer ${token}` + "`" + `"; Requires replacement if changed.`,
					},
					"auth_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Remote Write authentication type. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"basic",
								"credentialsSecret",
								"token",
								"textSecret",
								"oauth",
							),
						},
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"credentials_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a secret that references your credentials. Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"login_url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `URL for OAuth. Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
						},
					},
					"max_payload_events": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(4096)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size, in KB, of the request body. Default: 4096; Requires replacement if changed.`,
					},
					"metric_rename_expr": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`name.replace(/[^a-zA-Z0-9_]/g, '_')`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `A JS expression that can be used to rename metrics. E.g.: name.replace(/\./g, '_') will replace all '.' characters in a metric's name with the supported '_' character. Use the 'name' global variable to access the metric's name.  You can access event fields' values via __e.<fieldName>. Default: "name.replace(/[^a-zA-Z0-9_]/g, '_')"; Requires replacement if changed.`,
					},
					"metrics_flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(60)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How frequently metrics metadata is sent out. Value cannot be smaller than the base Flush period (sec) set above. Default: 60; Requires replacement if changed.`,
					},
					"oauth_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `OAuth header name. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `OAuth header value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request. Requires replacement if changed.`,
					},
					"oauth_params": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `OAuth parameter name. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `OAuth parameter value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request. Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"password": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Password for Basic authentication. Requires replacement if changed.`,
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Secret parameter value to pass in request body. Requires replacement if changed.`,
					},
					"secret_param_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Secret parameter name to pass in request body. Requires replacement if changed.`,
					},
					"send_metadata": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to generate and send metadata (` + "`" + `type` + "`" + ` and ` + "`" + `metricFamilyName` + "`" + `) requests. Default: true; Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. These fields are added as dimensions to generated metrics. Requires replacement if changed.`,
					},
					"text_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"token": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Bearer token to include in the authorization header. Requires replacement if changed.`,
					},
					"token_attribute_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token'). Requires replacement if changed.`,
					},
					"token_timeout_secs": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(3600)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How often the OAuth token should be refreshed. Default: 3600; Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "prometheus"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf(
								"prometheus",
							),
						},
					},
					"url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The endpoint to send metrics to. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false; Requires replacement if changed.`,
					},
					"username": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Username for Basic authentication. Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_ring": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`gzip`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default: "gzip"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"dest_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Path to use to write metrics. Defaults to $CRIBL_HOME/state/<id>. Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"format": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`json`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Format of the output data. Default: "json"; must be one of ["json", "raw"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"json",
								"raw",
							),
						},
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"max_data_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted. Default: "1GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"max_data_time": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`24h`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted. Default: "24h"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`\d+[smhd]$`), "must match pattern "+regexp.MustCompile(`\d+[smhd]$`).String()),
						},
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"partition_expr": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JS expression to define how files are partitioned and organized. If left blank, Cribl Stream will fallback on event.__partition. Requires replacement if changed.`,
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "ring"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf("ring"),
						},
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_router": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"rules": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"description": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Description of this rule's purpose. Requires replacement if changed.`,
								},
								"filter": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `JavaScript expression to select events to send to output. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
								"final": schema.BoolAttribute{
									Computed: true,
									Optional: true,
									Default:  booldefault.StaticBool(true),
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
									},
									Description: `Flag to control whether to stop the event from being checked against other rules. Default: true; Requires replacement if changed.`,
								},
								"output": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Output to send matching events to. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Event routing rules. Not Null; Requires replacement if changed.`,
						Validators: []validator.List{
							speakeasy_listvalidators.NotNull(),
							listvalidator.SizeAtLeast(1),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "router"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf("router"),
						},
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_s3": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"add_id_to_stage_path": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Append output's ID to staging location. Default: true; Requires replacement if changed.`,
					},
					"assume_role_arn": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Amazon Resource Name (ARN) of the role to assume. Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.UTF8LengthAtLeast(20),
							stringvalidator.RegexMatches(regexp.MustCompile(`^arn:`), "must match pattern "+regexp.MustCompile(`^arn:`).String()),
						},
					},
					"assume_role_external_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `External ID to use when assuming role. Requires replacement if changed.`,
					},
					"automatic_schema": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Automatically calculate the schema based on the events of each Parquet file generated. Default: false; Requires replacement if changed.`,
					},
					"aws_api_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Access key. This value can be a constant or a JavaScript expression(e.g., ` + "`" + `${C.env.SOME_ACCESS_KEY}` + "`" + `). Requires replacement if changed.`,
					},
					"aws_authentication_method": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`auto`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"auto",
								"manual",
								"secret",
							),
						},
					},
					"aws_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored secret that references your access key and secret key. Requires replacement if changed.`,
					},
					"aws_secret_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Secret key. This value can be a constant or a JavaScript expression(e.g., ` + "`" + `${C.env.SOME_SECRET}` + "`" + `). Requires replacement if changed.`,
					},
					"base_file_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`` + "`" + `CriblOut` + "`" + ``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to define the output filename prefix (can be constant). Default: "` + "`" + `CriblOut` + "`" + `"; Requires replacement if changed.`,
					},
					"bucket": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the destination S3 bucket. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: ` + "`" + `myBucket-${C.vars.myVar}` + "`" + `. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`gzip`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Choose data compression format to apply before moving files to final destination. Default: "gzip"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"compression_level": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`best_speed`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Compression level to apply before moving files to final destination. Default: "best_speed"; must be one of ["best_speed", "normal", "best_compression"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"best_speed",
								"normal",
								"best_compression",
							),
						},
					},
					"deadletter_enabled": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors. Default: false; Requires replacement if changed.`,
					},
					"deadletter_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/outputs/dead-letter`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Storage location for files that fail to reach their final destination after maximum retries are exceeded. Default: "$CRIBL_HOME/state/outputs/dead-letter"; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"dest_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Prefix to append to files before uploading. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: ` + "`" + `myKeyPrefix-${C.vars.myVar}` + "`" + `. Default: ""; Requires replacement if changed.`,
					},
					"duration_seconds": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(3600)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600; Requires replacement if changed.`,
					},
					"empty_dir_cleanup_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How frequently, in seconds, to clean up empty directories when 'Remove empty staging dirs' is enabled. Default: 300; Requires replacement if changed.`,
					},
					"enable_assume_role": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Use Assume Role credentials to access S3. Default: false; Requires replacement if changed.`,
					},
					"enable_page_checksum": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Parquet tools can use the checksum of a Parquet page to verify data integrity. Default: false; Requires replacement if changed.`,
					},
					"enable_statistics": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics. Default: true; Requires replacement if changed.`,
					},
					"enable_write_page_index": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping. Default: true; Requires replacement if changed.`,
					},
					"endpoint": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `S3 service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint. Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"file_name_suffix": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`` + "`" + `.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}` + "`" + ``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to define the output filename suffix (can be constant).  The ` + "`" + `__format` + "`" + ` variable refers to the value of the ` + "`" + `Data format` + "`" + ` field (` + "`" + `json` + "`" + ` or ` + "`" + `raw` + "`" + `).  The ` + "`" + `__compression` + "`" + ` field refers to the kind of compression being used (` + "`" + `none` + "`" + ` or ` + "`" + `gzip` + "`" + `). Default: "` + "`" + `.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}` + "`" + `"; Requires replacement if changed.`,
					},
					"format": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`json`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Format of the output data. Default: "json"; must be one of ["json", "raw", "parquet"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"json",
								"raw",
								"parquet",
							),
						},
					},
					"header_line": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `If set, this line will be written to the beginning of each output file. Default: ""; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"key_value_metadata": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed: true,
									Optional: true,
									Default:  stringdefault.StaticString(``),
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Default: ""; Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging, e.g., "key":"OCSF Event Class", "value":"9001". Requires replacement if changed.`,
					},
					"kms_key_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `ID or ARN of the KMS customer-managed key to use for encryption. Requires replacement if changed.`,
					},
					"max_closing_files_to_backpressure": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(100)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of files that can be waiting for upload before backpressure is applied. Default: 100; Requires replacement if changed.`,
					},
					"max_concurrent_file_parts": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(4)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of parts to upload in parallel per file. Minimum part size is 5MB. Default: 4; Requires replacement if changed.`,
					},
					"max_file_idle_time_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30; Requires replacement if changed.`,
					},
					"max_file_open_time_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300; Requires replacement if changed.`,
					},
					"max_file_size_mb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(32)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 32; Requires replacement if changed.`,
					},
					"max_open_files": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(100)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100; Requires replacement if changed.`,
					},
					"max_retry_num": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(20)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum number of times a file will attempt to move to its final destination before being dead-lettered. Default: 20; Requires replacement if changed.`,
					},
					"object_acl": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`private`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Object ACL to assign to uploaded objects. Default: "private"; must be one of ["private", "public-read", "public-read-write", "authenticated-read", "aws-exec-read", "bucket-owner-read", "bucket-owner-full-control"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"private",
								"public-read",
								"public-read-write",
								"authenticated-read",
								"aws-exec-read",
								"bucket-owner-read",
								"bucket-owner-full-control",
							),
						},
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"on_disk_full_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"parquet_data_page_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`DATA_PAGE_V2`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it. Default: "DATA_PAGE_V2"; must be one of ["DATA_PAGE_V1", "DATA_PAGE_V2"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"DATA_PAGE_V1",
								"DATA_PAGE_V2",
							),
						},
					},
					"parquet_page_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression. Default: "1MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:[kK][bB]|[mM][bB]|[gG][bB]|[tT][bB])?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:[kK][bB]|[mM][bB]|[gG][bB]|[tT][bB])?$`).String()),
						},
					},
					"parquet_row_group_length": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The number of rows that every group will contain. The final group can contain a smaller number of rows. Default: 10000; Requires replacement if changed.`,
					},
					"parquet_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`PARQUET_2_6`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Determines which data types are supported and how they are represented. Default: "PARQUET_2_6"; must be one of ["PARQUET_1_0", "PARQUET_2_4", "PARQUET_2_6"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"PARQUET_1_0",
								"PARQUET_2_4",
								"PARQUET_2_6",
							),
						},
					},
					"partition_expr": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory. Default: "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"; Requires replacement if changed.`,
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"region": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Region where the S3 bucket is located. Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true; Requires replacement if changed.`,
					},
					"remove_empty_dirs": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Remove empty staging directories after moving files. Default: true; Requires replacement if changed.`,
					},
					"reuse_connections": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Reuse connections between requests, which can improve performance. Default: true; Requires replacement if changed.`,
					},
					"server_side_encryption": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Server-side encryption for uploaded objects. must be one of ["AES256", "aws:kms"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"AES256",
								"aws:kms",
							),
						},
					},
					"should_log_invalid_rows": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Log up to 3 rows that @{product} skips due to data mismatch. Requires replacement if changed.`,
					},
					"signature_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`v4`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Signature version to use for signing S3 requests. Default: "v4"; must be one of ["v2", "v4"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("v2", "v4"),
						},
					},
					"stage_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/outputs/staging`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage. Default: "$CRIBL_HOME/state/outputs/staging"; Requires replacement if changed.`,
					},
					"storage_class": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Storage class to select for uploaded objects. must be one of ["STANDARD", "REDUCED_REDUNDANCY", "STANDARD_IA", "ONEZONE_IA", "INTELLIGENT_TIERING", "GLACIER", "GLACIER_IR", "DEEP_ARCHIVE"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"STANDARD",
								"REDUCED_REDUNDANCY",
								"STANDARD_IA",
								"ONEZONE_IA",
								"INTELLIGENT_TIERING",
								"GLACIER",
								"GLACIER_IR",
								"DEEP_ARCHIVE",
							),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "s3"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("s3"),
						},
					},
					"verify_permissions": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Disable if you can access files within the bucket but not the bucket itself. Default: true; Requires replacement if changed.`,
					},
					"write_high_water_mark": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(64)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Buffer size used to write to a file. Default: 64; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_security_lake": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"account_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `ID of the AWS account whose data the Destination will write to Security Lake. This should have been configured when creating the Amazon Security Lake custom source. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"add_id_to_stage_path": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Append output's ID to staging location. Default: true; Requires replacement if changed.`,
					},
					"assume_role_arn": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Amazon Resource Name (ARN) of the role to assume. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.UTF8LengthAtLeast(20),
							stringvalidator.RegexMatches(regexp.MustCompile(`^arn:`), "must match pattern "+regexp.MustCompile(`^arn:`).String()),
						},
					},
					"assume_role_external_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `External ID to use when assuming role. Requires replacement if changed.`,
					},
					"automatic_schema": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Automatically calculate the schema based on the events of each Parquet file generated. Default: false; Requires replacement if changed.`,
					},
					"aws_api_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Access key. This value can be a constant or a JavaScript expression(e.g., ` + "`" + `${C.env.SOME_ACCESS_KEY}` + "`" + `). Requires replacement if changed.`,
					},
					"aws_authentication_method": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`auto`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"auto",
								"manual",
								"secret",
							),
						},
					},
					"aws_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored secret that references your access key and secret key. Requires replacement if changed.`,
					},
					"aws_secret_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Secret key. Requires replacement if changed.`,
					},
					"base_file_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`` + "`" + `CriblOut` + "`" + ``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to define the output filename prefix (can be constant). Default: "` + "`" + `CriblOut` + "`" + `"; Requires replacement if changed.`,
					},
					"bucket": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the destination S3 bucket. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: ` + "`" + `myBucket-${C.vars.myVar}` + "`" + `. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"custom_source": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the custom source configured in Amazon Security Lake. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"deadletter_enabled": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors. Default: false; Requires replacement if changed.`,
					},
					"deadletter_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/outputs/dead-letter`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Storage location for files that fail to reach their final destination after maximum retries are exceeded. Default: "$CRIBL_HOME/state/outputs/dead-letter"; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"duration_seconds": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(3600)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600; Requires replacement if changed.`,
					},
					"empty_dir_cleanup_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How frequently, in seconds, to clean up empty directories when 'Remove empty staging dirs' is enabled. Default: 300; Requires replacement if changed.`,
					},
					"enable_assume_role": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Use Assume Role credentials to access S3. Default: false; Requires replacement if changed.`,
					},
					"enable_page_checksum": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Parquet tools can use the checksum of a Parquet page to verify data integrity. Default: false; Requires replacement if changed.`,
					},
					"enable_statistics": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics. Default: true; Requires replacement if changed.`,
					},
					"enable_write_page_index": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping. Default: true; Requires replacement if changed.`,
					},
					"endpoint": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Amazon Security Lake service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to Amazon Security Lake-compatible endpoint. Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"header_line": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `If set, this line will be written to the beginning of each output file. Default: ""; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"key_value_metadata": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed: true,
									Optional: true,
									Default:  stringdefault.StaticString(``),
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Default: ""; Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging, e.g., "key":"OCSF Event Class", "value":"9001". Requires replacement if changed.`,
					},
					"kms_key_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `ID or ARN of the KMS customer-managed key to use for encryption. Requires replacement if changed.`,
					},
					"max_closing_files_to_backpressure": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(100)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of files that can be waiting for upload before backpressure is applied. Default: 100; Requires replacement if changed.`,
					},
					"max_concurrent_file_parts": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(4)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of parts to upload in parallel per file. Minimum part size is 5MB. Default: 4; Requires replacement if changed.`,
					},
					"max_file_idle_time_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30; Requires replacement if changed.`,
					},
					"max_file_open_time_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300; Requires replacement if changed.`,
					},
					"max_file_size_mb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(32)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 32; Requires replacement if changed.`,
					},
					"max_open_files": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(100)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100; Requires replacement if changed.`,
					},
					"max_retry_num": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(20)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum number of times a file will attempt to move to its final destination before being dead-lettered. Default: 20; Requires replacement if changed.`,
					},
					"object_acl": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`private`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Object ACL to assign to uploaded objects. Default: "private"; must be one of ["private", "public-read", "public-read-write", "authenticated-read", "aws-exec-read", "bucket-owner-read", "bucket-owner-full-control"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"private",
								"public-read",
								"public-read-write",
								"authenticated-read",
								"aws-exec-read",
								"bucket-owner-read",
								"bucket-owner-full-control",
							),
						},
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"on_disk_full_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"parquet_data_page_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`DATA_PAGE_V2`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it. Default: "DATA_PAGE_V2"; must be one of ["DATA_PAGE_V1", "DATA_PAGE_V2"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"DATA_PAGE_V1",
								"DATA_PAGE_V2",
							),
						},
					},
					"parquet_page_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression. Default: "1MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:[kK][bB]|[mM][bB]|[gG][bB]|[tT][bB])?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:[kK][bB]|[mM][bB]|[gG][bB]|[tT][bB])?$`).String()),
						},
					},
					"parquet_row_group_length": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The number of rows that every group will contain. The final group can contain a smaller number of rows. Default: 10000; Requires replacement if changed.`,
					},
					"parquet_schema": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `To add a new schema, navigate to Processing > Knowledge > Parquet Schemas. Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.UTF8LengthAtLeast(1),
						},
					},
					"parquet_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`PARQUET_2_6`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Determines which data types are supported and how they are represented. Default: "PARQUET_2_6"; must be one of ["PARQUET_1_0", "PARQUET_2_4", "PARQUET_2_6"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"PARQUET_1_0",
								"PARQUET_2_4",
								"PARQUET_2_6",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"region": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Region where the Amazon Security Lake is located. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true; Requires replacement if changed.`,
					},
					"remove_empty_dirs": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Remove empty staging directories after moving files. Default: true; Requires replacement if changed.`,
					},
					"reuse_connections": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Reuse connections between requests, which can improve performance. Default: true; Requires replacement if changed.`,
					},
					"server_side_encryption": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Server-side encryption for uploaded objects. must be one of ["AES256", "aws:kms"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"AES256",
								"aws:kms",
							),
						},
					},
					"should_log_invalid_rows": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Log up to 3 rows that @{product} skips due to data mismatch. Requires replacement if changed.`,
					},
					"signature_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`v4`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Signature version to use for signing Amazon Security Lake requests. Default: "v4"; must be one of ["v2", "v4"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("v2", "v4"),
						},
					},
					"stage_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/outputs/staging`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage. Default: "$CRIBL_HOME/state/outputs/staging"; Requires replacement if changed.`,
					},
					"storage_class": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Storage class to select for uploaded objects. must be one of ["STANDARD", "REDUCED_REDUNDANCY", "STANDARD_IA", "ONEZONE_IA", "INTELLIGENT_TIERING", "GLACIER", "GLACIER_IR", "DEEP_ARCHIVE"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"STANDARD",
								"REDUCED_REDUNDANCY",
								"STANDARD_IA",
								"ONEZONE_IA",
								"INTELLIGENT_TIERING",
								"GLACIER",
								"GLACIER_IR",
								"DEEP_ARCHIVE",
							),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. These fields are added as dimensions and labels to generated metrics and logs, respectively. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "security_lake"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"security_lake",
							),
						},
					},
					"verify_permissions": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Disable if you can access files within the bucket but not the bucket itself. Default: true; Requires replacement if changed.`,
					},
					"write_high_water_mark": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(64)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Buffer size used to write to a file. Default: 64; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_sentinel": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"advanced_content_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`application/json`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `HTTP content-type header value. Default: "application/json"; Requires replacement if changed.`,
					},
					"auth_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "oauth"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("oauth"),
						},
					},
					"client_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to compute the Client ID for the Azure application. Can be a constant. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"compress": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Compress the payload body before sending. Default: true; Requires replacement if changed.`,
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"custom_content_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`application/x-ndjson`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Content type to use for request. Defaults to application/x-ndjson. Any content types set in Advanced Settings > Extra HTTP headers will override this entry. Default: "application/x-ndjson"; Requires replacement if changed.`,
					},
					"custom_drop_when_null": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to drop events when the source expression evaluates to null. Default: false; Requires replacement if changed.`,
					},
					"custom_event_delimiter": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`\n`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Delimiter string to insert between individual events. Defaults to newline character. Default: "\\n"; Requires replacement if changed.`,
					},
					"custom_payload_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`` + "`" + `${events}` + "`" + ``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Expression specifying how to format the payload for each batch. To reference the events to send, use the ` + "`" + `${events}` + "`" + ` variable. Example expression: ` + "`" + `{ "items" : [${events}] }` + "`" + ` would send the batch inside a JSON object. Default: "` + "`" + `${events}` + "`" + `"; Requires replacement if changed.`,
					},
					"custom_source_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`__httpOut`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Expression to evaluate on events to generate output. Example: ` + "`" + `raw=${_raw}` + "`" + `. See [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook#custom-format) for other examples. If empty, the full event is sent as stringified JSON. Default: "__httpOut"; Requires replacement if changed.`,
					},
					"dce_endpoint": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data collection endpoint (DCE) URL. In the format: ` + "`" + `https://<Endpoint-Name>-<Identifier>.<Region>.ingest.monitor.azure.com` + "`" + `. Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^https:\/\/\w+(-\w+)*-\w+\.\w+(-\w)?\.ingest\.monitor\.azure\.com(\/?)$`), "must match pattern "+regexp.MustCompile(`^https:\/\/\w+(-\w+)*-\w+\.\w+(-\w)?\.ingest\.monitor\.azure\.com(\/?)$`).String()),
						},
					},
					"dcr_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Immutable ID for the Data collection rule (DCR). Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"endpoint_url_configuration": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`url`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default: "url"; must be one of ["url", "ID"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"url",
								"ID",
							),
						},
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained [here](https://docs.cribl.io/stream/destinations-webhook/#internal-fields). Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"format": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be one of ["ndjson", "json_array", "custom", "advanced"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"ndjson",
								"json_array",
								"custom",
								"advanced",
							),
						},
					},
					"format_event_code": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Custom JavaScript code to format incoming event data accessible through the __e variable. The formatted content is added to (__e['__eventOut']) if available. Otherwise, the original event is serialized as JSON. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code. Requires replacement if changed.`,
					},
					"format_payload_code": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optional JavaScript code to format the payload sent to the Destination. The payload, containing a batch of formatted events, is accessible through the __e['payload'] variable. The formatted payload is returned in the __e['__payloadOut'] variable. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code. Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"keep_alive": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Disable to close the connection immediately after sending the outgoing request. Default: true; Requires replacement if changed.`,
					},
					"login_url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `URL for OAuth. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
						},
					},
					"max_payload_events": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size (KB) of the request body (defaults to the API's maximum limit of 1000 KB). Default: 1000; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"scope": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`https://monitor.azure.com/.default`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Scope to pass in the OAuth request. Default: "https://monitor.azure.com/.default"; Requires replacement if changed.`,
					},
					"secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Secret parameter value to pass in request body. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"stream_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The name of the stream (Sentinel table) in which to store the events. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"total_memory_limit_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "sentinel"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("sentinel"),
						},
					},
					"url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `URL to send events to. Can be overwritten by an event's __url field. Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_service_now": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"auth_token_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`lightstep-access-token`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default: "lightstep-access-token"; Requires replacement if changed.`,
					},
					"compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`gzip`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Type of compression to apply to messages sent to the OpenTelemetry endpoint. Default: "gzip"; must be one of ["none", "deflate", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"deflate",
								"gzip",
							),
						},
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"connection_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"endpoint": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`ingest.lightstep.com:443`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The endpoint where ServiceNow events will be sent. Enter any valid URL or an IP address (IPv4 or IPv6; enclose IPv6 addresses in square brackets). Default: "ingest.lightstep.com:443"; Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"http_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`gzip`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Type of compression to apply to messages sent to the OpenTelemetry endpoint. Default: "gzip"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"http_logs_endpoint_override": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `If you want to send logs to the default ` + "`" + `{endpoint}/v1/logs` + "`" + ` endpoint, leave this field empty; otherwise, specify the desired endpoint. Requires replacement if changed.`,
					},
					"http_metrics_endpoint_override": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `If you want to send metrics to the default ` + "`" + `{endpoint}/v1/metrics` + "`" + ` endpoint, leave this field empty; otherwise, specify the desired endpoint. Requires replacement if changed.`,
					},
					"http_traces_endpoint_override": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `If you want to send traces to the default ` + "`" + `{endpoint}/v1/traces` + "`" + ` endpoint, leave this field empty; otherwise, specify the desired endpoint. Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"keep_alive": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Disable to close the connection immediately after sending the outgoing request. Default: true; Requires replacement if changed.`,
					},
					"keep_alive_time": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How often the sender should ping the peer to keep the connection open. Default: 30; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(2048)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size, in KB, of the request body. Default: 2048; Requires replacement if changed.`,
					},
					"metadata": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed: true,
									Optional: true,
									Default:  stringdefault.StaticString(``),
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Default: ""; Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `List of key-value pairs to send with each gRPC request. Value supports JavaScript expressions that are evaluated just once, when the destination gets started. To pass credentials as metadata, use 'C.Secret'. Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"otlp_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1.3.1`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The version of OTLP Protobuf definitions to use when structuring data to send. Default: "1.3.1"; must be "1.3.1"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("1.3.1"),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"protocol": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`grpc`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select a transport option for OpenTelemetry. Default: "grpc"; must be one of ["grpc", "http"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"grpc",
								"http",
							),
						},
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"tls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"cert_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"certificate_name": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The name of the predefined certificate. Requires replacement if changed.`,
							},
							"disabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Default: true; Requires replacement if changed.`,
							},
							"max_version": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Minimum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Passphrase to use to decrypt private key. Requires replacement if changed.`,
							},
							"priv_key_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"reject_unauthorized": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								MarkdownDescription: `Reject certs that are not authorized by a CA in the CA certificate path, or by another ` + "\n" +
									`                    trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.` + "\n" +
									`Default: true; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"token_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "service_now"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"service_now",
							),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_signalfx": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"auth_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`manual`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"manual",
								"secret",
							),
						},
					},
					"compress": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Compress the payload body before sending. Default: true; Requires replacement if changed.`,
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"max_payload_events": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(4096)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size, in KB, of the request body. Default: 4096; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"realm": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`us0`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `SignalFx realm name, e.g. "us0". For a complete list of available SignalFx realm names, please check [here](https://docs.splunk.com/observability/en/get-started/service-description.html#sd-regions). Default: "us0"; Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"text_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"token": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `SignalFx API access token (see [here](https://docs.signalfx.com/en/latest/admin-guide/tokens.html#working-with-access-tokens)). Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "signalfx"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf("signalfx"),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_snmp": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"dns_resolve_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How often to resolve the destination hostname to an IP address. Ignored if all destinations are IP addresses. A value of 0 means every trap sent will incur a DNS lookup. Default: 0; Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"hosts": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"host": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Destination host. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
								"port": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(162)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Destination port, default is 162. Default: 162; Requires replacement if changed.`,
								},
							},
						},
						Description: `One or more SNMP destinations to forward traps to. Not Null; Requires replacement if changed.`,
						Validators: []validator.List{
							speakeasy_listvalidators.NotNull(),
							listvalidator.SizeAtLeast(1),
						},
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "snmp"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf("snmp"),
						},
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_sns": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"assume_role_arn": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Amazon Resource Name (ARN) of the role to assume. Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.UTF8LengthAtLeast(20),
							stringvalidator.RegexMatches(regexp.MustCompile(`^arn:`), "must match pattern "+regexp.MustCompile(`^arn:`).String()),
						},
					},
					"assume_role_external_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `External ID to use when assuming role. Requires replacement if changed.`,
					},
					"aws_api_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Access key. Requires replacement if changed.`,
					},
					"aws_authentication_method": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`auto`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"auto",
								"manual",
								"secret",
							),
						},
					},
					"aws_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored secret that references your access key and secret key. Requires replacement if changed.`,
					},
					"aws_secret_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Secret key. Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"duration_seconds": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(3600)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600; Requires replacement if changed.`,
					},
					"enable_assume_role": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Use Assume Role credentials to access SNS. Default: false; Requires replacement if changed.`,
					},
					"endpoint": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `SNS service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to SNS-compatible endpoint. Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"max_retries": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of retries before the output returns an error. Note that not all errors are retryable. The retries use an exponential backoff policy. Requires replacement if changed.`,
					},
					"message_group_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Messages in the same group are processed in a FIFO manner. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: ` + "`" + `https://host:port/myQueue-${C.vars.myVar}` + "`" + `. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"region": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Region where the SNS is located. Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true; Requires replacement if changed.`,
					},
					"reuse_connections": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Reuse connections between requests, which can improve performance. Default: true; Requires replacement if changed.`,
					},
					"signature_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`v4`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Signature version to use for signing SNS requests. Default: "v4"; must be one of ["v2", "v4"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("v2", "v4"),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"topic_arn": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The ARN of the SNS topic to send events to. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. E.g., 'https://host:port/myQueueName'. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: ` + "`" + `https://host:port/myQueue-${C.vars.myVar}` + "`" + `. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "sns"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("sns"),
						},
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_splunk": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"auth_token": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Shared secret token to use when establishing a connection to a Splunk indexer. Default: ""; Requires replacement if changed.`,
					},
					"auth_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`manual`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"manual",
								"secret",
							),
						},
					},
					"connection_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"enable_ack": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Check if indexer is shutting down and stop sending data. This helps minimize data loss during shutdown. Default: true; Requires replacement if changed.`,
					},
					"enable_multi_metrics": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Output metrics in multiple-metric format in a single event. Supported in Splunk 8.0 and above. Default: false; Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"host": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The hostname of the receiver. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"log_failed_requests": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Use to troubleshoot issues with sending data. Default: false; Requires replacement if changed.`,
					},
					"max_failed_health_checks": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of times healthcheck can fail before we close connection. If set to 0 (disabled), and the connection to Splunk is forcibly closed, some data loss might occur. Default: 1; Requires replacement if changed.`,
					},
					"max_s2_sversion": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`v3`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The highest S2S protocol version to advertise during handshake. Default: "v3"; must be one of ["v3", "v4"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("v3", "v4"),
						},
					},
					"nested_fields": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `How to serialize nested fields into index-time fields. Default: "none"; must be one of ["json", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"json",
								"none",
							),
						},
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"port": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(9997)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The port to connect to on the provided host. Default: 9997; Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"text_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"throttle_rate_per_sec": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`0`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`), "must match pattern "+regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`).String()),
						},
					},
					"tls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"cert_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"certificate_name": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The name of the predefined certificate. Requires replacement if changed.`,
							},
							"disabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Default: true; Requires replacement if changed.`,
							},
							"max_version": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Minimum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Passphrase to use to decrypt private key. Requires replacement if changed.`,
							},
							"priv_key_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"reject_unauthorized": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								MarkdownDescription: `Reject certs that are not authorized by a CA in the CA certificate path, or by another ` + "\n" +
									`                    trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.` + "\n" +
									`Default: true; Requires replacement if changed.`,
							},
							"servername": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address. Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "splunk"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("splunk"),
						},
					},
					"write_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(60000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead. Default: 60000; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_splunk_hec": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"auth_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`manual`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"manual",
								"secret",
							),
						},
					},
					"compress": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Compress the payload body before sending. Default: true; Requires replacement if changed.`,
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"dns_resolve_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(600)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Re-resolve any hostnames every this many seconds and pick up destinations from A records. Default: 600; Requires replacement if changed.`,
					},
					"enable_multi_metrics": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Output metrics in multiple-metric format, supported in Splunk 8.0 and above to allow multiple metrics in a single event. Default: false; Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"exclude_self": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Exclude all IPs of the current host from the list of any resolved hostnames. Default: false; Requires replacement if changed.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"load_balance_stats_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How far back in time to keep traffic stats for load balancing purposes. Default: 300; Requires replacement if changed.`,
					},
					"load_balanced": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS. Default: true; Requires replacement if changed.`,
					},
					"max_payload_events": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(4096)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size, in KB, of the request body. Default: 4096; Requires replacement if changed.`,
					},
					"next_queue": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`indexQueue`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In the Splunk app, define which Splunk processing queue to send the events after HEC processing. Default: "indexQueue"; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"tcp_routing": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`nowhere`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In the Splunk app, set the value of _TCP_ROUTING for events that do not have _ctrl._TCP_ROUTING set. Default: "nowhere"; Requires replacement if changed.`,
					},
					"text_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"token": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Splunk HEC authentication token. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "splunk_hec"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf(
								"splunk_hec",
							),
						},
					},
					"url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`http://localhost:8088/services/collector/event`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `URL to a Splunk HEC endpoint to send events to, e.g., http://localhost:8088/services/collector/event. Default: "http://localhost:8088/services/collector/event"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
						},
					},
					"urls": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"url": schema.StringAttribute{
									Computed: true,
									Optional: true,
									Default:  stringdefault.StaticString(`http://localhost:8088/services/collector/event`),
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `URL to a Splunk HEC endpoint to send events to, e.g., http://localhost:8088/services/collector/event. Default: "http://localhost:8088/services/collector/event"; Requires replacement if changed.`,
									Validators: []validator.String{
										stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
									},
								},
								"weight": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Assign a weight (>0) to each endpoint to indicate its traffic-handling capability. Default: 1; Requires replacement if changed.`,
								},
							},
						},
						Description: `Requires replacement if changed.`,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_splunk_lb": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"auth_token": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Shared secret token to use when establishing a connection to a Splunk indexer. Default: ""; Requires replacement if changed.`,
					},
					"auth_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`manual`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"manual",
								"secret",
							),
						},
					},
					"connection_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"dns_resolve_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(600)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Re-resolve any hostnames every this many seconds and pick up destinations from A records. Default: 600; Requires replacement if changed.`,
					},
					"enable_ack": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Check if indexer is shutting down and stop sending data. This helps minimize data loss during shutdown. Default: true; Requires replacement if changed.`,
					},
					"enable_multi_metrics": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Output metrics in multiple-metric format in a single event. Supported in Splunk 8.0 and above. Default: false; Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"exclude_self": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Exclude all IPs of the current host from the list of any resolved hostnames. Default: false; Requires replacement if changed.`,
					},
					"hosts": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"host": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `The hostname of the receiver. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
								"port": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(9997)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The port to connect to on the provided host. Default: 9997; Requires replacement if changed.`,
								},
								"servername": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Servername to use if establishing a TLS connection. If not specified, defaults to connection host (iff not an IP); otherwise, to the global TLS settings. Requires replacement if changed.`,
								},
								"tls": schema.StringAttribute{
									Computed: true,
									Optional: true,
									Default:  stringdefault.StaticString(`inherit`),
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Whether to inherit TLS configs from group setting or disable TLS. Default: "inherit"; must be one of ["inherit", "off"]; Requires replacement if changed.`,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"inherit",
											"off",
										),
									},
								},
								"weight": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Assign a weight (>0) to each endpoint to indicate its traffic-handling capability. Default: 1; Requires replacement if changed.`,
								},
							},
						},
						Description: `Set of Splunk indexers to load-balance data to. Not Null; Requires replacement if changed.`,
						Validators: []validator.List{
							speakeasy_listvalidators.NotNull(),
							listvalidator.SizeAtLeast(1),
						},
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"indexer_discovery": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Automatically discover indexers in indexer clustering environment. Default: false; Requires replacement if changed.`,
					},
					"indexer_discovery_configs": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"auth_token": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(``),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted. Default: ""; Requires replacement if changed.`,
							},
							"auth_tokens": schema.ListNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								NestedObject: schema.NestedAttributeObject{
									Validators: []validator.Object{
										speakeasy_objectvalidators.NotNull(),
									},
									PlanModifiers: []planmodifier.Object{
										objectplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"auth_type": schema.StringAttribute{
											Computed: true,
											Optional: true,
											Default:  stringdefault.StaticString(`manual`),
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]; Requires replacement if changed.`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"manual",
													"secret",
												),
											},
										},
									},
								},
								Description: `Tokens required to authenticate to cluster manager for indexer discovery. Requires replacement if changed.`,
							},
							"auth_type": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`manual`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"manual",
										"secret",
									),
								},
							},
							"master_uri": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Full URI of Splunk cluster manager (scheme://host:port). Example: https://managerAddress:8089. Not Null; Requires replacement if changed.`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.RegexMatches(regexp.MustCompile(`^https?://[a-zA-Z0-9-._]+:[0-9]+$`), "must match pattern "+regexp.MustCompile(`^https?://[a-zA-Z0-9-._]+:[0-9]+$`).String()),
								},
							},
							"refresh_interval_sec": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Time interval, in seconds, between two consecutive indexer list fetches from cluster manager. Default: 300; Requires replacement if changed.`,
							},
							"reject_unauthorized": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `During indexer discovery, reject cluster manager certificates that are not authorized by the system's CA. Disable to allow untrusted (for example, self-signed) certificates. Default: false; Requires replacement if changed.`,
							},
							"site": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`default`),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Clustering site of the indexers from where indexers need to be discovered. In case of single site cluster, it defaults to 'default' site. Default: "default"; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`[0-9A-Za-z-._]+`), "must match pattern "+regexp.MustCompile(`[0-9A-Za-z-._]+`).String()),
								},
							},
							"text_secret": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Select or create a stored text secret. Requires replacement if changed.`,
							},
						},
						Description: `List of configurations to set up indexer discovery in Splunk Indexer clustering environment. Requires replacement if changed.`,
					},
					"load_balance_stats_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How far back in time to keep traffic stats for load balancing purposes. Default: 300; Requires replacement if changed.`,
					},
					"log_failed_requests": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Use to troubleshoot issues with sending data. Default: false; Requires replacement if changed.`,
					},
					"max_concurrent_senders": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of concurrent connections (per worker process). A random set of IPs will be picked on every DNS resolution period. Use 0 for unlimited. Default: 0; Requires replacement if changed.`,
					},
					"max_failed_health_checks": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of times healthcheck can fail before we close connection. If set to 0 (disabled), and the connection to Splunk is forcibly closed, some data loss might occur. Default: 1; Requires replacement if changed.`,
					},
					"max_s2_sversion": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`v3`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The highest S2S protocol version to advertise during handshake. Default: "v3"; must be one of ["v3", "v4"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("v3", "v4"),
						},
					},
					"nested_fields": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `How to serialize nested fields into index-time fields. Default: "none"; must be one of ["json", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"json",
								"none",
							),
						},
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"sender_unhealthy_time_allowance": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(100)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How long (in milliseconds) each LB endpoint can report blocked before the Destination reports unhealthy, blocking the sender. (Grace period for fluctuations.) Use 0 to disable; max 1 minute. Default: 100; Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"text_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"throttle_rate_per_sec": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`0`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`), "must match pattern "+regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`).String()),
						},
					},
					"tls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"cert_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"certificate_name": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The name of the predefined certificate. Requires replacement if changed.`,
							},
							"disabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Default: true; Requires replacement if changed.`,
							},
							"max_version": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Minimum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Passphrase to use to decrypt private key. Requires replacement if changed.`,
							},
							"priv_key_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"reject_unauthorized": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								MarkdownDescription: `Reject certs that are not authorized by a CA in the CA certificate path, or by another ` + "\n" +
									`                    trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.` + "\n" +
									`Default: true; Requires replacement if changed.`,
							},
							"servername": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address. Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "splunk_lb"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf(
								"splunk_lb",
							),
						},
					},
					"write_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(60000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead. Default: 60000; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_sqs": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"assume_role_arn": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Amazon Resource Name (ARN) of the role to assume. Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.UTF8LengthAtLeast(20),
							stringvalidator.RegexMatches(regexp.MustCompile(`^arn:`), "must match pattern "+regexp.MustCompile(`^arn:`).String()),
						},
					},
					"assume_role_external_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `External ID to use when assuming role. Requires replacement if changed.`,
					},
					"aws_account_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account. Requires replacement if changed.`,
					},
					"aws_api_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Access key. Requires replacement if changed.`,
					},
					"aws_authentication_method": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`auto`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"auto",
								"manual",
								"secret",
							),
						},
					},
					"aws_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored secret that references your access key and secret key. Requires replacement if changed.`,
					},
					"aws_secret_key": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Secret key. Requires replacement if changed.`,
					},
					"create_queue": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Create queue if it does not exist. Default: true; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"duration_seconds": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(3600)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600; Requires replacement if changed.`,
					},
					"enable_assume_role": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Use Assume Role credentials to access SQS. Default: false; Requires replacement if changed.`,
					},
					"endpoint": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `SQS service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to SQS-compatible endpoint. Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size. Default: 1; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"max_in_progress": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum number of in-progress API requests before backpressure is applied. Default: 10; Requires replacement if changed.`,
					},
					"max_queue_size": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(100)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of queued batches before blocking. Default: 100; Requires replacement if changed.`,
					},
					"max_record_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(256)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size (KB) of batches to send. Per the SQS spec, the max allowed value is 256 KB. Default: 256; Requires replacement if changed.`,
					},
					"message_group_id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`cribl`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `This parameter applies only to FIFO queues. The tag that specifies that a message belongs to a specific message group. Messages that belong to the same message group are processed in a FIFO manner. Use event field __messageGroupId to override this value. Default: "cribl"; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"queue_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The name, URL, or ARN of the SQS queue to send events to. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. E.g., 'https://host:port/myQueueName'. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: ` + "`" + `https://host:port/myQueue-${C.vars.myVar}` + "`" + `. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"queue_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`standard`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The queue type used (or created). Defaults to Standard. Default: "standard"; must be one of ["standard", "fifo"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"standard",
								"fifo",
							),
						},
					},
					"region": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `AWS Region where the SQS queue is located. Required, unless the Queue entry is a URL or ARN that includes a Region. Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true; Requires replacement if changed.`,
					},
					"reuse_connections": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Reuse connections between requests, which can improve performance. Default: true; Requires replacement if changed.`,
					},
					"signature_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`v4`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Signature version to use for signing SQS requests. Default: "v4"; must be one of ["v2", "v4"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("v2", "v4"),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "sqs"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("sqs"),
						},
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_statsd": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"connection_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"dns_resolve_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How often to resolve the destination hostname to an IP address. Ignored if the destination is an IP address. A value of 0 means every batch sent will incur a DNS lookup. Default: 0; Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `When protocol is TCP, specifies how often buffers should be flushed, resulting in records sent to the destination. Default: 1; Requires replacement if changed.`,
					},
					"host": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The hostname of the destination. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"mtu": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(512)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `When protocol is UDP, specifies the maximum size of packets sent to the destination. Also known as the MTU for the network path to the destination system. Default: 512; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"port": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(8125)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Destination port. Default: 8125; Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"protocol": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`udp`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Protocol to use when communicating with the destination. Default: "udp"; must be one of ["udp", "tcp"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"udp",
								"tcp",
							),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"throttle_rate_per_sec": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`0`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`), "must match pattern "+regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`).String()),
						},
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "statsd"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf("statsd"),
						},
					},
					"write_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(60000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead. Default: 60000; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_statsd_ext": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"connection_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"dns_resolve_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How often to resolve the destination hostname to an IP address. Ignored if the destination is an IP address. A value of 0 means every batch sent will incur a DNS lookup. Default: 0; Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `When protocol is TCP, specifies how often buffers should be flushed, resulting in records sent to the destination. Default: 1; Requires replacement if changed.`,
					},
					"host": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The hostname of the destination. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"mtu": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(512)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `When protocol is UDP, specifies the maximum size of packets sent to the destination. Also known as the MTU for the network path to the destination system. Default: 512; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"port": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(8125)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Destination port. Default: 8125; Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"protocol": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`udp`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Protocol to use when communicating with the destination. Default: "udp"; must be one of ["udp", "tcp"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"udp",
								"tcp",
							),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"throttle_rate_per_sec": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`0`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`), "must match pattern "+regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`).String()),
						},
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `must be "statsd_ext"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"statsd_ext",
							),
						},
					},
					"write_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(60000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead. Default: 60000; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_sumo_logic": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"compress": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Compress the payload body before sending. Default: true; Requires replacement if changed.`,
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"custom_category": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, override the source category configured on the Sumo Logic HTTP collector. This can also be overridden at the event level with the __sourceCategory field. Requires replacement if changed.`,
					},
					"custom_source": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, override the source name configured on the Sumo Logic HTTP collector. This can also be overridden at the event level with the __sourceName field. Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"format": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`json`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, preserve the raw event format instead of json-ifying it. Default: "json"; must be one of ["json", "raw"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"json",
								"raw",
							),
						},
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"max_payload_events": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1024)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size, in KB, of the request body. Default: 1024; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"total_memory_limit_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "sumo_logic"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf(
								"sumo_logic",
							),
						},
					},
					"url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Sumo Logic HTTP collector URL to which events should be sent. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_syslog": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"app_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`Cribl`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default name for device or application that originated the message. Defaults to Cribl, but will be overwritten by value of __appname if set. Default: "Cribl"; Requires replacement if changed.`,
					},
					"connection_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"facility": schema.Int64Attribute{
						Computed: true,
						Optional: true,
						Default:  int64default.StaticInt64(1),
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
							speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
						},
						Description: `Default value for message facility. Will be overwritten by value of __facility if set. Defaults to user. Default: 1; must be one of ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21"]; Requires replacement if changed.`,
						Validators: []validator.Int64{
							int64validator.OneOf(
								0,
								1,
								2,
								3,
								4,
								5,
								6,
								7,
								8,
								9,
								10,
								11,
								12,
								13,
								14,
								15,
								16,
								17,
								18,
								19,
								20,
								21,
							),
						},
					},
					"host": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The hostname of the receiver. Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"load_balanced": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `For optimal performance, enable load balancing even if you have one hostname, as it can expand to multiple IPs.  If this setting is disabled, consider enabling round-robin DNS. Default: true; Requires replacement if changed.`,
					},
					"log_failed_requests": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Use to troubleshoot issues with sending data. Default: false; Requires replacement if changed.`,
					},
					"max_record_size": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1500)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size of syslog messages. Make sure this value is less than or equal to the MTU to avoid UDP packet fragmentation. Default: 1500; Requires replacement if changed.`,
					},
					"message_format": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`rfc3164`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The syslog message format depending on the receiver's support. Default: "rfc3164"; must be one of ["rfc3164", "rfc5424"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"rfc3164",
								"rfc5424",
							),
						},
					},
					"octet_count_framing": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `When enabled, messages will be prefixed with the byte count of the message. Otherwise, no prefix will be set, and the message will be appended with a \n. Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"port": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The port to connect to on the provided host. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"protocol": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`tcp`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The network protocol to use for sending out syslog messages. Default: "tcp"; must be one of ["tcp", "udp"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"tcp",
								"udp",
							),
						},
					},
					"severity": schema.Int64Attribute{
						Computed: true,
						Optional: true,
						Default:  int64default.StaticInt64(5),
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
							speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
						},
						Description: `Default value for message severity. Will be overwritten by value of __severity if set. Defaults to notice. Default: 5; must be one of ["0", "1", "2", "3", "4", "5", "6", "7"]; Requires replacement if changed.`,
						Validators: []validator.Int64{
							int64validator.OneOf(
								0,
								1,
								2,
								3,
								4,
								5,
								6,
								7,
							),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"throttle_rate_per_sec": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`0`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`), "must match pattern "+regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`).String()),
						},
					},
					"timestamp_format": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`syslog`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Timestamp format to use when serializing event's time field. Default: "syslog"; must be one of ["syslog", "iso8601"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"syslog",
								"iso8601",
							),
						},
					},
					"tls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"cert_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"certificate_name": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The name of the predefined certificate. Requires replacement if changed.`,
							},
							"disabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Default: true; Requires replacement if changed.`,
							},
							"max_version": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Minimum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Passphrase to use to decrypt private key. Requires replacement if changed.`,
							},
							"priv_key_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"reject_unauthorized": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								MarkdownDescription: `Reject certs that are not authorized by a CA in the CA certificate path, or by another ` + "\n" +
									`                    trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.` + "\n" +
									`Default: true; Requires replacement if changed.`,
							},
							"servername": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address. Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "syslog"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf("syslog"),
						},
					},
					"udp_dns_resolve_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How often to resolve the destination hostname to an IP address. Ignored if the destination is an IP address. A value of 0 means every message sent will incur a DNS lookup. Default: 0; Requires replacement if changed.`,
					},
					"write_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(60000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead. Default: 60000; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_tcpjson": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"auth_token": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optional authentication token to include as part of the connection header. Default: ""; Requires replacement if changed.`,
					},
					"auth_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`manual`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"manual",
								"secret",
							),
						},
					},
					"compression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`gzip`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the data before sending. Default: "gzip"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"connection_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"dns_resolve_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(600)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Re-resolve any hostnames every this many seconds and pick up destinations from A records. Default: 600; Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"exclude_self": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Exclude all IPs of the current host from the list of any resolved hostnames. Default: false; Requires replacement if changed.`,
					},
					"host": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The hostname of the receiver. Requires replacement if changed.`,
					},
					"hosts": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"host": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `The hostname of the receiver. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
								"port": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The port to connect to on the provided host. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"servername": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Servername to use if establishing a TLS connection. If not specified, defaults to connection host (iff not an IP); otherwise, to the global TLS settings. Requires replacement if changed.`,
								},
								"tls": schema.StringAttribute{
									Computed: true,
									Optional: true,
									Default:  stringdefault.StaticString(`inherit`),
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Whether to inherit TLS configs from group setting or disable TLS. Default: "inherit"; must be one of ["inherit", "off"]; Requires replacement if changed.`,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"inherit",
											"off",
										),
									},
								},
								"weight": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Assign a weight (>0) to each endpoint to indicate its traffic-handling capability. Default: 1; Requires replacement if changed.`,
								},
							},
						},
						Description: `Set of hosts to load-balance data to. Requires replacement if changed.`,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"load_balance_stats_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How far back in time to keep traffic stats for load balancing purposes. Default: 300; Requires replacement if changed.`,
					},
					"load_balanced": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Use load-balanced destinations. Default: true; Requires replacement if changed.`,
					},
					"log_failed_requests": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Use to troubleshoot issues with sending data. Default: false; Requires replacement if changed.`,
					},
					"max_concurrent_senders": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of concurrent connections (per worker process). A random set of IPs will be picked on every DNS resolution period. Use 0 for unlimited. Default: 0; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"port": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The port to connect to on the provided host. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"send_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Upon connection, send a header-like record containing the auth token and other metadata.This record will not contain an actual event – only subsequent records will. Default: true; Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"text_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"throttle_rate_per_sec": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`0`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`), "must match pattern "+regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`).String()),
						},
					},
					"tls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"cert_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"certificate_name": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The name of the predefined certificate. Requires replacement if changed.`,
							},
							"disabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Default: true; Requires replacement if changed.`,
							},
							"max_version": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Minimum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Passphrase to use to decrypt private key. Requires replacement if changed.`,
							},
							"priv_key_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"reject_unauthorized": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								MarkdownDescription: `Reject certs that are not authorized by a CA in the CA certificate path, or by another ` + "\n" +
									`                    trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.` + "\n" +
									`Default: true; Requires replacement if changed.`,
							},
							"servername": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address. Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"token_ttl_minutes": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(60)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `The number of minutes before the internally generated authentication token expires, valid values between 1 and 60. Default: 60; Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "tcpjson"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf("tcpjson"),
						},
					},
					"write_timeout": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(60000)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead. Default: 60000; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_wavefront": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"auth_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`manual`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"manual",
								"secret",
							),
						},
					},
					"compress": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Compress the payload body before sending. Default: true; Requires replacement if changed.`,
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"domain": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`longboard`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `WaveFront domain name, e.g. "longboard". Default: "longboard"; Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Requires replacement if changed.`,
					},
					"max_payload_events": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(4096)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size, in KB, of the request body. Default: 4096; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"text_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"token": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `WaveFront API authentication token (see [here](https://docs.wavefront.com/wavefront_api.html#generating-an-api-token)). Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "wavefront"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf(
								"wavefront",
							),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_webhook": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"advanced_content_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`application/json`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `HTTP content-type header value. Default: "application/json"; Requires replacement if changed.`,
					},
					"auth_header_expr": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`` + "`" + `Bearer ${token}` + "`" + ``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `JavaScript expression to compute the Authorization header value to pass in requests. The value ` + "`" + `${token}` + "`" + ` is used to reference the token obtained from authentication, e.g.: ` + "`" + `Bearer ${token}` + "`" + `. Default: "` + "`" + `Bearer ${token}` + "`" + `"; Requires replacement if changed.`,
					},
					"auth_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The authentication method to use for the HTTP request. Defaults to None. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"basic",
								"credentialsSecret",
								"token",
								"textSecret",
								"oauth",
							),
						},
					},
					"compress": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Compress the payload body before sending. Default: true; Requires replacement if changed.`,
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"credentials_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a secret that references your credentials. Requires replacement if changed.`,
					},
					"custom_content_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`application/x-ndjson`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Content type to use for request. Defaults to application/x-ndjson. Any content types set in Advanced Settings > Extra HTTP headers will override this entry. Default: "application/x-ndjson"; Requires replacement if changed.`,
					},
					"custom_drop_when_null": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to drop events when the source expression evaluates to null. Default: false; Requires replacement if changed.`,
					},
					"custom_event_delimiter": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`\n`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Delimiter string to insert between individual events. Defaults to newline character. Default: "\\n"; Requires replacement if changed.`,
					},
					"custom_payload_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`` + "`" + `${events}` + "`" + ``),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Expression specifying how to format the payload for each batch. To reference the events to send, use the ` + "`" + `${events}` + "`" + ` variable. Example expression: ` + "`" + `{ "items" : [${events}] }` + "`" + ` would send the batch inside a JSON object. Default: "` + "`" + `${events}` + "`" + `"; Requires replacement if changed.`,
					},
					"custom_source_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`__httpOut`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Expression to evaluate on events to generate output. Example: ` + "`" + `raw=${_raw}` + "`" + `. See [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook#custom-format) for other examples. If empty, the full event is sent as stringified JSON. Default: "__httpOut"; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"dns_resolve_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(600)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Re-resolve any hostnames every this many seconds and pick up destinations from A records. Default: 600; Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"exclude_self": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Exclude all IPs of the current host from the list of any resolved hostnames. Default: false; Requires replacement if changed.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained [here](https://docs.cribl.io/stream/destinations-webhook/#internal-fields). Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"format": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`ndjson`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Specifies how to format events before sending out. Defaults to NDJSON. Default: "ndjson"; must be one of ["ndjson", "json_array", "custom", "advanced"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"ndjson",
								"json_array",
								"custom",
								"advanced",
							),
						},
					},
					"format_event_code": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Custom JavaScript code to format incoming event data accessible through the __e variable. The formatted content is added to (__e['__eventOut']) if available. Otherwise, the original event is serialized as JSON. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code. Requires replacement if changed.`,
					},
					"format_payload_code": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optional JavaScript code to format the payload sent to the Destination. The payload, containing a batch of formatted events, is accessible through the __e['payload'] variable. The formatted payload is returned in the __e['__payloadOut'] variable. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code. Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"keep_alive": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Disable to close the connection immediately after sending the outgoing request. Default: true; Requires replacement if changed.`,
					},
					"load_balance_stats_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How far back in time to keep traffic stats for load balancing purposes. Default: 300; Requires replacement if changed.`,
					},
					"load_balanced": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS. Default: false; Requires replacement if changed.`,
					},
					"login_url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `URL for OAuth. Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
						},
					},
					"max_payload_events": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0; Requires replacement if changed.`,
					},
					"max_payload_size_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(4096)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum size, in KB, of the request body. Default: 4096; Requires replacement if changed.`,
					},
					"method": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`POST`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The method to use when sending events. Defaults to POST. Default: "POST"; must be one of ["POST", "PUT", "PATCH"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"POST",
								"PUT",
								"PATCH",
							),
						},
					},
					"oauth_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `OAuth header name. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `OAuth header value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request. Requires replacement if changed.`,
					},
					"oauth_params": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `OAuth parameter name. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `OAuth parameter value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request. Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"password": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Password for Basic authentication. Requires replacement if changed.`,
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Secret parameter value to pass in request body. Requires replacement if changed.`,
					},
					"secret_param_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Secret parameter name to pass in request body. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"text_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"tls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"cert_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"certificate_name": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The name of the predefined certificate. Requires replacement if changed.`,
							},
							"disabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Default: true; Requires replacement if changed.`,
							},
							"max_version": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Maximum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Minimum TLS version to use when connecting. must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Passphrase to use to decrypt private key. Requires replacement if changed.`,
							},
							"priv_key_path": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS. Requires replacement if changed.`,
							},
							"servername": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address. Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"token": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Bearer token to include in the authorization header. Requires replacement if changed.`,
					},
					"token_attribute_name": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token'). Requires replacement if changed.`,
					},
					"token_timeout_secs": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(3600)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How often the OAuth token should be refreshed. Default: 3600; Requires replacement if changed.`,
					},
					"total_memory_limit_kb": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be one of ["webhook", "sentinel", "dynatrace_http"]; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf(
								"webhook",
								"sentinel",
								"dynatrace_http",
							),
						},
					},
					"url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `URL of a webhook endpoint to send events to, such as http://localhost:10200. Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
						},
					},
					"urls": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"url": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `URL of a webhook endpoint to send events to, such as http://localhost:10200. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
										stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
									},
								},
								"weight": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Assign a weight (>0) to each endpoint to indicate its traffic-handling capability. Default: 1; Requires replacement if changed.`,
								},
							},
						},
						Description: `Requires replacement if changed.`,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false; Requires replacement if changed.`,
					},
					"username": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Username for Basic authentication. Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_xsiam"),
					}...),
				},
			},
			"output_xsiam": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"auth_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`token`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Enter a token directly, or provide a secret referencing a token. Default: "token"; must be one of ["token", "secret"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"token",
								"secret",
							),
						},
					},
					"compress": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Compress the payload body before sending. Default: true; Requires replacement if changed.`,
					},
					"concurrency": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(5)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of ongoing requests before blocking. Default: 5; Requires replacement if changed.`,
					},
					"description": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"dns_resolve_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(600)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Re-resolve any hostnames every this many seconds and pick up destinations from A records. Default: 600; Requires replacement if changed.`,
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere. Requires replacement if changed.`,
					},
					"exclude_self": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Exclude all IPs of the current host from the list of any resolved hostnames. Default: false; Requires replacement if changed.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field name. Requires replacement if changed.`,
								},
								"value": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Field value. Not Null; Requires replacement if changed.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Headers to add to all events. Requires replacement if changed.`,
					},
					"failed_request_logging_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"payload",
								"payloadAndHeaders",
								"none",
							),
						},
					},
					"flush_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size. Default: 1; Requires replacement if changed.`,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Unique ID for this output. Not Null; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"load_balance_stats_period_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(300)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `How far back in time to keep traffic stats for load balancing purposes. Default: 300; Requires replacement if changed.`,
					},
					"load_balanced": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS. Default: false; Requires replacement if changed.`,
					},
					"max_payload_events": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(0)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0; Requires replacement if changed.`,
					},
					"on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block, drop, or queue events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
								"queue",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Pipeline to process data before sending out to this output. Requires replacement if changed.`,
					},
					"pq_compress": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`none`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"gzip",
							),
						},
					},
					"pq_controls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Requires replacement if changed.`,
					},
					"pq_max_file_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`1 MB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_max_size": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`5GB`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
						},
					},
					"pq_mode": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`error`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"backpressure",
								"always",
							),
						},
					},
					"pq_on_backpressure": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`block`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"drop",
							),
						},
					},
					"pq_path": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"; Requires replacement if changed.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(true),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						MarkdownDescription: `Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). ` + "\n" +
							`        Defaults to Yes. When this setting is also present in TLS Settings (Client Side), ` + "\n" +
							`        that value will take precedence.` + "\n" +
							`Default: true; Requires replacement if changed.`,
					},
					"response_honor_retry_after_header": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false; Requires replacement if changed.`,
					},
					"response_retry_settings": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"backoff_rate": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
								},
								"http_status": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The HTTP response status code that will trigger retries. Not Null; Requires replacement if changed.`,
									Validators: []validator.Number{
										speakeasy_numbervalidators.NotNull(),
									},
								},
								"initial_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
								},
								"max_backoff": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
								},
							},
						},
						Description: `Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable). Requires replacement if changed.`,
					},
					"safe_headers": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `List of headers that are safe to log in plain text. Requires replacement if changed.`,
					},
					"streamtags": schema.ListAttribute{
						Computed: true,
						Optional: true,
						Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}. Requires replacement if changed.`,
					},
					"system_fields": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Requires replacement if changed.`,
					},
					"text_secret": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Select or create a stored text secret. Requires replacement if changed.`,
					},
					"throttle_rate_req_per_sec": schema.Int64Attribute{
						Computed: true,
						Optional: true,
						Default:  int64default.StaticInt64(400),
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
							speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
						},
						Description: `Maximum number of requests to limit to per second. Default: 400; Requires replacement if changed.`,
						Validators: []validator.Int64{
							int64validator.AtMost(2000),
						},
					},
					"timeout_retry_settings": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"backoff_rate": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(2)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2; Requires replacement if changed.`,
							},
							"initial_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(1000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000; Requires replacement if changed.`,
							},
							"max_backoff": schema.NumberAttribute{
								Computed: true,
								Optional: true,
								Default:  numberdefault.StaticBigFloat(big.NewFloat(10000)),
								PlanModifiers: []planmodifier.Number{
									numberplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
								},
								Description: `The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000; Requires replacement if changed.`,
							},
							"timeout_retry": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to retry on request timeout. Default: false; Requires replacement if changed.`,
							},
						},
						Description: `Requires replacement if changed.`,
					},
					"timeout_sec": schema.NumberAttribute{
						Computed: true,
						Optional: true,
						Default:  numberdefault.StaticBigFloat(big.NewFloat(30)),
						PlanModifiers: []planmodifier.Number{
							numberplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Description: `Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30; Requires replacement if changed.`,
					},
					"token": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `XSIAM authentication token. Requires replacement if changed.`,
					},
					"type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be "xsiam"; Requires replacement if changed.`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf("xsiam"),
						},
					},
					"url": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`http://localhost:8088/logs/v1/event`),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `XSIAM endpoint URL to send events to, such as https://api-{tenant external URL}/logs/v1/event. Default: "http://localhost:8088/logs/v1/event"; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
						},
					},
					"urls": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"url": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Not Null; Requires replacement if changed.; Parsed as JSON.`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
										validators.IsValidJSON(),
									},
								},
								"weight": schema.NumberAttribute{
									Computed: true,
									Optional: true,
									Default:  numberdefault.StaticBigFloat(big.NewFloat(1)),
									PlanModifiers: []planmodifier.Number{
										numberplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
									},
									Description: `Assign a weight (>0) to each endpoint to indicate its traffic-handling capability. Default: 1; Requires replacement if changed.`,
								},
							},
						},
						Description: `Requires replacement if changed.`,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						Default:  booldefault.StaticBool(false),
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false; Requires replacement if changed.`,
					},
				},
				Description: `Requires replacement if changed.`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("output_azure_blob"),
						path.MatchRelative().AtParent().AtName("output_azure_data_explorer"),
						path.MatchRelative().AtParent().AtName("output_azure_eventhub"),
						path.MatchRelative().AtParent().AtName("output_azure_logs"),
						path.MatchRelative().AtParent().AtName("output_click_house"),
						path.MatchRelative().AtParent().AtName("output_cloudwatch"),
						path.MatchRelative().AtParent().AtName("output_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("output_cribl_http"),
						path.MatchRelative().AtParent().AtName("output_cribl_lake"),
						path.MatchRelative().AtParent().AtName("output_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("output_crowdstrike_next_gen_siem"),
						path.MatchRelative().AtParent().AtName("output_datadog"),
						path.MatchRelative().AtParent().AtName("output_dataset"),
						path.MatchRelative().AtParent().AtName("output_default"),
						path.MatchRelative().AtParent().AtName("output_devnull"),
						path.MatchRelative().AtParent().AtName("output_disk_spool"),
						path.MatchRelative().AtParent().AtName("output_dl_s3"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_http"),
						path.MatchRelative().AtParent().AtName("output_dynatrace_otlp"),
						path.MatchRelative().AtParent().AtName("output_elastic"),
						path.MatchRelative().AtParent().AtName("output_elastic_cloud"),
						path.MatchRelative().AtParent().AtName("output_exabeam"),
						path.MatchRelative().AtParent().AtName("output_filesystem"),
						path.MatchRelative().AtParent().AtName("output_google_chronicle"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_logging"),
						path.MatchRelative().AtParent().AtName("output_google_cloud_storage"),
						path.MatchRelative().AtParent().AtName("output_google_pubsub"),
						path.MatchRelative().AtParent().AtName("output_grafana_cloud"),
						path.MatchRelative().AtParent().AtName("output_graphite"),
						path.MatchRelative().AtParent().AtName("output_honeycomb"),
						path.MatchRelative().AtParent().AtName("output_humio_hec"),
						path.MatchRelative().AtParent().AtName("output_influxdb"),
						path.MatchRelative().AtParent().AtName("output_kafka"),
						path.MatchRelative().AtParent().AtName("output_kinesis"),
						path.MatchRelative().AtParent().AtName("output_loki"),
						path.MatchRelative().AtParent().AtName("output_minio"),
						path.MatchRelative().AtParent().AtName("output_msk"),
						path.MatchRelative().AtParent().AtName("output_netflow"),
						path.MatchRelative().AtParent().AtName("output_newrelic"),
						path.MatchRelative().AtParent().AtName("output_newrelic_events"),
						path.MatchRelative().AtParent().AtName("output_open_telemetry"),
						path.MatchRelative().AtParent().AtName("output_prometheus"),
						path.MatchRelative().AtParent().AtName("output_ring"),
						path.MatchRelative().AtParent().AtName("output_router"),
						path.MatchRelative().AtParent().AtName("output_s3"),
						path.MatchRelative().AtParent().AtName("output_security_lake"),
						path.MatchRelative().AtParent().AtName("output_sentinel"),
						path.MatchRelative().AtParent().AtName("output_service_now"),
						path.MatchRelative().AtParent().AtName("output_signalfx"),
						path.MatchRelative().AtParent().AtName("output_snmp"),
						path.MatchRelative().AtParent().AtName("output_sns"),
						path.MatchRelative().AtParent().AtName("output_splunk"),
						path.MatchRelative().AtParent().AtName("output_splunk_hec"),
						path.MatchRelative().AtParent().AtName("output_splunk_lb"),
						path.MatchRelative().AtParent().AtName("output_sqs"),
						path.MatchRelative().AtParent().AtName("output_statsd"),
						path.MatchRelative().AtParent().AtName("output_statsd_ext"),
						path.MatchRelative().AtParent().AtName("output_sumo_logic"),
						path.MatchRelative().AtParent().AtName("output_syslog"),
						path.MatchRelative().AtParent().AtName("output_tcpjson"),
						path.MatchRelative().AtParent().AtName("output_wavefront"),
						path.MatchRelative().AtParent().AtName("output_webhook"),
					}...),
				},
			},
		},
	}
}

func (r *DestinationResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.CriblTerraform)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.CriblTerraform, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *DestinationResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *DestinationResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request := *data.ToSharedOutput()
	res, err := r.client.Outputs.CreateOutput(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.Object != nil && res.Object.Items != nil && len(res.Object.Items) > 0) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedOutput(&res.Object.Items[0])
	refreshPlan(ctx, plan, &data, resp.Diagnostics)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *DestinationResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *DestinationResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Not Implemented; we rely entirely on CREATE API request response

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *DestinationResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *DestinationResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	// Not Implemented; all attributes marked as RequiresReplace

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *DestinationResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *DestinationResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Not Implemented; entity does not have a configured DELETE operation
}

func (r *DestinationResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resp.Diagnostics.AddError("Not Implemented", "No available import state operation is available for resource destination.")
}
