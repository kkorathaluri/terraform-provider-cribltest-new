// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/speakeasy/terraform-provider-cribl-terraform/internal/sdk/internal/utils"
)

type OutputSyslogType string

const (
	OutputSyslogTypeSyslog OutputSyslogType = "syslog"
)

func (e OutputSyslogType) ToPointer() *OutputSyslogType {
	return &e
}
func (e *OutputSyslogType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "syslog":
		*e = OutputSyslogType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSyslogType: %v", v)
	}
}

// OutputSyslogProtocol - The network protocol to use for sending out syslog messages
type OutputSyslogProtocol string

const (
	OutputSyslogProtocolTCP OutputSyslogProtocol = "tcp"
	OutputSyslogProtocolUDP OutputSyslogProtocol = "udp"
)

func (e OutputSyslogProtocol) ToPointer() *OutputSyslogProtocol {
	return &e
}
func (e *OutputSyslogProtocol) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "tcp":
		fallthrough
	case "udp":
		*e = OutputSyslogProtocol(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSyslogProtocol: %v", v)
	}
}

// Facility - Default value for message facility. Will be overwritten by value of __facility if set. Defaults to user.
type Facility int64

const (
	FacilityZero      Facility = 0
	FacilityOne       Facility = 1
	FacilityTwo       Facility = 2
	FacilityThree     Facility = 3
	FacilityFour      Facility = 4
	FacilityFive      Facility = 5
	FacilitySix       Facility = 6
	FacilitySeven     Facility = 7
	FacilityEight     Facility = 8
	FacilityNine      Facility = 9
	FacilityTen       Facility = 10
	FacilityEleven    Facility = 11
	FacilityTwelve    Facility = 12
	FacilityThirteen  Facility = 13
	FacilityFourteen  Facility = 14
	FacilityFifteen   Facility = 15
	FacilitySixteen   Facility = 16
	FacilitySeventeen Facility = 17
	FacilityEighteen  Facility = 18
	FacilityNineteen  Facility = 19
	FacilityTwenty    Facility = 20
	FacilityTwentyOne Facility = 21
)

func (e Facility) ToPointer() *Facility {
	return &e
}
func (e *Facility) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		fallthrough
	case 2:
		fallthrough
	case 3:
		fallthrough
	case 4:
		fallthrough
	case 5:
		fallthrough
	case 6:
		fallthrough
	case 7:
		fallthrough
	case 8:
		fallthrough
	case 9:
		fallthrough
	case 10:
		fallthrough
	case 11:
		fallthrough
	case 12:
		fallthrough
	case 13:
		fallthrough
	case 14:
		fallthrough
	case 15:
		fallthrough
	case 16:
		fallthrough
	case 17:
		fallthrough
	case 18:
		fallthrough
	case 19:
		fallthrough
	case 20:
		fallthrough
	case 21:
		*e = Facility(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Facility: %v", v)
	}
}

// OutputSyslogSeverity - Default value for message severity. Will be overwritten by value of __severity if set. Defaults to notice.
type OutputSyslogSeverity int64

const (
	OutputSyslogSeverityZero  OutputSyslogSeverity = 0
	OutputSyslogSeverityOne   OutputSyslogSeverity = 1
	OutputSyslogSeverityTwo   OutputSyslogSeverity = 2
	OutputSyslogSeverityThree OutputSyslogSeverity = 3
	OutputSyslogSeverityFour  OutputSyslogSeverity = 4
	OutputSyslogSeverityFive  OutputSyslogSeverity = 5
	OutputSyslogSeveritySix   OutputSyslogSeverity = 6
	OutputSyslogSeveritySeven OutputSyslogSeverity = 7
)

func (e OutputSyslogSeverity) ToPointer() *OutputSyslogSeverity {
	return &e
}
func (e *OutputSyslogSeverity) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		fallthrough
	case 2:
		fallthrough
	case 3:
		fallthrough
	case 4:
		fallthrough
	case 5:
		fallthrough
	case 6:
		fallthrough
	case 7:
		*e = OutputSyslogSeverity(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSyslogSeverity: %v", v)
	}
}

// MessageFormat - The syslog message format depending on the receiver's support
type MessageFormat string

const (
	MessageFormatRfc3164 MessageFormat = "rfc3164"
	MessageFormatRfc5424 MessageFormat = "rfc5424"
)

func (e MessageFormat) ToPointer() *MessageFormat {
	return &e
}
func (e *MessageFormat) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "rfc3164":
		fallthrough
	case "rfc5424":
		*e = MessageFormat(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MessageFormat: %v", v)
	}
}

// TimestampFormat - Timestamp format to use when serializing event's time field
type TimestampFormat string

const (
	TimestampFormatSyslog  TimestampFormat = "syslog"
	TimestampFormatIso8601 TimestampFormat = "iso8601"
)

func (e TimestampFormat) ToPointer() *TimestampFormat {
	return &e
}
func (e *TimestampFormat) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "syslog":
		fallthrough
	case "iso8601":
		*e = TimestampFormat(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TimestampFormat: %v", v)
	}
}

// OutputSyslogMinimumTLSVersion - Minimum TLS version to use when connecting
type OutputSyslogMinimumTLSVersion string

const (
	OutputSyslogMinimumTLSVersionTlSv1  OutputSyslogMinimumTLSVersion = "TLSv1"
	OutputSyslogMinimumTLSVersionTlSv11 OutputSyslogMinimumTLSVersion = "TLSv1.1"
	OutputSyslogMinimumTLSVersionTlSv12 OutputSyslogMinimumTLSVersion = "TLSv1.2"
	OutputSyslogMinimumTLSVersionTlSv13 OutputSyslogMinimumTLSVersion = "TLSv1.3"
)

func (e OutputSyslogMinimumTLSVersion) ToPointer() *OutputSyslogMinimumTLSVersion {
	return &e
}
func (e *OutputSyslogMinimumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = OutputSyslogMinimumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSyslogMinimumTLSVersion: %v", v)
	}
}

// OutputSyslogMaximumTLSVersion - Maximum TLS version to use when connecting
type OutputSyslogMaximumTLSVersion string

const (
	OutputSyslogMaximumTLSVersionTlSv1  OutputSyslogMaximumTLSVersion = "TLSv1"
	OutputSyslogMaximumTLSVersionTlSv11 OutputSyslogMaximumTLSVersion = "TLSv1.1"
	OutputSyslogMaximumTLSVersionTlSv12 OutputSyslogMaximumTLSVersion = "TLSv1.2"
	OutputSyslogMaximumTLSVersionTlSv13 OutputSyslogMaximumTLSVersion = "TLSv1.3"
)

func (e OutputSyslogMaximumTLSVersion) ToPointer() *OutputSyslogMaximumTLSVersion {
	return &e
}
func (e *OutputSyslogMaximumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = OutputSyslogMaximumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSyslogMaximumTLSVersion: %v", v)
	}
}

type OutputSyslogTLSSettingsClientSide struct {
	Disabled *bool `default:"true" json:"disabled"`
	// Reject certs that are not authorized by a CA in the CA certificate path, or by another
	//                     trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
	Servername *string `json:"servername,omitempty"`
	// The name of the predefined certificate.
	CertificateName *string `json:"certificateName,omitempty"`
	// Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
	CaPath *string `json:"caPath,omitempty"`
	// Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
	PrivKeyPath *string `json:"privKeyPath,omitempty"`
	// Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
	CertPath *string `json:"certPath,omitempty"`
	// Passphrase to use to decrypt private key.
	Passphrase *string `json:"passphrase,omitempty"`
	// Minimum TLS version to use when connecting
	MinVersion *OutputSyslogMinimumTLSVersion `json:"minVersion,omitempty"`
	// Maximum TLS version to use when connecting
	MaxVersion *OutputSyslogMaximumTLSVersion `json:"maxVersion,omitempty"`
}

func (o OutputSyslogTLSSettingsClientSide) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OutputSyslogTLSSettingsClientSide) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *OutputSyslogTLSSettingsClientSide) GetDisabled() *bool {
	if o == nil {
		return nil
	}
	return o.Disabled
}

func (o *OutputSyslogTLSSettingsClientSide) GetRejectUnauthorized() *bool {
	if o == nil {
		return nil
	}
	return o.RejectUnauthorized
}

func (o *OutputSyslogTLSSettingsClientSide) GetServername() *string {
	if o == nil {
		return nil
	}
	return o.Servername
}

func (o *OutputSyslogTLSSettingsClientSide) GetCertificateName() *string {
	if o == nil {
		return nil
	}
	return o.CertificateName
}

func (o *OutputSyslogTLSSettingsClientSide) GetCaPath() *string {
	if o == nil {
		return nil
	}
	return o.CaPath
}

func (o *OutputSyslogTLSSettingsClientSide) GetPrivKeyPath() *string {
	if o == nil {
		return nil
	}
	return o.PrivKeyPath
}

func (o *OutputSyslogTLSSettingsClientSide) GetCertPath() *string {
	if o == nil {
		return nil
	}
	return o.CertPath
}

func (o *OutputSyslogTLSSettingsClientSide) GetPassphrase() *string {
	if o == nil {
		return nil
	}
	return o.Passphrase
}

func (o *OutputSyslogTLSSettingsClientSide) GetMinVersion() *OutputSyslogMinimumTLSVersion {
	if o == nil {
		return nil
	}
	return o.MinVersion
}

func (o *OutputSyslogTLSSettingsClientSide) GetMaxVersion() *OutputSyslogMaximumTLSVersion {
	if o == nil {
		return nil
	}
	return o.MaxVersion
}

// OutputSyslogBackpressureBehavior - Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputSyslogBackpressureBehavior string

const (
	OutputSyslogBackpressureBehaviorBlock OutputSyslogBackpressureBehavior = "block"
	OutputSyslogBackpressureBehaviorDrop  OutputSyslogBackpressureBehavior = "drop"
	OutputSyslogBackpressureBehaviorQueue OutputSyslogBackpressureBehavior = "queue"
)

func (e OutputSyslogBackpressureBehavior) ToPointer() *OutputSyslogBackpressureBehavior {
	return &e
}
func (e *OutputSyslogBackpressureBehavior) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "block":
		fallthrough
	case "drop":
		fallthrough
	case "queue":
		*e = OutputSyslogBackpressureBehavior(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSyslogBackpressureBehavior: %v", v)
	}
}

// OutputSyslogCompression - Codec to use to compress the persisted data.
type OutputSyslogCompression string

const (
	OutputSyslogCompressionNone OutputSyslogCompression = "none"
	OutputSyslogCompressionGzip OutputSyslogCompression = "gzip"
)

func (e OutputSyslogCompression) ToPointer() *OutputSyslogCompression {
	return &e
}
func (e *OutputSyslogCompression) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "gzip":
		*e = OutputSyslogCompression(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSyslogCompression: %v", v)
	}
}

// OutputSyslogQueueFullBehavior - Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputSyslogQueueFullBehavior string

const (
	OutputSyslogQueueFullBehaviorBlock OutputSyslogQueueFullBehavior = "block"
	OutputSyslogQueueFullBehaviorDrop  OutputSyslogQueueFullBehavior = "drop"
)

func (e OutputSyslogQueueFullBehavior) ToPointer() *OutputSyslogQueueFullBehavior {
	return &e
}
func (e *OutputSyslogQueueFullBehavior) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "block":
		fallthrough
	case "drop":
		*e = OutputSyslogQueueFullBehavior(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSyslogQueueFullBehavior: %v", v)
	}
}

// OutputSyslogMode - In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputSyslogMode string

const (
	OutputSyslogModeError        OutputSyslogMode = "error"
	OutputSyslogModeBackpressure OutputSyslogMode = "backpressure"
	OutputSyslogModeAlways       OutputSyslogMode = "always"
)

func (e OutputSyslogMode) ToPointer() *OutputSyslogMode {
	return &e
}
func (e *OutputSyslogMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "error":
		fallthrough
	case "backpressure":
		fallthrough
	case "always":
		*e = OutputSyslogMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSyslogMode: %v", v)
	}
}

type OutputSyslogPqControls struct {
}

type OutputSyslog struct {
	// Unique ID for this output
	ID   string           `json:"id"`
	Type OutputSyslogType `json:"type"`
	// Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`
	// Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields []string `json:"systemFields,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// The network protocol to use for sending out syslog messages
	Protocol *OutputSyslogProtocol `default:"tcp" json:"protocol"`
	// Default value for message facility. Will be overwritten by value of __facility if set. Defaults to user.
	Facility *Facility `default:"1" json:"facility"`
	// Default value for message severity. Will be overwritten by value of __severity if set. Defaults to notice.
	Severity *OutputSyslogSeverity `default:"5" json:"severity"`
	// Default name for device or application that originated the message. Defaults to Cribl, but will be overwritten by value of __appname if set.
	AppName *string `default:"Cribl" json:"appName"`
	// The syslog message format depending on the receiver's support
	MessageFormat *MessageFormat `default:"rfc3164" json:"messageFormat"`
	// Timestamp format to use when serializing event's time field
	TimestampFormat *TimestampFormat `default:"syslog" json:"timestampFormat"`
	// Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
	ThrottleRatePerSec *string `default:"0" json:"throttleRatePerSec"`
	// When enabled, messages will be prefixed with the byte count of the message. Otherwise, no prefix will be set, and the message will be appended with a \n.
	OctetCountFraming *bool `json:"octetCountFraming,omitempty"`
	// Use to troubleshoot issues with sending data
	LogFailedRequests *bool   `default:"false" json:"logFailedRequests"`
	Description       *string `json:"description,omitempty"`
	// For optimal performance, enable load balancing even if you have one hostname, as it can expand to multiple IPs.  If this setting is disabled, consider enabling round-robin DNS.
	LoadBalanced *bool `default:"true" json:"loadBalanced"`
	// Amount of time (milliseconds) to wait for the connection to establish before retrying
	ConnectionTimeout *float64 `default:"10000" json:"connectionTimeout"`
	// Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead
	WriteTimeout *float64                           `default:"60000" json:"writeTimeout"`
	TLS          *OutputSyslogTLSSettingsClientSide `json:"tls,omitempty"`
	// Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputSyslogBackpressureBehavior `default:"block" json:"onBackpressure"`
	// The hostname of the receiver
	Host *string `json:"host,omitempty"`
	// The port to connect to on the provided host
	Port *float64 `json:"port,omitempty"`
	// Maximum size of syslog messages. Make sure this value is less than or equal to the MTU to avoid UDP packet fragmentation.
	MaxRecordSize *float64 `default:"1500" json:"maxRecordSize"`
	// How often to resolve the destination hostname to an IP address. Ignored if the destination is an IP address. A value of 0 means every message sent will incur a DNS lookup.
	UDPDNSResolvePeriodSec *float64 `default:"0" json:"udpDnsResolvePeriodSec"`
	// The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `default:"1 MB" json:"pqMaxFileSize"`
	// The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `default:"5GB" json:"pqMaxSize"`
	// The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `default:"\\$CRIBL_HOME/state/queues" json:"pqPath"`
	// Codec to use to compress the persisted data.
	PqCompress *OutputSyslogCompression `default:"none" json:"pqCompress"`
	// Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputSyslogQueueFullBehavior `default:"block" json:"pqOnBackpressure"`
	// In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode     *OutputSyslogMode       `default:"error" json:"pqMode"`
	PqControls *OutputSyslogPqControls `json:"pqControls,omitempty"`
}

func (o OutputSyslog) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OutputSyslog) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *OutputSyslog) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *OutputSyslog) GetType() OutputSyslogType {
	if o == nil {
		return OutputSyslogType("")
	}
	return o.Type
}

func (o *OutputSyslog) GetPipeline() *string {
	if o == nil {
		return nil
	}
	return o.Pipeline
}

func (o *OutputSyslog) GetSystemFields() []string {
	if o == nil {
		return nil
	}
	return o.SystemFields
}

func (o *OutputSyslog) GetEnvironment() *string {
	if o == nil {
		return nil
	}
	return o.Environment
}

func (o *OutputSyslog) GetStreamtags() []string {
	if o == nil {
		return nil
	}
	return o.Streamtags
}

func (o *OutputSyslog) GetProtocol() *OutputSyslogProtocol {
	if o == nil {
		return nil
	}
	return o.Protocol
}

func (o *OutputSyslog) GetFacility() *Facility {
	if o == nil {
		return nil
	}
	return o.Facility
}

func (o *OutputSyslog) GetSeverity() *OutputSyslogSeverity {
	if o == nil {
		return nil
	}
	return o.Severity
}

func (o *OutputSyslog) GetAppName() *string {
	if o == nil {
		return nil
	}
	return o.AppName
}

func (o *OutputSyslog) GetMessageFormat() *MessageFormat {
	if o == nil {
		return nil
	}
	return o.MessageFormat
}

func (o *OutputSyslog) GetTimestampFormat() *TimestampFormat {
	if o == nil {
		return nil
	}
	return o.TimestampFormat
}

func (o *OutputSyslog) GetThrottleRatePerSec() *string {
	if o == nil {
		return nil
	}
	return o.ThrottleRatePerSec
}

func (o *OutputSyslog) GetOctetCountFraming() *bool {
	if o == nil {
		return nil
	}
	return o.OctetCountFraming
}

func (o *OutputSyslog) GetLogFailedRequests() *bool {
	if o == nil {
		return nil
	}
	return o.LogFailedRequests
}

func (o *OutputSyslog) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *OutputSyslog) GetLoadBalanced() *bool {
	if o == nil {
		return nil
	}
	return o.LoadBalanced
}

func (o *OutputSyslog) GetConnectionTimeout() *float64 {
	if o == nil {
		return nil
	}
	return o.ConnectionTimeout
}

func (o *OutputSyslog) GetWriteTimeout() *float64 {
	if o == nil {
		return nil
	}
	return o.WriteTimeout
}

func (o *OutputSyslog) GetTLS() *OutputSyslogTLSSettingsClientSide {
	if o == nil {
		return nil
	}
	return o.TLS
}

func (o *OutputSyslog) GetOnBackpressure() *OutputSyslogBackpressureBehavior {
	if o == nil {
		return nil
	}
	return o.OnBackpressure
}

func (o *OutputSyslog) GetHost() *string {
	if o == nil {
		return nil
	}
	return o.Host
}

func (o *OutputSyslog) GetPort() *float64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *OutputSyslog) GetMaxRecordSize() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxRecordSize
}

func (o *OutputSyslog) GetUDPDNSResolvePeriodSec() *float64 {
	if o == nil {
		return nil
	}
	return o.UDPDNSResolvePeriodSec
}

func (o *OutputSyslog) GetPqMaxFileSize() *string {
	if o == nil {
		return nil
	}
	return o.PqMaxFileSize
}

func (o *OutputSyslog) GetPqMaxSize() *string {
	if o == nil {
		return nil
	}
	return o.PqMaxSize
}

func (o *OutputSyslog) GetPqPath() *string {
	if o == nil {
		return nil
	}
	return o.PqPath
}

func (o *OutputSyslog) GetPqCompress() *OutputSyslogCompression {
	if o == nil {
		return nil
	}
	return o.PqCompress
}

func (o *OutputSyslog) GetPqOnBackpressure() *OutputSyslogQueueFullBehavior {
	if o == nil {
		return nil
	}
	return o.PqOnBackpressure
}

func (o *OutputSyslog) GetPqMode() *OutputSyslogMode {
	if o == nil {
		return nil
	}
	return o.PqMode
}

func (o *OutputSyslog) GetPqControls() *OutputSyslogPqControls {
	if o == nil {
		return nil
	}
	return o.PqControls
}
