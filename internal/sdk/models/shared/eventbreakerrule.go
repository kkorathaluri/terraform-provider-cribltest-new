// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy/terraform-provider-cribl-terraform/internal/sdk/internal/utils"
)

type EventBreakerRuleParser4Type string

const (
	EventBreakerRuleParser4TypeKvp EventBreakerRuleParser4Type = "kvp"
)

func (e EventBreakerRuleParser4Type) ToPointer() *EventBreakerRuleParser4Type {
	return &e
}
func (e *EventBreakerRuleParser4Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "kvp":
		*e = EventBreakerRuleParser4Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for EventBreakerRuleParser4Type: %v", v)
	}
}

type Four struct {
	AllowedKeyChars   *bool                       `json:"allowedKeyChars,omitempty"`
	AllowedValueChars []string                    `json:"allowedValueChars,omitempty"`
	CleanFields       []string                    `json:"cleanFields,omitempty"`
	DelimChar         *string                     `json:"delimChar,omitempty"`
	DstField          *string                     `json:"dstField,omitempty"`
	EscapeChar        *string                     `json:"escapeChar,omitempty"`
	FieldFilterExpr   *string                     `json:"fieldFilterExpr,omitempty"`
	Fields            []string                    `json:"fields,omitempty"`
	Keep              []string                    `json:"keep,omitempty"`
	Mode              ParserMode                  `json:"mode"`
	NullValue         *string                     `json:"nullValue,omitempty"`
	QuoteChar         *string                     `json:"quoteChar,omitempty"`
	Remove            []string                    `json:"remove,omitempty"`
	SrcField          string                      `json:"srcField"`
	Type              EventBreakerRuleParser4Type `json:"type"`
}

func (o *Four) GetAllowedKeyChars() *bool {
	if o == nil {
		return nil
	}
	return o.AllowedKeyChars
}

func (o *Four) GetAllowedValueChars() []string {
	if o == nil {
		return nil
	}
	return o.AllowedValueChars
}

func (o *Four) GetCleanFields() []string {
	if o == nil {
		return nil
	}
	return o.CleanFields
}

func (o *Four) GetDelimChar() *string {
	if o == nil {
		return nil
	}
	return o.DelimChar
}

func (o *Four) GetDstField() *string {
	if o == nil {
		return nil
	}
	return o.DstField
}

func (o *Four) GetEscapeChar() *string {
	if o == nil {
		return nil
	}
	return o.EscapeChar
}

func (o *Four) GetFieldFilterExpr() *string {
	if o == nil {
		return nil
	}
	return o.FieldFilterExpr
}

func (o *Four) GetFields() []string {
	if o == nil {
		return nil
	}
	return o.Fields
}

func (o *Four) GetKeep() []string {
	if o == nil {
		return nil
	}
	return o.Keep
}

func (o *Four) GetMode() ParserMode {
	if o == nil {
		return ParserMode("")
	}
	return o.Mode
}

func (o *Four) GetNullValue() *string {
	if o == nil {
		return nil
	}
	return o.NullValue
}

func (o *Four) GetQuoteChar() *string {
	if o == nil {
		return nil
	}
	return o.QuoteChar
}

func (o *Four) GetRemove() []string {
	if o == nil {
		return nil
	}
	return o.Remove
}

func (o *Four) GetSrcField() string {
	if o == nil {
		return ""
	}
	return o.SrcField
}

func (o *Four) GetType() EventBreakerRuleParser4Type {
	if o == nil {
		return EventBreakerRuleParser4Type("")
	}
	return o.Type
}

type EventBreakerRuleParser3Type string

const (
	EventBreakerRuleParser3TypeJSON EventBreakerRuleParser3Type = "json"
)

func (e EventBreakerRuleParser3Type) ToPointer() *EventBreakerRuleParser3Type {
	return &e
}
func (e *EventBreakerRuleParser3Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "json":
		*e = EventBreakerRuleParser3Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for EventBreakerRuleParser3Type: %v", v)
	}
}

type Three struct {
	CleanFields     []string                    `json:"cleanFields,omitempty"`
	DstField        *string                     `json:"dstField,omitempty"`
	FieldFilterExpr *string                     `json:"fieldFilterExpr,omitempty"`
	Fields          []string                    `json:"fields,omitempty"`
	Keep            []string                    `json:"keep,omitempty"`
	Mode            ParserMode                  `json:"mode"`
	Remove          []string                    `json:"remove,omitempty"`
	SrcField        string                      `json:"srcField"`
	Type            EventBreakerRuleParser3Type `json:"type"`
}

func (o *Three) GetCleanFields() []string {
	if o == nil {
		return nil
	}
	return o.CleanFields
}

func (o *Three) GetDstField() *string {
	if o == nil {
		return nil
	}
	return o.DstField
}

func (o *Three) GetFieldFilterExpr() *string {
	if o == nil {
		return nil
	}
	return o.FieldFilterExpr
}

func (o *Three) GetFields() []string {
	if o == nil {
		return nil
	}
	return o.Fields
}

func (o *Three) GetKeep() []string {
	if o == nil {
		return nil
	}
	return o.Keep
}

func (o *Three) GetMode() ParserMode {
	if o == nil {
		return ParserMode("")
	}
	return o.Mode
}

func (o *Three) GetRemove() []string {
	if o == nil {
		return nil
	}
	return o.Remove
}

func (o *Three) GetSrcField() string {
	if o == nil {
		return ""
	}
	return o.SrcField
}

func (o *Three) GetType() EventBreakerRuleParser3Type {
	if o == nil {
		return EventBreakerRuleParser3Type("")
	}
	return o.Type
}

type PatternList struct {
	Pattern string `json:"pattern"`
}

func (o *PatternList) GetPattern() string {
	if o == nil {
		return ""
	}
	return o.Pattern
}

type EventBreakerRuleParserType string

const (
	EventBreakerRuleParserTypeGrok EventBreakerRuleParserType = "grok"
)

func (e EventBreakerRuleParserType) ToPointer() *EventBreakerRuleParserType {
	return &e
}
func (e *EventBreakerRuleParserType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "grok":
		*e = EventBreakerRuleParserType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for EventBreakerRuleParserType: %v", v)
	}
}

type Parser2 struct {
	DstField    *string                    `json:"dstField,omitempty"`
	Mode        ParserMode                 `json:"mode"`
	Pattern     *string                    `json:"pattern,omitempty"`
	PatternList []PatternList              `json:"patternList,omitempty"`
	Source      *string                    `json:"source,omitempty"`
	SrcField    string                     `json:"srcField"`
	Type        EventBreakerRuleParserType `json:"type"`
}

func (o *Parser2) GetDstField() *string {
	if o == nil {
		return nil
	}
	return o.DstField
}

func (o *Parser2) GetMode() ParserMode {
	if o == nil {
		return ParserMode("")
	}
	return o.Mode
}

func (o *Parser2) GetPattern() *string {
	if o == nil {
		return nil
	}
	return o.Pattern
}

func (o *Parser2) GetPatternList() []PatternList {
	if o == nil {
		return nil
	}
	return o.PatternList
}

func (o *Parser2) GetSource() *string {
	if o == nil {
		return nil
	}
	return o.Source
}

func (o *Parser2) GetSrcField() string {
	if o == nil {
		return ""
	}
	return o.SrcField
}

func (o *Parser2) GetType() EventBreakerRuleParserType {
	if o == nil {
		return EventBreakerRuleParserType("")
	}
	return o.Type
}

type ParserType string

const (
	ParserTypeClf   ParserType = "clf"
	ParserTypeCsv   ParserType = "csv"
	ParserTypeDelim ParserType = "delim"
	ParserTypeElff  ParserType = "elff"
)

func (e ParserType) ToPointer() *ParserType {
	return &e
}
func (e *ParserType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "clf":
		fallthrough
	case "csv":
		fallthrough
	case "delim":
		fallthrough
	case "elff":
		*e = ParserType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ParserType: %v", v)
	}
}

type Parser1 struct {
	AllowedKeyChars   *bool      `json:"allowedKeyChars,omitempty"`
	AllowedValueChars []string   `json:"allowedValueChars,omitempty"`
	CleanFields       []string   `json:"cleanFields,omitempty"`
	DelimChar         *string    `json:"delimChar,omitempty"`
	DstField          *string    `json:"dstField,omitempty"`
	EscapeChar        *string    `json:"escapeChar,omitempty"`
	FieldFilterExpr   *string    `json:"fieldFilterExpr,omitempty"`
	Fields            []string   `json:"fields,omitempty"`
	Keep              []string   `json:"keep,omitempty"`
	Mode              ParserMode `json:"mode"`
	NullValue         *string    `json:"nullValue,omitempty"`
	QuoteChar         *string    `json:"quoteChar,omitempty"`
	Remove            []string   `json:"remove,omitempty"`
	SrcField          string     `json:"srcField"`
	Type              ParserType `json:"type"`
}

func (o *Parser1) GetAllowedKeyChars() *bool {
	if o == nil {
		return nil
	}
	return o.AllowedKeyChars
}

func (o *Parser1) GetAllowedValueChars() []string {
	if o == nil {
		return nil
	}
	return o.AllowedValueChars
}

func (o *Parser1) GetCleanFields() []string {
	if o == nil {
		return nil
	}
	return o.CleanFields
}

func (o *Parser1) GetDelimChar() *string {
	if o == nil {
		return nil
	}
	return o.DelimChar
}

func (o *Parser1) GetDstField() *string {
	if o == nil {
		return nil
	}
	return o.DstField
}

func (o *Parser1) GetEscapeChar() *string {
	if o == nil {
		return nil
	}
	return o.EscapeChar
}

func (o *Parser1) GetFieldFilterExpr() *string {
	if o == nil {
		return nil
	}
	return o.FieldFilterExpr
}

func (o *Parser1) GetFields() []string {
	if o == nil {
		return nil
	}
	return o.Fields
}

func (o *Parser1) GetKeep() []string {
	if o == nil {
		return nil
	}
	return o.Keep
}

func (o *Parser1) GetMode() ParserMode {
	if o == nil {
		return ParserMode("")
	}
	return o.Mode
}

func (o *Parser1) GetNullValue() *string {
	if o == nil {
		return nil
	}
	return o.NullValue
}

func (o *Parser1) GetQuoteChar() *string {
	if o == nil {
		return nil
	}
	return o.QuoteChar
}

func (o *Parser1) GetRemove() []string {
	if o == nil {
		return nil
	}
	return o.Remove
}

func (o *Parser1) GetSrcField() string {
	if o == nil {
		return ""
	}
	return o.SrcField
}

func (o *Parser1) GetType() ParserType {
	if o == nil {
		return ParserType("")
	}
	return o.Type
}

type ParserUnionType string

const (
	ParserUnionTypeParser1 ParserUnionType = "parser_1"
	ParserUnionTypeParser2 ParserUnionType = "parser_2"
	ParserUnionTypeThree   ParserUnionType = "3"
	ParserUnionTypeFour    ParserUnionType = "4"
)

type Parser struct {
	Parser1 *Parser1 `queryParam:"inline"`
	Parser2 *Parser2 `queryParam:"inline"`
	Three   *Three   `queryParam:"inline"`
	Four    *Four    `queryParam:"inline"`

	Type ParserUnionType
}

func CreateParserParser1(parser1 Parser1) Parser {
	typ := ParserUnionTypeParser1

	return Parser{
		Parser1: &parser1,
		Type:    typ,
	}
}

func CreateParserParser2(parser2 Parser2) Parser {
	typ := ParserUnionTypeParser2

	return Parser{
		Parser2: &parser2,
		Type:    typ,
	}
}

func CreateParserThree(three Three) Parser {
	typ := ParserUnionTypeThree

	return Parser{
		Three: &three,
		Type:  typ,
	}
}

func CreateParserFour(four Four) Parser {
	typ := ParserUnionTypeFour

	return Parser{
		Four: &four,
		Type: typ,
	}
}

func (u *Parser) UnmarshalJSON(data []byte) error {

	var parser2 Parser2 = Parser2{}
	if err := utils.UnmarshalJSON(data, &parser2, "", true, true); err == nil {
		u.Parser2 = &parser2
		u.Type = ParserUnionTypeParser2
		return nil
	}

	var three Three = Three{}
	if err := utils.UnmarshalJSON(data, &three, "", true, true); err == nil {
		u.Three = &three
		u.Type = ParserUnionTypeThree
		return nil
	}

	var parser1 Parser1 = Parser1{}
	if err := utils.UnmarshalJSON(data, &parser1, "", true, true); err == nil {
		u.Parser1 = &parser1
		u.Type = ParserUnionTypeParser1
		return nil
	}

	var four Four = Four{}
	if err := utils.UnmarshalJSON(data, &four, "", true, true); err == nil {
		u.Four = &four
		u.Type = ParserUnionTypeFour
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Parser", string(data))
}

func (u Parser) MarshalJSON() ([]byte, error) {
	if u.Parser1 != nil {
		return utils.MarshalJSON(u.Parser1, "", true)
	}

	if u.Parser2 != nil {
		return utils.MarshalJSON(u.Parser2, "", true)
	}

	if u.Three != nil {
		return utils.MarshalJSON(u.Three, "", true)
	}

	if u.Four != nil {
		return utils.MarshalJSON(u.Four, "", true)
	}

	return nil, errors.New("could not marshal union type Parser: all fields are null")
}

type EventBreakerRuleTimestampType string

const (
	EventBreakerRuleTimestampTypeAuto    EventBreakerRuleTimestampType = "auto"
	EventBreakerRuleTimestampTypeFormat  EventBreakerRuleTimestampType = "format"
	EventBreakerRuleTimestampTypeCurrent EventBreakerRuleTimestampType = "current"
)

func (e EventBreakerRuleTimestampType) ToPointer() *EventBreakerRuleTimestampType {
	return &e
}
func (e *EventBreakerRuleTimestampType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "auto":
		fallthrough
	case "format":
		fallthrough
	case "current":
		*e = EventBreakerRuleTimestampType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for EventBreakerRuleTimestampType: %v", v)
	}
}

type Timestamp struct {
	Format *string                       `json:"format,omitempty"`
	Length *float64                      `json:"length,omitempty"`
	Type   EventBreakerRuleTimestampType `json:"type"`
}

func (o *Timestamp) GetFormat() *string {
	if o == nil {
		return nil
	}
	return o.Format
}

func (o *Timestamp) GetLength() *float64 {
	if o == nil {
		return nil
	}
	return o.Length
}

func (o *Timestamp) GetType() EventBreakerRuleTimestampType {
	if o == nil {
		return EventBreakerRuleTimestampType("")
	}
	return o.Type
}

type TimestampTimezone2 struct {
	Name    string    `json:"name"`
	Offsets []float64 `json:"offsets"`
	Untils  []float64 `json:"untils"`
}

func (o *TimestampTimezone2) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *TimestampTimezone2) GetOffsets() []float64 {
	if o == nil {
		return []float64{}
	}
	return o.Offsets
}

func (o *TimestampTimezone2) GetUntils() []float64 {
	if o == nil {
		return []float64{}
	}
	return o.Untils
}

type TimestampTimezoneType string

const (
	TimestampTimezoneTypeStr                TimestampTimezoneType = "str"
	TimestampTimezoneTypeTimestampTimezone2 TimestampTimezoneType = "timestampTimezone_2"
)

type TimestampTimezone struct {
	Str                *string             `queryParam:"inline"`
	TimestampTimezone2 *TimestampTimezone2 `queryParam:"inline"`

	Type TimestampTimezoneType
}

func CreateTimestampTimezoneStr(str string) TimestampTimezone {
	typ := TimestampTimezoneTypeStr

	return TimestampTimezone{
		Str:  &str,
		Type: typ,
	}
}

func CreateTimestampTimezoneTimestampTimezone2(timestampTimezone2 TimestampTimezone2) TimestampTimezone {
	typ := TimestampTimezoneTypeTimestampTimezone2

	return TimestampTimezone{
		TimestampTimezone2: &timestampTimezone2,
		Type:               typ,
	}
}

func (u *TimestampTimezone) UnmarshalJSON(data []byte) error {

	var timestampTimezone2 TimestampTimezone2 = TimestampTimezone2{}
	if err := utils.UnmarshalJSON(data, &timestampTimezone2, "", true, true); err == nil {
		u.TimestampTimezone2 = &timestampTimezone2
		u.Type = TimestampTimezoneTypeTimestampTimezone2
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = TimestampTimezoneTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for TimestampTimezone", string(data))
}

func (u TimestampTimezone) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.TimestampTimezone2 != nil {
		return utils.MarshalJSON(u.TimestampTimezone2, "", true)
	}

	return nil, errors.New("could not marshal union type TimestampTimezone: all fields are null")
}

type EventBreakerRuleType string

const (
	EventBreakerRuleTypeRegex         EventBreakerRuleType = "regex"
	EventBreakerRuleTypeTimestamp     EventBreakerRuleType = "timestamp"
	EventBreakerRuleTypeJSON          EventBreakerRuleType = "json"
	EventBreakerRuleTypeCsv           EventBreakerRuleType = "csv"
	EventBreakerRuleTypeJSONArray     EventBreakerRuleType = "json_array"
	EventBreakerRuleTypeHeader        EventBreakerRuleType = "header"
	EventBreakerRuleTypeAwsCloudtrail EventBreakerRuleType = "aws_cloudtrail"
	EventBreakerRuleTypeAwsVpcflow    EventBreakerRuleType = "aws_vpcflow"
)

func (e EventBreakerRuleType) ToPointer() *EventBreakerRuleType {
	return &e
}
func (e *EventBreakerRuleType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "regex":
		fallthrough
	case "timestamp":
		fallthrough
	case "json":
		fallthrough
	case "csv":
		fallthrough
	case "json_array":
		fallthrough
	case "header":
		fallthrough
	case "aws_cloudtrail":
		fallthrough
	case "aws_vpcflow":
		*e = EventBreakerRuleType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for EventBreakerRuleType: %v", v)
	}
}

type EventBreakerRule struct {
	CleanFields          *bool                    `json:"cleanFields,omitempty"`
	Condition            string                   `json:"condition"`
	Delimiter            *string                  `json:"delimiter,omitempty"`
	DelimiterRegex       *string                  `json:"delimiterRegex,omitempty"`
	Disabled             *bool                    `json:"disabled,omitempty"`
	EscapeChar           *string                  `json:"escapeChar,omitempty"`
	EventBreakerRegex    *string                  `json:"eventBreakerRegex,omitempty"`
	Fields               []EventBreakerRuleFields `json:"fields,omitempty"`
	FieldsLineRegex      *string                  `json:"fieldsLineRegex,omitempty"`
	HeaderLineRegex      *string                  `json:"headerLineRegex,omitempty"`
	Index                *float64                 `json:"index,omitempty"`
	JSONArrayField       *string                  `json:"jsonArrayField,omitempty"`
	JSONExtractAll       *bool                    `json:"jsonExtractAll,omitempty"`
	JSONTimeField        *string                  `json:"jsonTimeField,omitempty"`
	MaxEventBytes        float64                  `json:"maxEventBytes"`
	Name                 string                   `json:"name"`
	NullFieldVal         *string                  `json:"nullFieldVal,omitempty"`
	Parser               *Parser                  `json:"parser,omitempty"`
	ParserEnabled        *bool                    `json:"parserEnabled,omitempty"`
	QuoteChar            *string                  `json:"quoteChar,omitempty"`
	ShouldUseDataRaw     *bool                    `json:"shouldUseDataRaw,omitempty"`
	TimeField            *string                  `json:"timeField,omitempty"`
	Timestamp            Timestamp                `json:"timestamp"`
	TimestampAnchorRegex string                   `json:"timestampAnchorRegex"`
	TimestampEarliest    *string                  `json:"timestampEarliest,omitempty"`
	TimestampLatest      *string                  `json:"timestampLatest,omitempty"`
	TimestampTimezone    TimestampTimezone        `json:"timestampTimezone"`
	Type                 *EventBreakerRuleType    `json:"type,omitempty"`
}

func (o *EventBreakerRule) GetCleanFields() *bool {
	if o == nil {
		return nil
	}
	return o.CleanFields
}

func (o *EventBreakerRule) GetCondition() string {
	if o == nil {
		return ""
	}
	return o.Condition
}

func (o *EventBreakerRule) GetDelimiter() *string {
	if o == nil {
		return nil
	}
	return o.Delimiter
}

func (o *EventBreakerRule) GetDelimiterRegex() *string {
	if o == nil {
		return nil
	}
	return o.DelimiterRegex
}

func (o *EventBreakerRule) GetDisabled() *bool {
	if o == nil {
		return nil
	}
	return o.Disabled
}

func (o *EventBreakerRule) GetEscapeChar() *string {
	if o == nil {
		return nil
	}
	return o.EscapeChar
}

func (o *EventBreakerRule) GetEventBreakerRegex() *string {
	if o == nil {
		return nil
	}
	return o.EventBreakerRegex
}

func (o *EventBreakerRule) GetFields() []EventBreakerRuleFields {
	if o == nil {
		return nil
	}
	return o.Fields
}

func (o *EventBreakerRule) GetFieldsLineRegex() *string {
	if o == nil {
		return nil
	}
	return o.FieldsLineRegex
}

func (o *EventBreakerRule) GetHeaderLineRegex() *string {
	if o == nil {
		return nil
	}
	return o.HeaderLineRegex
}

func (o *EventBreakerRule) GetIndex() *float64 {
	if o == nil {
		return nil
	}
	return o.Index
}

func (o *EventBreakerRule) GetJSONArrayField() *string {
	if o == nil {
		return nil
	}
	return o.JSONArrayField
}

func (o *EventBreakerRule) GetJSONExtractAll() *bool {
	if o == nil {
		return nil
	}
	return o.JSONExtractAll
}

func (o *EventBreakerRule) GetJSONTimeField() *string {
	if o == nil {
		return nil
	}
	return o.JSONTimeField
}

func (o *EventBreakerRule) GetMaxEventBytes() float64 {
	if o == nil {
		return 0.0
	}
	return o.MaxEventBytes
}

func (o *EventBreakerRule) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *EventBreakerRule) GetNullFieldVal() *string {
	if o == nil {
		return nil
	}
	return o.NullFieldVal
}

func (o *EventBreakerRule) GetParser() *Parser {
	if o == nil {
		return nil
	}
	return o.Parser
}

func (o *EventBreakerRule) GetParserEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.ParserEnabled
}

func (o *EventBreakerRule) GetQuoteChar() *string {
	if o == nil {
		return nil
	}
	return o.QuoteChar
}

func (o *EventBreakerRule) GetShouldUseDataRaw() *bool {
	if o == nil {
		return nil
	}
	return o.ShouldUseDataRaw
}

func (o *EventBreakerRule) GetTimeField() *string {
	if o == nil {
		return nil
	}
	return o.TimeField
}

func (o *EventBreakerRule) GetTimestamp() Timestamp {
	if o == nil {
		return Timestamp{}
	}
	return o.Timestamp
}

func (o *EventBreakerRule) GetTimestampAnchorRegex() string {
	if o == nil {
		return ""
	}
	return o.TimestampAnchorRegex
}

func (o *EventBreakerRule) GetTimestampEarliest() *string {
	if o == nil {
		return nil
	}
	return o.TimestampEarliest
}

func (o *EventBreakerRule) GetTimestampLatest() *string {
	if o == nil {
		return nil
	}
	return o.TimestampLatest
}

func (o *EventBreakerRule) GetTimestampTimezone() TimestampTimezone {
	if o == nil {
		return TimestampTimezone{}
	}
	return o.TimestampTimezone
}

func (o *EventBreakerRule) GetType() *EventBreakerRuleType {
	if o == nil {
		return nil
	}
	return o.Type
}
