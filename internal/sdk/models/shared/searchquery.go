// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy/terraform-provider-cribl-terraform/internal/sdk/internal/utils"
)

type SearchQuery3Type string

const (
	SearchQuery3TypeValues SearchQuery3Type = "values"
)

func (e SearchQuery3Type) ToPointer() *SearchQuery3Type {
	return &e
}
func (e *SearchQuery3Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "values":
		*e = SearchQuery3Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SearchQuery3Type: %v", v)
	}
}

type SearchQuery3 struct {
	Type   SearchQuery3Type `json:"type"`
	Values []string         `json:"values"`
}

func (o *SearchQuery3) GetType() SearchQuery3Type {
	if o == nil {
		return SearchQuery3Type("")
	}
	return o.Type
}

func (o *SearchQuery3) GetValues() []string {
	if o == nil {
		return []string{}
	}
	return o.Values
}

type SearchQueryEarliestType string

const (
	SearchQueryEarliestTypeStr    SearchQueryEarliestType = "str"
	SearchQueryEarliestTypeNumber SearchQueryEarliestType = "number"
)

type SearchQueryEarliest struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type SearchQueryEarliestType
}

func CreateSearchQueryEarliestStr(str string) SearchQueryEarliest {
	typ := SearchQueryEarliestTypeStr

	return SearchQueryEarliest{
		Str:  &str,
		Type: typ,
	}
}

func CreateSearchQueryEarliestNumber(number float64) SearchQueryEarliest {
	typ := SearchQueryEarliestTypeNumber

	return SearchQueryEarliest{
		Number: &number,
		Type:   typ,
	}
}

func (u *SearchQueryEarliest) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = SearchQueryEarliestTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = &number
		u.Type = SearchQueryEarliestTypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SearchQueryEarliest", string(data))
}

func (u SearchQueryEarliest) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type SearchQueryEarliest: all fields are null")
}

type SearchQueryLatestType string

const (
	SearchQueryLatestTypeStr    SearchQueryLatestType = "str"
	SearchQueryLatestTypeNumber SearchQueryLatestType = "number"
)

type SearchQueryLatest struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type SearchQueryLatestType
}

func CreateSearchQueryLatestStr(str string) SearchQueryLatest {
	typ := SearchQueryLatestTypeStr

	return SearchQueryLatest{
		Str:  &str,
		Type: typ,
	}
}

func CreateSearchQueryLatestNumber(number float64) SearchQueryLatest {
	typ := SearchQueryLatestTypeNumber

	return SearchQueryLatest{
		Number: &number,
		Type:   typ,
	}
}

func (u *SearchQueryLatest) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = SearchQueryLatestTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = &number
		u.Type = SearchQueryLatestTypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SearchQueryLatest", string(data))
}

func (u SearchQueryLatest) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type SearchQueryLatest: all fields are null")
}

type SearchQuery2Type string

const (
	SearchQuery2TypeInline SearchQuery2Type = "inline"
)

func (e SearchQuery2Type) ToPointer() *SearchQuery2Type {
	return &e
}
func (e *SearchQuery2Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "inline":
		*e = SearchQuery2Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SearchQuery2Type: %v", v)
	}
}

type SearchQuery2 struct {
	Earliest       *SearchQueryEarliest `json:"earliest"`
	Latest         *SearchQueryLatest   `json:"latest"`
	ParentSearchID *string              `json:"parentSearchId,omitempty"`
	Query          *string              `json:"query"`
	SampleRate     *float64             `json:"sampleRate,omitempty"`
	Timezone       *string              `json:"timezone,omitempty"`
	Type           SearchQuery2Type     `json:"type"`
}

func (o *SearchQuery2) GetEarliest() *SearchQueryEarliest {
	if o == nil {
		return nil
	}
	return o.Earliest
}

func (o *SearchQuery2) GetLatest() *SearchQueryLatest {
	if o == nil {
		return nil
	}
	return o.Latest
}

func (o *SearchQuery2) GetParentSearchID() *string {
	if o == nil {
		return nil
	}
	return o.ParentSearchID
}

func (o *SearchQuery2) GetQuery() *string {
	if o == nil {
		return nil
	}
	return o.Query
}

func (o *SearchQuery2) GetSampleRate() *float64 {
	if o == nil {
		return nil
	}
	return o.SampleRate
}

func (o *SearchQuery2) GetTimezone() *string {
	if o == nil {
		return nil
	}
	return o.Timezone
}

func (o *SearchQuery2) GetType() SearchQuery2Type {
	if o == nil {
		return SearchQuery2Type("")
	}
	return o.Type
}

type SearchQueryType string

const (
	SearchQueryTypeSaved SearchQueryType = "saved"
)

func (e SearchQueryType) ToPointer() *SearchQueryType {
	return &e
}
func (e *SearchQueryType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "saved":
		*e = SearchQueryType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SearchQueryType: %v", v)
	}
}

type SearchQuery1 struct {
	Query   *string             `json:"query,omitempty"`
	QueryID string              `json:"queryId"`
	RunMode *SavesSearchRunMode `json:"runMode,omitempty"`
	Type    SearchQueryType     `json:"type"`
}

func (o *SearchQuery1) GetQuery() *string {
	if o == nil {
		return nil
	}
	return o.Query
}

func (o *SearchQuery1) GetQueryID() string {
	if o == nil {
		return ""
	}
	return o.QueryID
}

func (o *SearchQuery1) GetRunMode() *SavesSearchRunMode {
	if o == nil {
		return nil
	}
	return o.RunMode
}

func (o *SearchQuery1) GetType() SearchQueryType {
	if o == nil {
		return SearchQueryType("")
	}
	return o.Type
}

type SearchQueryUnionType string

const (
	SearchQueryUnionTypeSearchQuery1 SearchQueryUnionType = "SearchQuery_1"
	SearchQueryUnionTypeSearchQuery2 SearchQueryUnionType = "SearchQuery_2"
	SearchQueryUnionTypeSearchQuery3 SearchQueryUnionType = "SearchQuery_3"
)

type SearchQuery struct {
	SearchQuery1 *SearchQuery1 `queryParam:"inline"`
	SearchQuery2 *SearchQuery2 `queryParam:"inline"`
	SearchQuery3 *SearchQuery3 `queryParam:"inline"`

	Type SearchQueryUnionType
}

func CreateSearchQuerySearchQuery1(searchQuery1 SearchQuery1) SearchQuery {
	typ := SearchQueryUnionTypeSearchQuery1

	return SearchQuery{
		SearchQuery1: &searchQuery1,
		Type:         typ,
	}
}

func CreateSearchQuerySearchQuery2(searchQuery2 SearchQuery2) SearchQuery {
	typ := SearchQueryUnionTypeSearchQuery2

	return SearchQuery{
		SearchQuery2: &searchQuery2,
		Type:         typ,
	}
}

func CreateSearchQuerySearchQuery3(searchQuery3 SearchQuery3) SearchQuery {
	typ := SearchQueryUnionTypeSearchQuery3

	return SearchQuery{
		SearchQuery3: &searchQuery3,
		Type:         typ,
	}
}

func (u *SearchQuery) UnmarshalJSON(data []byte) error {

	var searchQuery3 SearchQuery3 = SearchQuery3{}
	if err := utils.UnmarshalJSON(data, &searchQuery3, "", true, true); err == nil {
		u.SearchQuery3 = &searchQuery3
		u.Type = SearchQueryUnionTypeSearchQuery3
		return nil
	}

	var searchQuery1 SearchQuery1 = SearchQuery1{}
	if err := utils.UnmarshalJSON(data, &searchQuery1, "", true, true); err == nil {
		u.SearchQuery1 = &searchQuery1
		u.Type = SearchQueryUnionTypeSearchQuery1
		return nil
	}

	var searchQuery2 SearchQuery2 = SearchQuery2{}
	if err := utils.UnmarshalJSON(data, &searchQuery2, "", true, true); err == nil {
		u.SearchQuery2 = &searchQuery2
		u.Type = SearchQueryUnionTypeSearchQuery2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SearchQuery", string(data))
}

func (u SearchQuery) MarshalJSON() ([]byte, error) {
	if u.SearchQuery1 != nil {
		return utils.MarshalJSON(u.SearchQuery1, "", true)
	}

	if u.SearchQuery2 != nil {
		return utils.MarshalJSON(u.SearchQuery2, "", true)
	}

	if u.SearchQuery3 != nil {
		return utils.MarshalJSON(u.SearchQuery3, "", true)
	}

	return nil, errors.New("could not marshal union type SearchQuery: all fields are null")
}
