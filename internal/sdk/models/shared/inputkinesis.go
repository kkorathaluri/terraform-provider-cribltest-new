// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/speakeasy/terraform-provider-cribl-terraform/internal/sdk/internal/utils"
)

type InputKinesisType string

const (
	InputKinesisTypeKinesis InputKinesisType = "kinesis"
)

func (e InputKinesisType) ToPointer() *InputKinesisType {
	return &e
}
func (e *InputKinesisType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "kinesis":
		*e = InputKinesisType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputKinesisType: %v", v)
	}
}

type InputKinesisConnections struct {
	Pipeline *string `json:"pipeline,omitempty"`
	Output   string  `json:"output"`
}

func (o *InputKinesisConnections) GetPipeline() *string {
	if o == nil {
		return nil
	}
	return o.Pipeline
}

func (o *InputKinesisConnections) GetOutput() string {
	if o == nil {
		return ""
	}
	return o.Output
}

// InputKinesisMode - With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputKinesisMode string

const (
	InputKinesisModeSmart  InputKinesisMode = "smart"
	InputKinesisModeAlways InputKinesisMode = "always"
)

func (e InputKinesisMode) ToPointer() *InputKinesisMode {
	return &e
}
func (e *InputKinesisMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "smart":
		fallthrough
	case "always":
		*e = InputKinesisMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputKinesisMode: %v", v)
	}
}

// InputKinesisCompression - Codec to use to compress the persisted data
type InputKinesisCompression string

const (
	InputKinesisCompressionNone InputKinesisCompression = "none"
	InputKinesisCompressionGzip InputKinesisCompression = "gzip"
)

func (e InputKinesisCompression) ToPointer() *InputKinesisCompression {
	return &e
}
func (e *InputKinesisCompression) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "gzip":
		*e = InputKinesisCompression(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputKinesisCompression: %v", v)
	}
}

type InputKinesisPq struct {
	// With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
	Mode *InputKinesisMode `default:"always" json:"mode"`
	// The maximum number of events to hold in memory before writing the events to disk
	MaxBufferSize *float64 `default:"1000" json:"maxBufferSize"`
	// The number of events to send downstream before committing that Stream has read them
	CommitFrequency *float64 `default:"42" json:"commitFrequency"`
	// The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
	MaxFileSize *string `default:"1 MB" json:"maxFileSize"`
	// The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	MaxSize *string `default:"5GB" json:"maxSize"`
	// The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
	Path *string `default:"\\$CRIBL_HOME/state/queues" json:"path"`
	// Codec to use to compress the persisted data
	Compress *InputKinesisCompression `default:"none" json:"compress"`
}

func (i InputKinesisPq) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKinesisPq) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *InputKinesisPq) GetMode() *InputKinesisMode {
	if o == nil {
		return nil
	}
	return o.Mode
}

func (o *InputKinesisPq) GetMaxBufferSize() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxBufferSize
}

func (o *InputKinesisPq) GetCommitFrequency() *float64 {
	if o == nil {
		return nil
	}
	return o.CommitFrequency
}

func (o *InputKinesisPq) GetMaxFileSize() *string {
	if o == nil {
		return nil
	}
	return o.MaxFileSize
}

func (o *InputKinesisPq) GetMaxSize() *string {
	if o == nil {
		return nil
	}
	return o.MaxSize
}

func (o *InputKinesisPq) GetPath() *string {
	if o == nil {
		return nil
	}
	return o.Path
}

func (o *InputKinesisPq) GetCompress() *InputKinesisCompression {
	if o == nil {
		return nil
	}
	return o.Compress
}

// ShardIteratorStart - Location at which to start reading a shard for the first time.
type ShardIteratorStart string

const (
	ShardIteratorStartTrimHorizon ShardIteratorStart = "TRIM_HORIZON"
	ShardIteratorStartLatest      ShardIteratorStart = "LATEST"
)

func (e ShardIteratorStart) ToPointer() *ShardIteratorStart {
	return &e
}
func (e *ShardIteratorStart) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TRIM_HORIZON":
		fallthrough
	case "LATEST":
		*e = ShardIteratorStart(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ShardIteratorStart: %v", v)
	}
}

// RecordDataFormat - Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
type RecordDataFormat string

const (
	RecordDataFormatCribl      RecordDataFormat = "cribl"
	RecordDataFormatNdjson     RecordDataFormat = "ndjson"
	RecordDataFormatCloudwatch RecordDataFormat = "cloudwatch"
	RecordDataFormatLine       RecordDataFormat = "line"
)

func (e RecordDataFormat) ToPointer() *RecordDataFormat {
	return &e
}
func (e *RecordDataFormat) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cribl":
		fallthrough
	case "ndjson":
		fallthrough
	case "cloudwatch":
		fallthrough
	case "line":
		*e = RecordDataFormat(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RecordDataFormat: %v", v)
	}
}

// ShardLoadBalancing - The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
type ShardLoadBalancing string

const (
	ShardLoadBalancingConsistentHashing ShardLoadBalancing = "ConsistentHashing"
	ShardLoadBalancingRoundRobin        ShardLoadBalancing = "RoundRobin"
)

func (e ShardLoadBalancing) ToPointer() *ShardLoadBalancing {
	return &e
}
func (e *ShardLoadBalancing) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ConsistentHashing":
		fallthrough
	case "RoundRobin":
		*e = ShardLoadBalancing(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ShardLoadBalancing: %v", v)
	}
}

// InputKinesisAuthenticationMethod - AWS authentication method. Choose Auto to use IAM roles.
type InputKinesisAuthenticationMethod string

const (
	InputKinesisAuthenticationMethodAuto   InputKinesisAuthenticationMethod = "auto"
	InputKinesisAuthenticationMethodManual InputKinesisAuthenticationMethod = "manual"
	InputKinesisAuthenticationMethodSecret InputKinesisAuthenticationMethod = "secret"
)

func (e InputKinesisAuthenticationMethod) ToPointer() *InputKinesisAuthenticationMethod {
	return &e
}
func (e *InputKinesisAuthenticationMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "auto":
		fallthrough
	case "manual":
		fallthrough
	case "secret":
		*e = InputKinesisAuthenticationMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputKinesisAuthenticationMethod: %v", v)
	}
}

// InputKinesisSignatureVersion - Signature version to use for signing Kinesis stream requests
type InputKinesisSignatureVersion string

const (
	InputKinesisSignatureVersionV2 InputKinesisSignatureVersion = "v2"
	InputKinesisSignatureVersionV4 InputKinesisSignatureVersion = "v4"
)

func (e InputKinesisSignatureVersion) ToPointer() *InputKinesisSignatureVersion {
	return &e
}
func (e *InputKinesisSignatureVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "v2":
		fallthrough
	case "v4":
		*e = InputKinesisSignatureVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputKinesisSignatureVersion: %v", v)
	}
}

type InputKinesisMetadata struct {
	Name string `json:"name"`
	// JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
	Value string `json:"value"`
}

func (o *InputKinesisMetadata) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *InputKinesisMetadata) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type InputKinesis struct {
	// Unique ID for this input
	ID       *string           `json:"id,omitempty"`
	Type     *InputKinesisType `json:"type,omitempty"`
	Disabled *bool             `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []InputKinesisConnections `json:"connections,omitempty"`
	Pq          *InputKinesisPq           `json:"pq,omitempty"`
	// Kinesis stream name to read data from.
	StreamName string `json:"streamName"`
	// Time interval in minutes between consecutive service calls
	ServiceInterval *float64 `default:"1" json:"serviceInterval"`
	// A JS expression to be called with each shardId for the stream, if the expression evalutates to a truthy value the shard will be processed.
	ShardExpr *string `default:"true" json:"shardExpr"`
	// Location at which to start reading a shard for the first time.
	ShardIteratorType *ShardIteratorStart `default:"TRIM_HORIZON" json:"shardIteratorType"`
	// Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
	PayloadFormat *RecordDataFormat `default:"cribl" json:"payloadFormat"`
	// Maximum number of records per getRecords call
	GetRecordsLimit *float64 `default:"5000" json:"getRecordsLimit"`
	// Maximum number of records, across all shards, to pull down at once per Worker Process
	GetRecordsLimitTotal *float64 `default:"20000" json:"getRecordsLimitTotal"`
	// The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
	LoadBalancingAlgorithm *ShardLoadBalancing `default:"ConsistentHashing" json:"loadBalancingAlgorithm"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *InputKinesisAuthenticationMethod `default:"auto" json:"awsAuthenticationMethod"`
	// Secret key
	AwsSecretKey *string `json:"awsSecretKey,omitempty"`
	// Region where the Kinesis stream is located
	Region string `json:"region"`
	// Kinesis stream service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing Kinesis stream requests
	SignatureVersion *InputKinesisSignatureVersion `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Use Assume Role credentials to access Kinesis stream
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Verify Kinesis Producer Library (KPL) event checksums
	VerifyKPLCheckSums *bool `default:"false" json:"verifyKPLCheckSums"`
	// Yes means: when resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this can cause data loss after a Worker Node's unexpected shutdown or restart.
	AvoidDuplicates *bool `default:"false" json:"avoidDuplicates"`
	// Fields to add to events from this input
	Metadata    []InputKinesisMetadata `json:"metadata,omitempty"`
	Description *string                `json:"description,omitempty"`
	// Access key
	AwsAPIKey *string `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key.
	AwsSecret *string `json:"awsSecret,omitempty"`
}

func (i InputKinesis) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKinesis) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *InputKinesis) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *InputKinesis) GetType() *InputKinesisType {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *InputKinesis) GetDisabled() *bool {
	if o == nil {
		return nil
	}
	return o.Disabled
}

func (o *InputKinesis) GetPipeline() *string {
	if o == nil {
		return nil
	}
	return o.Pipeline
}

func (o *InputKinesis) GetSendToRoutes() *bool {
	if o == nil {
		return nil
	}
	return o.SendToRoutes
}

func (o *InputKinesis) GetEnvironment() *string {
	if o == nil {
		return nil
	}
	return o.Environment
}

func (o *InputKinesis) GetPqEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.PqEnabled
}

func (o *InputKinesis) GetStreamtags() []string {
	if o == nil {
		return nil
	}
	return o.Streamtags
}

func (o *InputKinesis) GetConnections() []InputKinesisConnections {
	if o == nil {
		return nil
	}
	return o.Connections
}

func (o *InputKinesis) GetPq() *InputKinesisPq {
	if o == nil {
		return nil
	}
	return o.Pq
}

func (o *InputKinesis) GetStreamName() string {
	if o == nil {
		return ""
	}
	return o.StreamName
}

func (o *InputKinesis) GetServiceInterval() *float64 {
	if o == nil {
		return nil
	}
	return o.ServiceInterval
}

func (o *InputKinesis) GetShardExpr() *string {
	if o == nil {
		return nil
	}
	return o.ShardExpr
}

func (o *InputKinesis) GetShardIteratorType() *ShardIteratorStart {
	if o == nil {
		return nil
	}
	return o.ShardIteratorType
}

func (o *InputKinesis) GetPayloadFormat() *RecordDataFormat {
	if o == nil {
		return nil
	}
	return o.PayloadFormat
}

func (o *InputKinesis) GetGetRecordsLimit() *float64 {
	if o == nil {
		return nil
	}
	return o.GetRecordsLimit
}

func (o *InputKinesis) GetGetRecordsLimitTotal() *float64 {
	if o == nil {
		return nil
	}
	return o.GetRecordsLimitTotal
}

func (o *InputKinesis) GetLoadBalancingAlgorithm() *ShardLoadBalancing {
	if o == nil {
		return nil
	}
	return o.LoadBalancingAlgorithm
}

func (o *InputKinesis) GetAwsAuthenticationMethod() *InputKinesisAuthenticationMethod {
	if o == nil {
		return nil
	}
	return o.AwsAuthenticationMethod
}

func (o *InputKinesis) GetAwsSecretKey() *string {
	if o == nil {
		return nil
	}
	return o.AwsSecretKey
}

func (o *InputKinesis) GetRegion() string {
	if o == nil {
		return ""
	}
	return o.Region
}

func (o *InputKinesis) GetEndpoint() *string {
	if o == nil {
		return nil
	}
	return o.Endpoint
}

func (o *InputKinesis) GetSignatureVersion() *InputKinesisSignatureVersion {
	if o == nil {
		return nil
	}
	return o.SignatureVersion
}

func (o *InputKinesis) GetReuseConnections() *bool {
	if o == nil {
		return nil
	}
	return o.ReuseConnections
}

func (o *InputKinesis) GetRejectUnauthorized() *bool {
	if o == nil {
		return nil
	}
	return o.RejectUnauthorized
}

func (o *InputKinesis) GetEnableAssumeRole() *bool {
	if o == nil {
		return nil
	}
	return o.EnableAssumeRole
}

func (o *InputKinesis) GetAssumeRoleArn() *string {
	if o == nil {
		return nil
	}
	return o.AssumeRoleArn
}

func (o *InputKinesis) GetAssumeRoleExternalID() *string {
	if o == nil {
		return nil
	}
	return o.AssumeRoleExternalID
}

func (o *InputKinesis) GetDurationSeconds() *float64 {
	if o == nil {
		return nil
	}
	return o.DurationSeconds
}

func (o *InputKinesis) GetVerifyKPLCheckSums() *bool {
	if o == nil {
		return nil
	}
	return o.VerifyKPLCheckSums
}

func (o *InputKinesis) GetAvoidDuplicates() *bool {
	if o == nil {
		return nil
	}
	return o.AvoidDuplicates
}

func (o *InputKinesis) GetMetadata() []InputKinesisMetadata {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *InputKinesis) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *InputKinesis) GetAwsAPIKey() *string {
	if o == nil {
		return nil
	}
	return o.AwsAPIKey
}

func (o *InputKinesis) GetAwsSecret() *string {
	if o == nil {
		return nil
	}
	return o.AwsSecret
}
