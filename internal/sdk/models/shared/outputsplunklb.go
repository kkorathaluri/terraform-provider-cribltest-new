// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/speakeasy/terraform-provider-cribl-terraform/internal/sdk/internal/utils"
)

type OutputSplunkLbType string

const (
	OutputSplunkLbTypeSplunkLb OutputSplunkLbType = "splunk_lb"
)

func (e OutputSplunkLbType) ToPointer() *OutputSplunkLbType {
	return &e
}
func (e *OutputSplunkLbType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "splunk_lb":
		*e = OutputSplunkLbType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSplunkLbType: %v", v)
	}
}

// OutputSplunkLbNestedFieldSerialization - How to serialize nested fields into index-time fields
type OutputSplunkLbNestedFieldSerialization string

const (
	OutputSplunkLbNestedFieldSerializationJSON OutputSplunkLbNestedFieldSerialization = "json"
	OutputSplunkLbNestedFieldSerializationNone OutputSplunkLbNestedFieldSerialization = "none"
)

func (e OutputSplunkLbNestedFieldSerialization) ToPointer() *OutputSplunkLbNestedFieldSerialization {
	return &e
}
func (e *OutputSplunkLbNestedFieldSerialization) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "json":
		fallthrough
	case "none":
		*e = OutputSplunkLbNestedFieldSerialization(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSplunkLbNestedFieldSerialization: %v", v)
	}
}

// OutputSplunkLbMinimumTLSVersion - Minimum TLS version to use when connecting
type OutputSplunkLbMinimumTLSVersion string

const (
	OutputSplunkLbMinimumTLSVersionTlSv1  OutputSplunkLbMinimumTLSVersion = "TLSv1"
	OutputSplunkLbMinimumTLSVersionTlSv11 OutputSplunkLbMinimumTLSVersion = "TLSv1.1"
	OutputSplunkLbMinimumTLSVersionTlSv12 OutputSplunkLbMinimumTLSVersion = "TLSv1.2"
	OutputSplunkLbMinimumTLSVersionTlSv13 OutputSplunkLbMinimumTLSVersion = "TLSv1.3"
)

func (e OutputSplunkLbMinimumTLSVersion) ToPointer() *OutputSplunkLbMinimumTLSVersion {
	return &e
}
func (e *OutputSplunkLbMinimumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = OutputSplunkLbMinimumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSplunkLbMinimumTLSVersion: %v", v)
	}
}

// OutputSplunkLbMaximumTLSVersion - Maximum TLS version to use when connecting
type OutputSplunkLbMaximumTLSVersion string

const (
	OutputSplunkLbMaximumTLSVersionTlSv1  OutputSplunkLbMaximumTLSVersion = "TLSv1"
	OutputSplunkLbMaximumTLSVersionTlSv11 OutputSplunkLbMaximumTLSVersion = "TLSv1.1"
	OutputSplunkLbMaximumTLSVersionTlSv12 OutputSplunkLbMaximumTLSVersion = "TLSv1.2"
	OutputSplunkLbMaximumTLSVersionTlSv13 OutputSplunkLbMaximumTLSVersion = "TLSv1.3"
)

func (e OutputSplunkLbMaximumTLSVersion) ToPointer() *OutputSplunkLbMaximumTLSVersion {
	return &e
}
func (e *OutputSplunkLbMaximumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = OutputSplunkLbMaximumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSplunkLbMaximumTLSVersion: %v", v)
	}
}

type OutputSplunkLbTLSSettingsClientSide struct {
	Disabled *bool `default:"true" json:"disabled"`
	// Reject certs that are not authorized by a CA in the CA certificate path, or by another
	//                     trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
	Servername *string `json:"servername,omitempty"`
	// The name of the predefined certificate.
	CertificateName *string `json:"certificateName,omitempty"`
	// Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
	CaPath *string `json:"caPath,omitempty"`
	// Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
	PrivKeyPath *string `json:"privKeyPath,omitempty"`
	// Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
	CertPath *string `json:"certPath,omitempty"`
	// Passphrase to use to decrypt private key.
	Passphrase *string `json:"passphrase,omitempty"`
	// Minimum TLS version to use when connecting
	MinVersion *OutputSplunkLbMinimumTLSVersion `json:"minVersion,omitempty"`
	// Maximum TLS version to use when connecting
	MaxVersion *OutputSplunkLbMaximumTLSVersion `json:"maxVersion,omitempty"`
}

func (o OutputSplunkLbTLSSettingsClientSide) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OutputSplunkLbTLSSettingsClientSide) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *OutputSplunkLbTLSSettingsClientSide) GetDisabled() *bool {
	if o == nil {
		return nil
	}
	return o.Disabled
}

func (o *OutputSplunkLbTLSSettingsClientSide) GetRejectUnauthorized() *bool {
	if o == nil {
		return nil
	}
	return o.RejectUnauthorized
}

func (o *OutputSplunkLbTLSSettingsClientSide) GetServername() *string {
	if o == nil {
		return nil
	}
	return o.Servername
}

func (o *OutputSplunkLbTLSSettingsClientSide) GetCertificateName() *string {
	if o == nil {
		return nil
	}
	return o.CertificateName
}

func (o *OutputSplunkLbTLSSettingsClientSide) GetCaPath() *string {
	if o == nil {
		return nil
	}
	return o.CaPath
}

func (o *OutputSplunkLbTLSSettingsClientSide) GetPrivKeyPath() *string {
	if o == nil {
		return nil
	}
	return o.PrivKeyPath
}

func (o *OutputSplunkLbTLSSettingsClientSide) GetCertPath() *string {
	if o == nil {
		return nil
	}
	return o.CertPath
}

func (o *OutputSplunkLbTLSSettingsClientSide) GetPassphrase() *string {
	if o == nil {
		return nil
	}
	return o.Passphrase
}

func (o *OutputSplunkLbTLSSettingsClientSide) GetMinVersion() *OutputSplunkLbMinimumTLSVersion {
	if o == nil {
		return nil
	}
	return o.MinVersion
}

func (o *OutputSplunkLbTLSSettingsClientSide) GetMaxVersion() *OutputSplunkLbMaximumTLSVersion {
	if o == nil {
		return nil
	}
	return o.MaxVersion
}

// OutputSplunkLbMaxS2SVersion - The highest S2S protocol version to advertise during handshake
type OutputSplunkLbMaxS2SVersion string

const (
	OutputSplunkLbMaxS2SVersionV3 OutputSplunkLbMaxS2SVersion = "v3"
	OutputSplunkLbMaxS2SVersionV4 OutputSplunkLbMaxS2SVersion = "v4"
)

func (e OutputSplunkLbMaxS2SVersion) ToPointer() *OutputSplunkLbMaxS2SVersion {
	return &e
}
func (e *OutputSplunkLbMaxS2SVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "v3":
		fallthrough
	case "v4":
		*e = OutputSplunkLbMaxS2SVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSplunkLbMaxS2SVersion: %v", v)
	}
}

// OutputSplunkLbBackpressureBehavior - Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputSplunkLbBackpressureBehavior string

const (
	OutputSplunkLbBackpressureBehaviorBlock OutputSplunkLbBackpressureBehavior = "block"
	OutputSplunkLbBackpressureBehaviorDrop  OutputSplunkLbBackpressureBehavior = "drop"
	OutputSplunkLbBackpressureBehaviorQueue OutputSplunkLbBackpressureBehavior = "queue"
)

func (e OutputSplunkLbBackpressureBehavior) ToPointer() *OutputSplunkLbBackpressureBehavior {
	return &e
}
func (e *OutputSplunkLbBackpressureBehavior) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "block":
		fallthrough
	case "drop":
		fallthrough
	case "queue":
		*e = OutputSplunkLbBackpressureBehavior(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSplunkLbBackpressureBehavior: %v", v)
	}
}

// OutputSplunkLbAuthenticationMethod - Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
type OutputSplunkLbAuthenticationMethod string

const (
	OutputSplunkLbAuthenticationMethodManual OutputSplunkLbAuthenticationMethod = "manual"
	OutputSplunkLbAuthenticationMethodSecret OutputSplunkLbAuthenticationMethod = "secret"
)

func (e OutputSplunkLbAuthenticationMethod) ToPointer() *OutputSplunkLbAuthenticationMethod {
	return &e
}
func (e *OutputSplunkLbAuthenticationMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "manual":
		fallthrough
	case "secret":
		*e = OutputSplunkLbAuthenticationMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSplunkLbAuthenticationMethod: %v", v)
	}
}

// OutputSplunkLbIndexerDiscoveryConfigsAuthTokensAuthenticationMethod - Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
type OutputSplunkLbIndexerDiscoveryConfigsAuthTokensAuthenticationMethod string

const (
	OutputSplunkLbIndexerDiscoveryConfigsAuthTokensAuthenticationMethodManual OutputSplunkLbIndexerDiscoveryConfigsAuthTokensAuthenticationMethod = "manual"
	OutputSplunkLbIndexerDiscoveryConfigsAuthTokensAuthenticationMethodSecret OutputSplunkLbIndexerDiscoveryConfigsAuthTokensAuthenticationMethod = "secret"
)

func (e OutputSplunkLbIndexerDiscoveryConfigsAuthTokensAuthenticationMethod) ToPointer() *OutputSplunkLbIndexerDiscoveryConfigsAuthTokensAuthenticationMethod {
	return &e
}
func (e *OutputSplunkLbIndexerDiscoveryConfigsAuthTokensAuthenticationMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "manual":
		fallthrough
	case "secret":
		*e = OutputSplunkLbIndexerDiscoveryConfigsAuthTokensAuthenticationMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSplunkLbIndexerDiscoveryConfigsAuthTokensAuthenticationMethod: %v", v)
	}
}

type OutputSplunkLbAuthTokens struct {
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType *OutputSplunkLbIndexerDiscoveryConfigsAuthTokensAuthenticationMethod `default:"manual" json:"authType"`
}

func (o OutputSplunkLbAuthTokens) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OutputSplunkLbAuthTokens) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *OutputSplunkLbAuthTokens) GetAuthType() *OutputSplunkLbIndexerDiscoveryConfigsAuthTokensAuthenticationMethod {
	if o == nil {
		return nil
	}
	return o.AuthType
}

// OutputSplunkLbIndexerDiscoveryConfigsAuthenticationMethod - Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
type OutputSplunkLbIndexerDiscoveryConfigsAuthenticationMethod string

const (
	OutputSplunkLbIndexerDiscoveryConfigsAuthenticationMethodManual OutputSplunkLbIndexerDiscoveryConfigsAuthenticationMethod = "manual"
	OutputSplunkLbIndexerDiscoveryConfigsAuthenticationMethodSecret OutputSplunkLbIndexerDiscoveryConfigsAuthenticationMethod = "secret"
)

func (e OutputSplunkLbIndexerDiscoveryConfigsAuthenticationMethod) ToPointer() *OutputSplunkLbIndexerDiscoveryConfigsAuthenticationMethod {
	return &e
}
func (e *OutputSplunkLbIndexerDiscoveryConfigsAuthenticationMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "manual":
		fallthrough
	case "secret":
		*e = OutputSplunkLbIndexerDiscoveryConfigsAuthenticationMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSplunkLbIndexerDiscoveryConfigsAuthenticationMethod: %v", v)
	}
}

// IndexerDiscoveryConfigs - List of configurations to set up indexer discovery in Splunk Indexer clustering environment.
type IndexerDiscoveryConfigs struct {
	// Clustering site of the indexers from where indexers need to be discovered. In case of single site cluster, it defaults to 'default' site.
	Site *string `default:"default" json:"site"`
	// Full URI of Splunk cluster manager (scheme://host:port). Example: https://managerAddress:8089
	MasterURI string `json:"masterUri"`
	// Time interval, in seconds, between two consecutive indexer list fetches from cluster manager
	RefreshIntervalSec *float64 `default:"300" json:"refreshIntervalSec"`
	// During indexer discovery, reject cluster manager certificates that are not authorized by the system's CA. Disable to allow untrusted (for example, self-signed) certificates.
	RejectUnauthorized *bool `default:"false" json:"rejectUnauthorized"`
	// Tokens required to authenticate to cluster manager for indexer discovery
	AuthTokens []OutputSplunkLbAuthTokens `json:"authTokens,omitempty"`
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType *OutputSplunkLbIndexerDiscoveryConfigsAuthenticationMethod `default:"manual" json:"authType"`
	// Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
	AuthToken *string `default:"" json:"authToken"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (i IndexerDiscoveryConfigs) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *IndexerDiscoveryConfigs) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *IndexerDiscoveryConfigs) GetSite() *string {
	if o == nil {
		return nil
	}
	return o.Site
}

func (o *IndexerDiscoveryConfigs) GetMasterURI() string {
	if o == nil {
		return ""
	}
	return o.MasterURI
}

func (o *IndexerDiscoveryConfigs) GetRefreshIntervalSec() *float64 {
	if o == nil {
		return nil
	}
	return o.RefreshIntervalSec
}

func (o *IndexerDiscoveryConfigs) GetRejectUnauthorized() *bool {
	if o == nil {
		return nil
	}
	return o.RejectUnauthorized
}

func (o *IndexerDiscoveryConfigs) GetAuthTokens() []OutputSplunkLbAuthTokens {
	if o == nil {
		return nil
	}
	return o.AuthTokens
}

func (o *IndexerDiscoveryConfigs) GetAuthType() *OutputSplunkLbIndexerDiscoveryConfigsAuthenticationMethod {
	if o == nil {
		return nil
	}
	return o.AuthType
}

func (o *IndexerDiscoveryConfigs) GetAuthToken() *string {
	if o == nil {
		return nil
	}
	return o.AuthToken
}

func (o *IndexerDiscoveryConfigs) GetTextSecret() *string {
	if o == nil {
		return nil
	}
	return o.TextSecret
}

// OutputSplunkLbTLS - Whether to inherit TLS configs from group setting or disable TLS.
type OutputSplunkLbTLS string

const (
	OutputSplunkLbTLSInherit OutputSplunkLbTLS = "inherit"
	OutputSplunkLbTLSOff     OutputSplunkLbTLS = "off"
)

func (e OutputSplunkLbTLS) ToPointer() *OutputSplunkLbTLS {
	return &e
}
func (e *OutputSplunkLbTLS) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "inherit":
		fallthrough
	case "off":
		*e = OutputSplunkLbTLS(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSplunkLbTLS: %v", v)
	}
}

type Hosts struct {
	// The hostname of the receiver.
	Host string `json:"host"`
	// The port to connect to on the provided host.
	Port *float64 `default:"9997" json:"port"`
	// Whether to inherit TLS configs from group setting or disable TLS.
	TLS *OutputSplunkLbTLS `default:"inherit" json:"tls"`
	// Servername to use if establishing a TLS connection. If not specified, defaults to connection host (iff not an IP); otherwise, to the global TLS settings.
	Servername *string `json:"servername,omitempty"`
	// Assign a weight (>0) to each endpoint to indicate its traffic-handling capability
	Weight *float64 `default:"1" json:"weight"`
}

func (h Hosts) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(h, "", false)
}

func (h *Hosts) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &h, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *Hosts) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *Hosts) GetPort() *float64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *Hosts) GetTLS() *OutputSplunkLbTLS {
	if o == nil {
		return nil
	}
	return o.TLS
}

func (o *Hosts) GetServername() *string {
	if o == nil {
		return nil
	}
	return o.Servername
}

func (o *Hosts) GetWeight() *float64 {
	if o == nil {
		return nil
	}
	return o.Weight
}

// OutputSplunkLbCompression - Codec to use to compress the persisted data.
type OutputSplunkLbCompression string

const (
	OutputSplunkLbCompressionNone OutputSplunkLbCompression = "none"
	OutputSplunkLbCompressionGzip OutputSplunkLbCompression = "gzip"
)

func (e OutputSplunkLbCompression) ToPointer() *OutputSplunkLbCompression {
	return &e
}
func (e *OutputSplunkLbCompression) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "gzip":
		*e = OutputSplunkLbCompression(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSplunkLbCompression: %v", v)
	}
}

// OutputSplunkLbQueueFullBehavior - Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputSplunkLbQueueFullBehavior string

const (
	OutputSplunkLbQueueFullBehaviorBlock OutputSplunkLbQueueFullBehavior = "block"
	OutputSplunkLbQueueFullBehaviorDrop  OutputSplunkLbQueueFullBehavior = "drop"
)

func (e OutputSplunkLbQueueFullBehavior) ToPointer() *OutputSplunkLbQueueFullBehavior {
	return &e
}
func (e *OutputSplunkLbQueueFullBehavior) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "block":
		fallthrough
	case "drop":
		*e = OutputSplunkLbQueueFullBehavior(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSplunkLbQueueFullBehavior: %v", v)
	}
}

// OutputSplunkLbMode - In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputSplunkLbMode string

const (
	OutputSplunkLbModeError        OutputSplunkLbMode = "error"
	OutputSplunkLbModeBackpressure OutputSplunkLbMode = "backpressure"
	OutputSplunkLbModeAlways       OutputSplunkLbMode = "always"
)

func (e OutputSplunkLbMode) ToPointer() *OutputSplunkLbMode {
	return &e
}
func (e *OutputSplunkLbMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "error":
		fallthrough
	case "backpressure":
		fallthrough
	case "always":
		*e = OutputSplunkLbMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSplunkLbMode: %v", v)
	}
}

type OutputSplunkLbPqControls struct {
}

type OutputSplunkLb struct {
	// Unique ID for this output
	ID   *string            `json:"id,omitempty"`
	Type OutputSplunkLbType `json:"type"`
	// Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`
	// Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields []string `json:"systemFields,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Re-resolve any hostnames every this many seconds and pick up destinations from A records.
	DNSResolvePeriodSec *float64 `default:"600" json:"dnsResolvePeriodSec"`
	// How far back in time to keep traffic stats for load balancing purposes.
	LoadBalanceStatsPeriodSec *float64 `default:"300" json:"loadBalanceStatsPeriodSec"`
	// Maximum number of concurrent connections (per worker process). A random set of IPs will be picked on every DNS resolution period. Use 0 for unlimited.
	MaxConcurrentSenders *float64 `default:"0" json:"maxConcurrentSenders"`
	// How to serialize nested fields into index-time fields
	NestedFields *OutputSplunkLbNestedFieldSerialization `default:"none" json:"nestedFields"`
	// Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
	ThrottleRatePerSec *string `default:"0" json:"throttleRatePerSec"`
	// Amount of time (milliseconds) to wait for the connection to establish before retrying
	ConnectionTimeout *float64 `default:"10000" json:"connectionTimeout"`
	// Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead
	WriteTimeout *float64                             `default:"60000" json:"writeTimeout"`
	TLS          *OutputSplunkLbTLSSettingsClientSide `json:"tls,omitempty"`
	// Output metrics in multiple-metric format in a single event. Supported in Splunk 8.0 and above.
	EnableMultiMetrics *bool `default:"false" json:"enableMultiMetrics"`
	// Check if indexer is shutting down and stop sending data. This helps minimize data loss during shutdown.
	EnableACK *bool `default:"true" json:"enableACK"`
	// Use to troubleshoot issues with sending data
	LogFailedRequests *bool `default:"false" json:"logFailedRequests"`
	// The highest S2S protocol version to advertise during handshake
	MaxS2Sversion *OutputSplunkLbMaxS2SVersion `default:"v3" json:"maxS2Sversion"`
	// Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputSplunkLbBackpressureBehavior `default:"block" json:"onBackpressure"`
	// Automatically discover indexers in indexer clustering environment.
	IndexerDiscovery *bool `default:"false" json:"indexerDiscovery"`
	// How long (in milliseconds) each LB endpoint can report blocked before the Destination reports unhealthy, blocking the sender. (Grace period for fluctuations.) Use 0 to disable; max 1 minute.
	SenderUnhealthyTimeAllowance *float64 `default:"100" json:"senderUnhealthyTimeAllowance"`
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType    *OutputSplunkLbAuthenticationMethod `default:"manual" json:"authType"`
	Description *string                             `json:"description,omitempty"`
	// Maximum number of times healthcheck can fail before we close connection. If set to 0 (disabled), and the connection to Splunk is forcibly closed, some data loss might occur.
	MaxFailedHealthChecks *float64 `default:"1" json:"maxFailedHealthChecks"`
	// List of configurations to set up indexer discovery in Splunk Indexer clustering environment.
	IndexerDiscoveryConfigs *IndexerDiscoveryConfigs `json:"indexerDiscoveryConfigs,omitempty"`
	// Exclude all IPs of the current host from the list of any resolved hostnames.
	ExcludeSelf *bool `default:"false" json:"excludeSelf"`
	// Set of Splunk indexers to load-balance data to.
	Hosts []Hosts `json:"hosts"`
	// The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `default:"1 MB" json:"pqMaxFileSize"`
	// The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `default:"5GB" json:"pqMaxSize"`
	// The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `default:"\\$CRIBL_HOME/state/queues" json:"pqPath"`
	// Codec to use to compress the persisted data.
	PqCompress *OutputSplunkLbCompression `default:"none" json:"pqCompress"`
	// Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputSplunkLbQueueFullBehavior `default:"block" json:"pqOnBackpressure"`
	// In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode     *OutputSplunkLbMode       `default:"error" json:"pqMode"`
	PqControls *OutputSplunkLbPqControls `json:"pqControls,omitempty"`
	// Shared secret token to use when establishing a connection to a Splunk indexer.
	AuthToken *string `default:"" json:"authToken"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (o OutputSplunkLb) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OutputSplunkLb) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *OutputSplunkLb) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *OutputSplunkLb) GetType() OutputSplunkLbType {
	if o == nil {
		return OutputSplunkLbType("")
	}
	return o.Type
}

func (o *OutputSplunkLb) GetPipeline() *string {
	if o == nil {
		return nil
	}
	return o.Pipeline
}

func (o *OutputSplunkLb) GetSystemFields() []string {
	if o == nil {
		return nil
	}
	return o.SystemFields
}

func (o *OutputSplunkLb) GetEnvironment() *string {
	if o == nil {
		return nil
	}
	return o.Environment
}

func (o *OutputSplunkLb) GetStreamtags() []string {
	if o == nil {
		return nil
	}
	return o.Streamtags
}

func (o *OutputSplunkLb) GetDNSResolvePeriodSec() *float64 {
	if o == nil {
		return nil
	}
	return o.DNSResolvePeriodSec
}

func (o *OutputSplunkLb) GetLoadBalanceStatsPeriodSec() *float64 {
	if o == nil {
		return nil
	}
	return o.LoadBalanceStatsPeriodSec
}

func (o *OutputSplunkLb) GetMaxConcurrentSenders() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxConcurrentSenders
}

func (o *OutputSplunkLb) GetNestedFields() *OutputSplunkLbNestedFieldSerialization {
	if o == nil {
		return nil
	}
	return o.NestedFields
}

func (o *OutputSplunkLb) GetThrottleRatePerSec() *string {
	if o == nil {
		return nil
	}
	return o.ThrottleRatePerSec
}

func (o *OutputSplunkLb) GetConnectionTimeout() *float64 {
	if o == nil {
		return nil
	}
	return o.ConnectionTimeout
}

func (o *OutputSplunkLb) GetWriteTimeout() *float64 {
	if o == nil {
		return nil
	}
	return o.WriteTimeout
}

func (o *OutputSplunkLb) GetTLS() *OutputSplunkLbTLSSettingsClientSide {
	if o == nil {
		return nil
	}
	return o.TLS
}

func (o *OutputSplunkLb) GetEnableMultiMetrics() *bool {
	if o == nil {
		return nil
	}
	return o.EnableMultiMetrics
}

func (o *OutputSplunkLb) GetEnableACK() *bool {
	if o == nil {
		return nil
	}
	return o.EnableACK
}

func (o *OutputSplunkLb) GetLogFailedRequests() *bool {
	if o == nil {
		return nil
	}
	return o.LogFailedRequests
}

func (o *OutputSplunkLb) GetMaxS2Sversion() *OutputSplunkLbMaxS2SVersion {
	if o == nil {
		return nil
	}
	return o.MaxS2Sversion
}

func (o *OutputSplunkLb) GetOnBackpressure() *OutputSplunkLbBackpressureBehavior {
	if o == nil {
		return nil
	}
	return o.OnBackpressure
}

func (o *OutputSplunkLb) GetIndexerDiscovery() *bool {
	if o == nil {
		return nil
	}
	return o.IndexerDiscovery
}

func (o *OutputSplunkLb) GetSenderUnhealthyTimeAllowance() *float64 {
	if o == nil {
		return nil
	}
	return o.SenderUnhealthyTimeAllowance
}

func (o *OutputSplunkLb) GetAuthType() *OutputSplunkLbAuthenticationMethod {
	if o == nil {
		return nil
	}
	return o.AuthType
}

func (o *OutputSplunkLb) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *OutputSplunkLb) GetMaxFailedHealthChecks() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxFailedHealthChecks
}

func (o *OutputSplunkLb) GetIndexerDiscoveryConfigs() *IndexerDiscoveryConfigs {
	if o == nil {
		return nil
	}
	return o.IndexerDiscoveryConfigs
}

func (o *OutputSplunkLb) GetExcludeSelf() *bool {
	if o == nil {
		return nil
	}
	return o.ExcludeSelf
}

func (o *OutputSplunkLb) GetHosts() []Hosts {
	if o == nil {
		return []Hosts{}
	}
	return o.Hosts
}

func (o *OutputSplunkLb) GetPqMaxFileSize() *string {
	if o == nil {
		return nil
	}
	return o.PqMaxFileSize
}

func (o *OutputSplunkLb) GetPqMaxSize() *string {
	if o == nil {
		return nil
	}
	return o.PqMaxSize
}

func (o *OutputSplunkLb) GetPqPath() *string {
	if o == nil {
		return nil
	}
	return o.PqPath
}

func (o *OutputSplunkLb) GetPqCompress() *OutputSplunkLbCompression {
	if o == nil {
		return nil
	}
	return o.PqCompress
}

func (o *OutputSplunkLb) GetPqOnBackpressure() *OutputSplunkLbQueueFullBehavior {
	if o == nil {
		return nil
	}
	return o.PqOnBackpressure
}

func (o *OutputSplunkLb) GetPqMode() *OutputSplunkLbMode {
	if o == nil {
		return nil
	}
	return o.PqMode
}

func (o *OutputSplunkLb) GetPqControls() *OutputSplunkLbPqControls {
	if o == nil {
		return nil
	}
	return o.PqControls
}

func (o *OutputSplunkLb) GetAuthToken() *string {
	if o == nil {
		return nil
	}
	return o.AuthToken
}

func (o *OutputSplunkLb) GetTextSecret() *string {
	if o == nil {
		return nil
	}
	return o.TextSecret
}
